<!DOCTYPE html>
<meta charset="utf-8">
<title>managerManager.getState</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../resources/test-helpers.sub.js"></script>
<script src="resources/helpers.js"></script>
<body>
<script>
function post_and_wait_for_reply(worker, message) {
  return new Promise(resolve => {
      navigator.serviceWorker.onmessage = e => { resolve(e.data); };
      worker.postMessage(message);
    });
}

promise_test(async t => {
  const scope = '../resources/get-state';
  const script = '../resources/empty-worker.js';

  const registration =
      await service_worker_unregister_and_register(t, script, scope);

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
  })

  const manager = registration.navigationPreload;
  await wait_for_state(t, registration.installing, 'activated');
  let state = await manager.getState();
  expect_navigation_preload_state(state, false, 'true', 'default state');
  let result = await manager.enable();
  assert_equals(result, undefined, 'enable() should resolve to undefined');
  state = await manager.getState();
  expect_navigation_preload_state(state, true, 'true', 'state after enable()');
  result = await manager.disable();
  assert_equals(result, undefined, 'disable() should resolve to undefined');
  state = await manager.getState();
  expect_navigation_preload_state(state, false, 'true',
                                  'state after disable()');
  result = await manager.setHeaderValue('dreams that cannot be');
  assert_equals(result, undefined,
                'setHeaderValue() should resolve to undefined');
  state = await manager.getState();
  expect_navigation_preload_state(state, false, 'dreams that cannot be',
                                  'state after setHeaderValue()');
  await manager.setHeaderValue('');
  state = await manager.getState();
  expect_navigation_preload_state(state, false, '',
                                  'after setHeaderValue to empty string');
  await manager.setHeaderValue(null);
  state = await manager.getState();
  expect_navigation_preload_state(state, false, 'null',
                                  'after setHeaderValue to null');
  await promise_rejects(t,
            new TypeError,
            manager.setHeaderValue('what\uDC00\uD800this'),
            'setHeaderValue() should throw if passed surrogates');
  await promise_rejects(t,
            new TypeError,
            manager.setHeaderValue('zer\0o'),
            'setHeaderValue() should throw if passed \\0');
  await promise_rejects(t,
            new TypeError,
            manager.setHeaderValue('\rcarriage'),
            'setHeaderValue() should throw if passed \\r');
  await promise_rejects(t,
            new TypeError,
            manager.setHeaderValue('newline\n'),
            'setHeaderValue() should throw if passed \\n');
  await promise_rejects(t,
            new TypeError,
            manager.setHeaderValue(),
            'setHeaderValue() should throw if passed undefined');
  await manager.enable();
  state = await manager.getState();
  expect_navigation_preload_state(state, true, 'null',
                                  'enable() should not change header');
}, 'getState');

// This test sends commands to a worker to call enable()/disable()/getState().
// It checks the results from the worker and verifies that they match the
// navigation preload state accessible from the page.
promise_test(async t => {
  const SCOPE = 'resources/get-state-worker';
  const SCRIPT = 'resources/get-state-worker.js';

  const registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
  })

  const worker = registration.installing;
  await wait_for_state(t, worker, 'activated');
  let data = await post_and_wait_for_reply(worker, 'getState');
  let states = await Promise.all([data,
                                 registration.navigationPreload.getState()]);
  expect_navigation_preload_state(states[0], false, 'true',
                                  'default state (from worker)');
  expect_navigation_preload_state(states[1], false, 'true',
                                  'default state (from page)');

  data = await post_and_wait_for_reply(worker, 'enable');
  assert_equals(data, undefined, 'enable() should resolve to undefined');
  states = await Promise.all([
            post_and_wait_for_reply(worker, 'getState'),
            registration.navigationPreload.getState()]);
  expect_navigation_preload_state(states[0], true, 'true',
                                  'state after enable() (from worker)');
  expect_navigation_preload_state(states[1], true, 'true',
                                  'state after enable() (from page)');

  // Call disable() and then getState().
  data = await post_and_wait_for_reply(worker, 'disable');
  assert_equals(data, undefined,
                '.disable() should resolve to undefined');
  states = await Promise.all([
      post_and_wait_for_reply(worker, 'getState'),
      registration.navigationPreload.getState()]);
  expect_navigation_preload_state(states[0], false, 'true',
                                  'state after disable() (from worker)');
  expect_navigation_preload_state(states[1], false, 'true',
                                  'state after disable() (from page)');

  data = await post_and_wait_for_reply(worker, 'setHeaderValue');
  states = await Promise.all([
           post_and_wait_for_reply(worker, 'getState'),
           registration.navigationPreload.getState()]);
  expect_navigation_preload_state(states[0], false, 'insightful',
      'state after setHeaderValue() (from worker)');
  expect_navigation_preload_state(states[1], false, 'insightful',
      'state after setHeaderValue() (from page)');
}, 'getState from a worker');

// This tests navigation preload API when there is no active worker. It calls
// the API from the main page and then from the worker itself.
promise_test(async t => {
  const SCOPE = 'resources/wait-for-activate-worker';
  const SCRIPT = 'resources/wait-for-activate-worker.js';

  const registration =
      await service_worker_unregister_and_register(t, SCRIPT, SCOPE);
  const manager = registration.navigationPreload;

  add_completion_callback(async() => {
    if (registration)
      await registration.unregister();
  });

  await Promise.all([
        promise_rejects(
            t, 'InvalidStateError', manager.enable(),
            'enable should reject if there is no active worker'),
        promise_rejects(
            t, 'InvalidStateError', manager.disable(),
            'disable should reject if there is no active worker'),
        promise_rejects(
            t, 'InvalidStateError', manager.setHeaderValue('umm'),
            'setHeaderValue should reject if there is no active worker')]);
  const state = await manager.getState();
  expect_navigation_preload_state(state, false, 'true',
                                  'state before activation');
  const result = await post_and_wait_for_reply(registration.installing,
                                               'ping');
  assert_equals(result, 'PASS');
}, 'no active worker');
</script>
</body>
