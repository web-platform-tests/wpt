<!DOCTYPE html>
<title>Service Worker: registration end-to-end</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
promise_test(async t => {
  const SCOPE = 'resources/in-scope/';
  const SCRIPT = 'resources/end-to-end-worker.js';
  let serviceWorkerStates = [];
  const currentChangeCount = 0;

  assert_true(navigator.serviceWorker instanceof ServiceWorkerContainer);
  assert_equals(typeof navigator.serviceWorker.register, 'function');
  assert_equals(typeof navigator.serviceWorker.getRegistration, 'function');

  navigator.serviceWorker.oncurrentchange = function() {
    ++currentChangeCount;
  };

  const registration = await service_worker_unregister_and_register(
    t,
    SCRIPT,
    SCOPE
  );

  function sendMessagePort(worker, from) {
    const messageChannel = new MessageChannel();
    worker.postMessage({from:from, port:messageChannel.port2}, [messageChannel.port2]);
    return messageChannel.port1;
  }

  async function onRegister(registration) {
    const sw = registration.installing;
    serviceWorkerStates.push(sw.state);
    lastServiceWorkerState = sw.state;

    const sawMessage =  new Promise(resolve => {
      sendMessagePort(sw, 'registering doc').onmessage = function (e) {
        receivedMessageFromPort = e.data;
        resolve();
      };
    });

    const sawActive = new Promise(resolve => {
      sw.onstatechange = function() {
        serviceWorkerStates.push(sw.state);

        switch (sw.state) {
        case 'installed':
          assert_equals(lastServiceWorkerState, "installing");
          break;
        case 'activating':
          assert_equals(lastServiceWorkerState, "installed");
          break;
        case 'activated':
          assert_equals(lastServiceWorkerState, "activating");
          break;
        default:
          // We won't see "redundant" because onstatechange is
          // overwritten before calling unregister.
          assert_unreached("Unexpected state: " + sw.state);
        };

        lastServiceWorkerState = sw.state;
        if (sw.state === 'activated')
          resolve();
      };
    });

    await Promise.all([sawMessage, sawActive]);

    t.add_cleanup(async() => {
      if (registration)  await registration.unregister();
    });

    assert_array_equals(serviceWorkerStates,
                        ['installing', "installed", "activating", "activated"],
                        "Service worker should pass through all states");

    assert_equals(currentChangeCount, 0,
                  "Should not see current changes since document is out of scope");

    assert_equals(receivedMessageFromPort, "Ack for: registering doc");

    await new Promise(resolve => {
      sw.onstatechange = function() {
        assert_equals(sw.state, "redundant");
        resolve();
      };
    });
  };
});

</script>
