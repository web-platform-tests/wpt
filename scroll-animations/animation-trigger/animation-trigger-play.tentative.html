<!DOCTYPE html>
<html>
  <head>
    <link rel="help" src="https://drafts.csswg.org/css-animations-2/#animation-trigger">
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="/web-animations/testcommon.js"></script>
    <script src="/dom/events/scrolling/scroll_support.js"></script>
    <script src="support/support.js"></script>
  </head>
  <body>
    <style>
      @keyframes expand {
        from { transform: scaleX(1); }
        to { transform: scaleX(5); }
      }
      .subject, .target {
        height: 50px;
        width: 50px;
        background-color: red;
      }
      #target {
        animation: expand linear 10s forwards;
        animation-trigger: --trigger play;
      }
      #subject {
        timeline-trigger: --trigger view() 150px 200px;
      }

      .scroller {
        overflow-y: scroll;
        height: 500px;
        width: 500px;
        border: solid 1px;
        position: relative;
      }
      #space {
        width: 50px;
        height: 600px;
      }
    </style>
    <div id="wrapper">
      <div id="scroller" class="scroller">
        <div id="space"></div>
        <div id="subject" class="subject" tabindex="0"></div>
        <div id="space"></div>
      </div>
      <div id="target" class="target" tabindex="0"></div>
    </div>
    <script>
      const CSS_ANIMATION_DURATION = 10000;

      const COVER_START_OFFSET = 100;
      // The activation and active ranges are the same for this test.
      const CSS_TRIGGER_START_PX = 150;
      const CSS_TRIGGER_END_PX = 200;
      const ACTIVATION_RANGE_START_PX = COVER_START_OFFSET + CSS_TRIGGER_START_PX;
      const ACTIVATION_RANGE_END_PX = COVER_START_OFFSET + CSS_TRIGGER_END_PX;

      const enter = () => {
        return runAndWaitForFrameUpdate(async () => {
          scroller.scrollTop =
              (ACTIVATION_RANGE_START_PX + ACTIVATION_RANGE_END_PX) / 2;
        });
      }

      const exit = () => {
        return runAndWaitForFrameUpdate(async () => {
          scroller.scrollTop = ACTIVATION_RANGE_END_PX + 100;
        });
      }

      const reset = () => {
        const animation = target.getAnimations()[0];
        animation.pause();
        animation.currentTime = 0;
        scroller.scrollTop = 0;
      }

      promise_test(async (test) => {
        const animation = target.getAnimations()[0];
        assert_equals(animation.playState, "paused");

        // Entering the activation range should result in playing.
        await enter();
        assert_equals(animation.playState, "running");

        animation.pause();
        animation.currentTime = CSS_ANIMATION_DURATION / 2;
        assert_times_equal(animation.currentTime, CSS_ANIMATION_DURATION / 2);
        assert_equals(animation.playState, "paused");

        // Exiting the active range should have no effect.
        await exit();
        assert_equals(animation.playState, "paused");
        assert_times_equal(animation.currentTime, CSS_ANIMATION_DURATION / 2);

        // Re-entering the activation range should resume playing from where it
        // left off.
        await enter();
        await waitForAnimationFrames(2);
        assert_equals(animation.playState, "running");
        assert_greater_than(animation.currentTime,
                                 CSS_ANIMATION_DURATION / 2);
      }, "play behavior resumes a paused animation");

      promise_test(async (test) => {
        reset();
        const animation = target.getAnimations()[0];
        assert_equals(animation.playState, "paused");

        // Entering the activation range should result in playing.
        await enter();
        assert_equals(animation.playState, "running");

        animation.finish();
        assert_times_equal(animation.currentTime, CSS_ANIMATION_DURATION);
        assert_equals(animation.playState, "finished");

        // Exiting the active range should have no effect.
        await exit();
        assert_equals(animation.playState, "finished");
        assert_times_equal(animation.currentTime, CSS_ANIMATION_DURATION);

        // Re-entering the activation range should restart the animation.
        await enter();
        await waitForAnimationFrames(2);
        assert_equals(animation.playState, "running");
        assert_greater_than(animation.currentTime, 0);
      }, "play behavior restarts a finished animation");
</script>
  </body>
</html>
