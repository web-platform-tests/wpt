<!doctype html>
<meta charset=utf-8>
<meta name=timeout content=long>
<title>RTCDataChannel id attribute</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

// This is the maximum number of streams, NOT the maximum stream ID (which is 65534)
// See: https://tools.ietf.org/html/draft-ietf-rtcweb-data-channel-13#section-6.2
const nStreams = 65535;

/*
  6.1.
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL] [...]
 */
promise_test(t => {
  const pc = new RTCPeerConnection;
  const channel = pc.createDataChannel('');
  const ids = new UniqueSet();

  return pc.createOffer()
  .then(offer => pc.setLocalDescription(offer))
  .then(() => {
    // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
    // "active".
    const answer = {
      type: "answer",
      sdp: pc.localDescription.sdp.replace("actpass", "active")
    };
    return pc.setRemoteDescription(answer);
  })
  .then(() => {
    // Since the remote description had an "active" DTLS role, we're the server
    // and should use odd data channel IDs, according to rtcweb-data-channel.
    assert_equals(channel.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${channel.id})`);
    const another_channel = pc.createDataChannel('another');
    assert_equals(another_channel.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${channel.id})`);

    // Ensure IDs are unique
    ids.add(channel.id, `Channel ID ${channel.id} should be unique`);
    ids.add(another_channel.id, `Channel ID ${another_channel.id} should be unique`);
  })
}, "DTLS client uses odd data channel IDs");

promise_test(t => {
  const pc = new RTCPeerConnection;
  const channel = pc.createDataChannel('');
  const ids = new UniqueSet();

  return pc.createOffer()
  .then(offer => pc.setLocalDescription(offer))
  .then(() => {
    // Turn our own offer SDP into valid answer SDP by setting the DTLS role to
    // "passive".
    const answer = {
      type: "answer",
      sdp: pc.localDescription.sdp.replace("actpass", "passive")
    };
    return pc.setRemoteDescription(answer);
  })
  .then(() => {
    // Since the remote description had a "passive" DTLS role, we're the client
    // and should use even data channel IDs, according to rtcweb-data-channel.
    assert_equals(channel.id % 2, 0,
      `Channel created by the DTLS client role must be even (was ${channel.id})`);
    const another_channel = pc.createDataChannel('another');
    assert_equals(another_channel.id % 2, 0,
      `Channel created by the DTLS client role must be even (was ${channel.id})`);

    // Ensure IDs are unique
    ids.add(channel.id, `Channel ID ${channel.id} should be unique`);
    ids.add(another_channel.id, `Channel ID ${another_channel.id} should be unique`);
  })
}, "DTLS server uses even data channel IDs");

/*
  Check if the implementation allows using in-band negotiated channels with a specific ID (which
  is now a spec violation).
 */
async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dc1 = pc1.createDataChannel('', {
    negotiated: false,
    id: 42
  });
  dc1.onopen = t.step_func(() => {
    dc1.send(':(');
  });

  const dc2 = pc2.createDataChannel('', {
    negotiated: false,
    id: 42
  });
  dc2.onmessage = t.step_func((event) => {
    assert_unreached('Channel established with same ID using negotiated=false');
  });

  exchangeIceCandidates(pc1, pc2);
  doSignalingHandshake(pc1, pc2)
  .then(() => {
    t.step_timeout(t.step_func_done(), 1000)
  })
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'In-band negotiation with a specific ID should not be allowed');

/*
  Check if the implementation still follows the odd/even role correctly if we annoy it with
  negotiated channels not following that rule.

  Note: This test assumes that the implementation can handle a minimum of 40 data channels.
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  exchangeIceCandidates(pc1, pc2);
  const channels = [];
  const negotiatedChannels = [];
  const ids = new UniqueSet();

  // Create 10 DCEP-negotiated channels with pc1
  // Note: These should not have any associated valid ID at this point
  for (let i = 0; i < 10; ++i) {
    const dc = pc1.createDataChannel('before-connection');
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    channels.push(dc);
  }

  // Create 10 negotiated channels with pc1 violating the odd/even rule
  for (let id = 0; id < 20; id += 2) {
    const dc = pc1.createDataChannel(`negotiated-not-odd-${id}-before-connection`, {
      negotiated: true,
      id: id,
    });
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    negotiatedChannels.push([dc, id]);
    ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
  }

  return doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  })
  .then(() => {
    for (const dc of channels) {
      assert_equals(dc.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc.id})`);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }

    // Create 10 channels with pc1
    for (let i = 0; i < 10; ++i) {
      const dc = pc1.createDataChannel('after-connection');
      assert_equals(dc.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc.id})`);
      channels.push(dc);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }

    // Create 10 negotiated channels with pc1 violating the odd/even rule
    for (let i = 0; i < 10; ++i) {
      // Generate a valid even ID that has not been taken, yet.
      let id = 20;
      while (ids.has(id)) {
        id += 2;
      }
      const dc = pc1.createDataChannel(`negotiated-not-odd-${i}-after-connection`, {
        negotiated: true,
        id: id,
      });
      negotiatedChannels.push([dc, id]);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }

    // Since we've added new channels, let's check again that the odd/even role is not violated
    for (const dc of channels) {
      assert_equals(dc.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc.id})`);
    }

    // Let's also make sure the negotiated channels have kept their ID
    for (const [dc, id] of negotiatedChannels) {
      assert_equals(dc.id, id, 'Negotiated channels should keep their assigned ID');
    }
  });
}, 'Odd/even role should not be violated when mixing with negotiated channels');

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted AFTER
  establishing a peer connection.

  6.1.  createDataChannel
    21. If the [[DataChannelId]] slot is null (due to no ID being passed into
        createDataChannel, or [[Negotiated]] being false), and the DTLS role of the SCTP
        transport has already been negotiated, then initialize [[DataChannelId]] to a value
        generated by the user agent, according to [RTCWEB-DATA-PROTOCOL], and skip
        to the next step. If no available ID could be generated, or if the value of the
        [[DataChannelId]] slot is being used by an existing RTCDataChannel, throw an
        OperationError exception.

  TODO: Needs updating in case https://github.com/w3c/webrtc-pc/issues/1829 turns out positive
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  const ids = new UniqueSet();

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  return createDataChannelPair(pc1, pc2, {
    channelLabel: 'initial',
    modifyOffer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    modifyAnswer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  })
  .then(([dc1, dc2]) => {
    // At this point, one channel id is already taken and it MUST be odd since pc1 created it
    assert_equals(dc1.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
    assert_equals(dc2.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc2.id})`);
    ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`); // dc2 is the same channel on the other peer

    // Create 65534 further channels
    // Note: Since 65535 streams is a SHOULD, we may have less than that
    for (let i = 1; i < nStreams; ++i) {
      let dc;

      // The first two channels and all even streams need to be created by pc2
      if (i < 2 || i % 2 === 0) {
        try {
          dc = pc2.createDataChannel('this is going to be fun');
        } catch (e) {
          assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
          break;
        }
        assert_equals(dc.id % 2, 0,
          `Channel #${i + 2} created by the DTLS client role must be even (was ${dc.id})`);
      } else {
        try {
          dc = pc1.createDataChannel('this is going to be fun, too');
        } catch (e) {
          assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
          break;
        }
        assert_equals(dc.id % 2, 1,
          `Channel #${i + 2} created by the DTLS server role must be odd (was ${dc.id})`);
      }

      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }

    // Try creating one further channel on both sides. The attempt should fail.
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
    assert_throws('OperationError', () =>
      pc2.createDataChannel('this is too exhausting!'));
  });
}, 'Creating a channel after exhausting the maximum number of channels should throw ' +
  'OperationError (after connection establishment)');

/*
  Ensure an ID cannot be reused before the former channel with the same ID has been closed.
  See: https://bugs.chromium.org/p/chromium/issues/detail?id=559394
 */
async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  createDataChannelPair(pc1, pc2, { channelLabel: 'test' })
  .then(([dc1, dc2]) => {
    let done = false;
    assert_not_equals(dc1.id, null, 'Expect dc1.id to be assigned after dc1 opened');
    const id = dc1.id;

    dc2.onclose = t.step_func(() => {
      // Give pc1 a chance to create the new data channel.
      t.step_timeout(() => {
        assert_true(done, 'pc1 should be done by now');
        t.done();
      }, 100);
    });

    // Close immediately and reuse the ID
    // Note: Be aware that this is a race but the JS should always be faster than the reset
    //       dance on the network.
    dc1.close();
    assert_throws('OperationError', () => {
      pc1.createDataChannel('id-reuse', {
        negotiated: true,
        id: id
      })
    });
    done = true;
  })
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'ID reuse should not be possible before the former channel with the same ID closed');

/*
  Ensure an ID can be reused once the former channel with the same ID has been closed.
 */
async_test(t => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  createDataChannelPair(pc1, pc2, { channelLabel: 'test' })
  .then(([dc1, _]) => {
    assert_not_equals(dc1.id, null, 'Expect dc1.id to be assigned after dc1 opened');
    const id = dc1.id;

    dc1.onclose = t.step_func(() => {
      // Immediately reuse the channel ID and wait for it to open
      const dc = pc1.createDataChannel('id-reuse', {
        negotiated: true,
        id: id
      });
      dc.onopen = t.step_func(() => t.done());
      assert_equals(dc.id, id, "Expect dc.id to match former channel's dc1.id");
      t.step_timeout(() => assert_unreached('dc did not open in time'), 1000);
    });

    dc1.close();
  })
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'ID reuse should be possible once the former channel with the same ID closed');

/*
  Create channels until exhaustion, close one, open one (this should work), open another
  (this should fail).

  TODO: Needs updating in case https://github.com/w3c/webrtc-pc/issues/1829 turns out positive
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  const channels = [];
  const ids = new UniqueSet();

  // We need the initial data channel on the DTLS server side to ensure the peer connection
  // will be established
  return createDataChannelPair(pc1, pc2, {
    channelLabel: 'initial',
    modifyOffer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    modifyAnswer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  })
  .then(([dc1, dc2]) => {
    // At this point, one channel id is already taken and it MUST be odd since pc1 created it
    assert_equals(dc1.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc1.id})`);
    assert_equals(dc2.id % 2, 1,
      `Channel created by the DTLS server role must be odd (was ${dc2.id})`);
    ids.add(dc1.id, `Channel ID ${dc1.id} should be unique`); // dc2 is the same channel on the other peer

    // Create 65534 further channels with pc1
    // Note: Since we do this on pc1 only, IDs should be exhausted after 32767 channels
    for (let i = 1; i < nStreams; ++i) {
      let dc;
      try {
        dc = pc1.createDataChannel('test');
      } catch (e) {
        assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
        break;
      }
      assert_equals(dc.id % 2, 1,
        `Channel #${i + 2} created by the DTLS server role must be even (was ${dc.id})`);

      channels.push(dc);
      ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
    }

    // Try creating one further channel with pc1. The attempt should fail.
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));

    // Close a channel and wait until it's closed
    return new Promise((resolve) => {
      const dc = channels[0];
      const id = dc.id;
      dc.onclose = () => resolve(id);
      dc.close();
    });
  })
  .then((id) => {
    // Create a new channel, ensure the ID has been reassigned
    const dc = pc1.createDataChannel('reassigned?');
    assert_equals(dc.id, id, `ID ${id} should be reassigned to new channel`);
  });
}, 'Channel IDs should be reassigned after exhaustion in case a channel has been closed');

/*
  Create 66535 channels with the DTLS client role. Ensure the odd/even rule is not violated.
 */
promise_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  exchangeIceCandidates(pc1, pc2);
  const channels = [];
  const ids = new UniqueSet();

  // Create 65535+1000 channels with pc1
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it may
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < (nStreams + 1000); ++i) {
    const dc = pc1.createDataChannel('test');
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push(dc);
  }

  return doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  })
  .then(() => {
    for (const dc of channels) {
      if (dc.readyState !== 'closed') {
        assert_equals(dc.id % 2, 1,
          `Channel created by the DTLS server role must be odd (was ${dc.id})`);
        ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
      }
    }

    // Try creating one further channel on both sides. The attempt should fail since all IDs are
    // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
  });
}, 'Exhausting channels with one peer should not violate the odd/even rule');

/*
  Create 32768 (client), 32767 (server) channels to make sure all ids are exhausted BEFORE
  establishing a peer connection.

  Be aware that late channel id assignment can currently fail in many places not covered by the
  spec, see: https://github.com/w3c/webrtc-pc/issues/1818

  4.4.1.6.
    2.2.6.  If description negotiates the DTLS role of the SCTP transport, and there is an
            RTCDataChannel with a null id, then generate an ID according to [RTCWEB-DATA-PROTOCOL].
            If no available ID could be generated, then run the following steps:
      1.    Let channel be the RTCDataChannel object for which an ID could not be generated.
      2.    Set channel's [[ReadyState]] slot to "closed".
      3.    Fire an event named error with an OperationError exception at channel.
      4.    Fire a simple event named close at channel.
 */
async_test(t => {
  // Takes the DTLS server role
  const pc1 = new RTCPeerConnection();
  // Takes the DTLS client role
  const pc2 = new RTCPeerConnection();

  exchangeIceCandidates(pc1, pc2);
  const channels = [];
  const ids = new UniqueSet();
  let nExpected = 0;
  let nActualCloses = 0;
  let nActualErrors = 0;

  const maybeDone = t.step_func(() => {
    if (nExpected === nActualCloses && nExpected === nActualErrors) {
      t.done();
    }
  });

  // Create 65535+2 channels (since 65535 streams is a SHOULD, we may have less than that.)
  // Create two extra channels to possibly trigger the steps in the description.
  //
  // Note: Following the spec strictly would assume that this cannot fail. But in reality it will
  //       fail because the implementation knows how many streams it supports. What it doesn't
  //       know is how many streams the other peer supports (e.g. what will be negotiated).
  for (let i = 0; i < (nStreams + 2); ++i) {
    let dc;
    try {
      const pc = i % 2 === 1 ? pc1 : pc2;
      dc = pc.createDataChannel('this is going to be fun');
      dc.onclose = t.step_func(() => {
        ++nActualCloses;
        maybeDone();
      });
      dc.onerror = t.step_func((e) => {
        assert_true(e instanceof RTCError, 'Expect error object to be instance of RTCError');
        assert_equals(e.error, 'sctp-failure', "Expect error to be of type 'sctp-failure'");
        ++nActualErrors;
        maybeDone();
      });
    } catch (e) {
      assert_equals(e.name, 'OperationError', 'Fail on creation should throw OperationError');
      break;
    }
    assert_equals(dc.id, null, 'Channel id must be null before DTLS role has been determined');
    assert_not_equals(dc.readyState, 'closed',
      'Channel may not be closed before connection establishment');
    channels.push([dc, i % 2 === 1]);
  }

  doSignalingHandshake(pc1, pc2, {
    offer: (offer) => {
      // Ensure pc1 takes the server role
      assert_true(offer.sdp.includes('actpass') || offer.sdp.includes('passive'),
        'pc1 must take the DTLS server role');
      return offer;
    },
    answer: (answer) => {
      // Ensure pc2 takes the client role
      // Note: It very likely will choose 'active' itself
      answer.sdp = answer.sdp.replace('actpass', 'active');
      assert_true(answer.sdp.includes('active'), 'pc2 must take the DTLS client role');
      return answer;
    },
  })
  .then(() => {
    // Since the spec does not define a specific order to which channels may fail if an ID could
    // not be generated, any of the channels may be affected by the steps of the description.
    for (const [dc, odd] of channels) {
      if (dc.readyState !== 'closed') {
        assert_equals(dc.id % 2, odd ? 1 : 0,
          `Channels created by the DTLS ${odd ? 'server' : 'client'} role must be
          ${odd ? 'odd' : 'even'} (was ${dc.id})`);
        ids.add(dc.id, `Channel ID ${dc.id} should be unique`);
      } else {
        ++nExpected;
      }
    }

    // Try creating one further channel on both sides. The attempt should fail since all IDs are
    // taken. If one ID is available, the implementation probably miscounts (or I did in the test).
    assert_throws('OperationError', () =>
      pc1.createDataChannel('this is too exhausting!'));
    assert_throws('OperationError', () =>
      pc2.createDataChannel('this is too exhausting!'));
  })
  .then(() => {
    maybeDone();
  })
  .catch(t.step_func(err =>
    assert_unreached(`Unexpected promise rejection: ${err}`)));
}, 'Channel ID exhaustion handling (before and after connection establishment)');

</script>
