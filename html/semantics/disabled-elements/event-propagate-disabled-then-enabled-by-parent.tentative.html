<!DOCTYPE html>
<title>Form elements mutated to be disabled during propagation to parents</title>
<meta charset=utf8>
<meta name=timeout content=long>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="/resources/testdriver-actions.js"></script>

<!-- Things that have activation behaviors -->
<form id=cases>
  <button>Text</button>
  <button><span class="target">Span</span></button>
  <input type="button">
  <input type="checkbox">
  <!-- <input type="color" value="#000000"> Can't detect whether the picker opened -->
  <!-- <input type="file"> Can't detect whether the picker opened -->
  <input type="image">
  <input type="radio">
  <input type="range" value="0">
  <input type="reset">
  <input type="submit">
</form>

<script>
  /**
   * @param {Element} element
   */
  function getEventFiringTarget(element) {
    return element.querySelector(".target") || element;
  }

  /**
   * @param {HTMLElement} element
   * @param {object} options
   * @param {boolean} options.initialDisabled
   */
  function initialize(element, { initialDisabled }) {
    element.disabled = initialDisabled;
    switch (element.type) {
      case "checkbox":
      case "radio":
        element.checked = false;
        break;
      case "range":
        element.value = 0;
        break;
    }
  }

  /**
   * @param {HTMLElement} element
   * @param {string[]} observedEvents
   * @param {object} options
   * @param {boolean} options.initialDisabled
   */
  function assertStatus(element, observedEvents, { initialDisabled }) {
    switch (element.type) {
      case "checkbox":
      case "radio":
        // By legacy-pre-activation behavior
        // https://html.spec.whatwg.org/multipage/input.html#the-input-element:legacy-canceled-activation-behavior
        assert_equals(element.checked, !initialDisabled, `.checked should be ${!initialDisabled}`);
        if (!initialDisabled) {
          assert_array_equals(observedEvents, ["input", "change"], "Input and change events should be observed");
          return;
        }
        break;
      case "range":
        if (!initialDisabled) {
          assert_true(element.valueAsNumber > 0, ".value should be nonzero");
          assert_array_equals(observedEvents, ["input", "change"], "Input and change events should be observed");
          return;
        }
        assert_equals(element.valueAsNumber, 0, ".value should not change");
        break;
    }

    // const focusable = element.tabIndex !== -1 && !initialDisabled;

    // if (!focusable) {
    assert_array_equals(observedEvents, [], "No events should be observed");
    // } else if (element.localName === "button") {
    //   assert_array_equals(observedEvents, ["focus", "submit"], "Focus and submit events should be observed");
    // } else {
    //   assert_array_equals(observedEvents, ["focus"], "A focus event should be observed");
    // }
    // assert_equals(document.activeElement, document.body, "The focus should be at the body");
  }

  // /**
  //  * @param {Event} ev
  //  */
  // function preventDefaultIfNecessary(element, ev) {
  //   if (element.type === "file") {
  //     // Prevent opening a modal picker
  //     ev.preventDefault();
  //   }
  // }

  /**
   * @param {*} t
   * @param {Element} element
   * @param {object} options
   * @param {boolean} options.initialDisabled
   */
  function setupTest(t, element, { initialDisabled }) {
    const controller = new AbortController();
    t.add_cleanup(() => controller.abort());
    const { signal } = controller;

    /** @type {string[]} */
    const observedEvents = [];

    initialize(element, { initialDisabled });

    for (const event of ["input", "change"]) {
      element.addEventListener(event, t.step_func(event => {
        observedEvents.push(event.type);
      }), { signal });
    }
    for (const event of ["submit", "reset"]) {
      cases.addEventListener(event, t.step_func(event => {
        observedEvents.push(event.type);
        event.preventDefault();
      }), { signal });
    }

    cases.addEventListener("click", t.step_func(event => {
      element.disabled = !initialDisabled;
      // preventDefaultIfNecessary(element, event);
    }, { signal }));

    const target = getEventFiringTarget(element);
    return { target, observedEvents };
  }

  const elements = document.getElementById("cases").children;
  for (const element of elements) {
    promise_test(async t => {
      const { target, observedEvents } = setupTest(t, element, { initialDisabled: false });

      await test_driver.click(target);
      await new Promise(resolve => t.step_timeout(resolve, 0));

      assertStatus(element, observedEvents, { initialDisabled: false });
    }, `immediate propagation on ${element.outerHTML} when initially disabled=false`);


    promise_test(async t => {
      const { target, observedEvents } = setupTest(t, element, { initialDisabled: true });

      await test_driver.click(target);
      await new Promise(resolve => t.step_timeout(resolve, 0));

      assertStatus(element, observedEvents, { initialDisabled: true });
    }, `immediate propagation on ${element.outerHTML} when initially disabled=true`);
  }
</script>
