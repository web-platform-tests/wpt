<!DOCTYPE html>
<html>
  <head>
    <title>
      sample-accurate-scheduling.html
    </title>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
  </head>
  <body>
    <script>
      // Test that a series of notes can be scheduled with sample accuracy.
      // An impulse is used so the exact rendering positions are observable.

      const sampleRate = 44100.0;
      const lengthInSeconds = 4;

      let context;
      let impulse;

      // See if we can render at exactly these sample offsets.
      const sampleOffsets = [0, 3, 512, 517, 1000, 1005, 20000, 21234, 37590];

      function createImpulse() {
        // An impulse has a value of 1 at time 0, and is otherwise 0.
        impulse = new AudioBuffer({
          length: 512,
          numberOfChannels: 2,
          sampleRate,
        });
        const sampleDataL = impulse.getChannelData(0);
        const sampleDataR = impulse.getChannelData(1);
        sampleDataL[0] = 1.0;
        sampleDataR[0] = 1.0;
      }

      function playNote(time) {
        const bufferSource = new AudioBufferSourceNode(context, {
          buffer: impulse,
        });
        bufferSource.connect(context.destination);
        bufferSource.start(time);
      }

      function checkSampleAccuracy(buffer) {
        const bufferDataL = buffer.getChannelData(0);
        const bufferDataR = buffer.getChannelData(1);

        let impulseCount = 0;
        let badOffsetCount = 0;

        // Left and right channels must be the same.
        assert_array_equals(
            bufferDataL,
            bufferDataR,
            'Content of left and right channels match');

        // Go through every sample and make sure it's 0, except at positions in
        // sampleOffsets.
        for (let i = 0; i < buffer.length; ++i) {
          if (bufferDataL[i] !== 0) {
            // Make sure this index is in sampleOffsets
            let found = false;
            for (let j = 0; j < sampleOffsets.length; ++j) {
              if (sampleOffsets[j] === i) {
                found = true;
                break;
              }
            }
            ++impulseCount;
            assert_true(found, 'Non-zero sample found at sample offset ' + i);
            if (!found) {
              ++badOffsetCount;
            }
          }
        }

        assert_equals(
            impulseCount, sampleOffsets.length, 'Number of impulses found');
        if (impulseCount === sampleOffsets.length) {
          assert_equals(badOffsetCount, 0, 'bad offset');
        }
      }

      promise_test(async () => {
        context = new OfflineAudioContext(
            2,
            sampleRate * lengthInSeconds,
            sampleRate);
        createImpulse();

        for (let i = 0; i < sampleOffsets.length; ++i) {
          let timeInSeconds = sampleOffsets[i] / sampleRate;
          playNote(timeInSeconds);
        }

        const renderedBuffer = await context.startRendering();
        checkSampleAccuracy(renderedBuffer);
      }, 'Test sample-accurate scheduling');
    </script>
  </body>
</html>
