<!doctype html>
<meta charset=utf-8>
<title>RTCDataChannel.close</title>
<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';

// Disable global timeout
// IMPORTANT: You need to add a timeout to *every test* of this file!
setup({ explicit_timeout: true });

// Test is based on the following revision:
// https://rawgit.com/w3c/webrtc-pc/1cc5bfc3ff18741033d804c4a71f7891242fb5b3/webrtc.html

const nChannels = 10;

/*
  6.2. close()

       Closes the RTCDataChannel. It may be called regardless of whether the RTCDataChannel object
       was created by this peer or the remote peer.

       When the close method is called, the user agent MUST run the following steps:

       1. Let channel be the RTCDataChannel object which is about to be closed.
       2. If channel's [[ReadyState]] slot is closing or closed, then abort these steps.
       3. Set channel's [[ReadyState]] slot to closing.
       4. If the closing procedure has not started yet, start it.
 */
test((t) => {
  const pc = new RTCPeerConnection();
  t.add_cleanup(() => pc.close());
  const dc = pc.createDataChannel('test');

  // Note: Since the closing procedure requires to queue a task,
  //       the channel should not be closed at this point.
  dc.close();
  assert_equals(dc.readyState, 'closing', 'dc should be closing after calling close()');
}, 'In-band data channel closing before connection establishment', {
  timeout: 5000
});

promise_test(async (t) => {
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const [dc1] = await createDataChannelPair(pc1, pc2, { channelLabel: 'onclose' });

  // Note: Since the closing procedure requires to queue a task,
  //       the channel should not be closed at this point.
  dc1.close();
  assert_equals(dc1.readyState, 'closing', 'dc1 should be closing after calling close()');
}, 'In-band data channel closing after connection establishment', {
  timeout: 5000
});

/*
  6.2. An RTCDataChannel object's underlying data transport may be torn down in a non-abrupt
       manner by running the closing procedure. When that happens the user agent MUST, unless the
       procedure was initiated by the close method, queue a task that sets the object's
       [[ReadyState]] slot to closing. This will eventually render the data transport closed.

       When an RTCDataChannel object's underlying data transport has been closed, the user agent
       MUST queue a task to run the following steps:

       1. Let channel be the RTCDataChannel object whose transport was closed.
       2. Set channel's [[ReadyState]] slot to closed.
       4. Fire a simple event named close at channel.
 */
promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dcPairs = await Promise.all(Array.from(new Array(nChannels), (_, i) => {
    return createDataChannelPair(pc1, pc2, {
      channelLabel: `onclose-${i}`,
      doSignaling: i === nChannels - 1,
    });
  }));

  let nCloses = 0;

  for (const [, dc2] of dcPairs) {
    // We're closing on dc1, so dc2 should fire. However, dc1 should not fire.
    // See: https://github.com/w3c/webrtc-pc/issues/1821
    dc2.onclose = t.step_func(() => {
      assert_equals(dc2.readyState, 'closed',
        'dc2 should be closed after onclose has been raised');
      ++nCloses;
      if (nCloses === nChannels - 1) {
        resolver.resolve();
      }
    });
  }

  for (const [dc1] of dcPairs) {
    dc1.close();
  }

  await resolver;
}, `In-band data channels x${nChannels} closing on local side should be synchronized across
 peers`, {
  timeout: 5000
});

promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  const dcPairs = await Promise.all(Array.from(new Array(nChannels), (_, i) => {
    return createDataChannelPair(pc1, pc2, {
      channelLabel: `onclose-${i}`,
      doSignaling: i === nChannels - 1,
    });
  }));

  let nCloses = 0;

  for (const [dc1] of dcPairs) {
    // We're closing on dc2, so dc1 should fire. However, dc2 should not fire.
    // See: https://github.com/w3c/webrtc-pc/issues/1821
    dc1.onclose = t.step_func(() => {
      assert_equals(dc1.readyState, 'closed',
        'dc1 should be closed after onclose has been raised');
      ++nCloses;
      if (nCloses === nChannels - 1) {
        resolver.resolve();
      }
    });
  }

  for (const [, dc2] of dcPairs) {
    dc2.close();
  }

  await resolver;
}, `In-band data channels x${nChannels} closing on remote side should be synchronized across
 peers`, {
  timeout: 5000
});

promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  let nCloses = 0;
  for (let i = 0; i < nChannels; ++i) {
    const dc1 = pc1.createDataChannel(`onclose-${i}`, {
      negotiated: true,
      id: 42 + i
    });
    const dc2 = pc2.createDataChannel(`onclose-${i}`, {
      negotiated: true,
      id: 42 + i
    });

    dc1.onopen = t.step_func(() => {
      dc1.close();
    });

    // We're closing on dc1, so dc2 should fire. However, dc1 should not fire.
    // See: https://github.com/w3c/webrtc-pc/issues/1821
    dc2.onclose = t.step_func(() => {
      assert_equals(dc1.readyState, 'closed',
        'dc2 should be closed after onclose has been raised');
      ++nCloses;
      if (nCloses === nChannels - 1) {
        resolver.resolve();
      }
    });
  }

  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);
  await resolver;
}, `Negotiated data channels x${nChannels} closing should be synchronized across peers`, {
  timeout: 5000
});

// Based on https://bugs.chromium.org/p/webrtc/issues/detail?id=6881
promise_test(async (t) => {
  const resolver = new Resolver();
  const pc1 = new RTCPeerConnection();
  const pc2 = new RTCPeerConnection();
  t.add_cleanup(() => pc1.close());
  t.add_cleanup(() => pc2.close());

  let nOpen = 0;
  let nCloses = 0;
  for (let i = 0; i < nChannels; ++i) {
    const dc1 = pc1.createDataChannel(`onclose-${i}`, {
      negotiated: true,
      id: 42 + i
    });
    const dc2 = pc2.createDataChannel(`onclose-${i}`, {
      negotiated: true,
      id: 42 + i
    });

    // Wait for all channels to open, then close the peer connection
    dc1.onopen = t.step_func(() => {
      ++nOpen;
      if (nOpen === nChannels - 1) {
        // Without this short timeout, Chrome's behaviour is flaky for some reason
        t.step_timeout(() => pc1.close(), 1000);
        t.step_timeout(() => assert_unreached('remote close events did not fire in time'), 2000);
      }
    });

    // We're closing on dc1, so dc2 should fire. However, dc1 should not fire.
    // See: https://github.com/w3c/webrtc-pc/issues/1821
    dc2.onclose = t.step_func(() => {
      assert_equals(dc1.readyState, 'closed',
        'dc2 should be closed after onclose has been raised');
      ++nCloses;
      if (nCloses === nChannels - 1) {
        resolver.resolve();
      }
    });
  }

  exchangeIceCandidates(pc1, pc2);
  await doSignalingHandshake(pc1, pc2);
  await resolver;
}, `Closing peer connection locally should close all ${nChannels} channels for the remote peer`, {
  timeout: 5000
});

/*
  Untestable:

  6.2.
       When an RTCDataChannel object's underlying data transport has been closed, the user agent
       MUST queue a task to run the following steps:

         3. If the transport was closed with an error, fire an RTCError event at channel with
          errorDetail set to "sctp-failure".

       Note: We cannot test this since we cannot provoke an SCTP error.

  6.2.
      In some cases, the user agent may be unable to create an RTCDataChannel's underlying data
      transport. For example, the data channel's id may be outside the range negotiated by the
      [RTCWEB-DATA] implementations in the SCTP handshake. When the user agent determines that an
      RTCDataChannel's underlying data transport cannot be created, the user agent MUST queue a
      task to run the following steps:

      1. Let channel be the RTCDataChannel object for which the user agent could not create an
         underlying data transport.
      2. Set channel's [[ReadyState]] slot to closed.
      3. Fire an RTCError event at channel with errorDetail set to "data-channel-failure".
      4. Fire a simple event named close at channel.

      Note: We cannot test this since there is no way of knowing how many SCTP streams have
            been negotiated.
 */

</script>
