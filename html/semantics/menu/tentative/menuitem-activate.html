<!DOCTYPE html>
<meta name="timeout" content="long">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-actions.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script src="../../popovers/resources/popover-utils.js"></script>
<link rel=author href=mailto:dom@chromium.org>
<link rel=help href=https://open-ui.org/components/menu.explainer>
<style>

menuitem:open { background-color: rgb(12,19,8); }

</style>

<menubar>
 <menuitem id=openMainMenu commandfor=mainmenu command=toggle-menu>Open first menu</menuitem>
</menubar>

<menulist id=mainmenu>
 <menuitem id=openSubMenu commandfor=submenu command=toggle-menu>Toggle menu</menuitem>
 <menuitem id=showPopoverMenuItem command=toggle-popover commandfor=popover>Show popover</menuitem>
 <menuitem id=doNothing>Normal item</menuitem>
</menulist>

<menulist id=submenu>
 <menuitem>Sub menu</menuitem>
</menulist>

<menubar>
  <menuitem id=toggleSubMenu1 commandfor=submenu command=toggle-menu>Toggle menu</menuitem>
  <menuitem id=toggleSubMenu2 commandfor=submenu command=toggle-menu>Toggle menu</menuitem>
  <menuitem id=showSubMenu commandfor=submenu command=show-menu>Show menu</menuitem>
</menubar>

<div popover id=popover>Popover</div>

<button popovertarget=popoverwithmenu>Open popover with menu</button>
<div popover id=popoverwithmenu>
  <button popovertarget=menuinpopover>Open menu in the popover</button>
  <menulist id=menuinpopover>
    <menuitem id=menuinpopoveritem1>First item</menuitem>
    <menuitem id=menuinpopoveritem2 command=toggle-menu commandfor=menuinpopover2>Toggle menu 2</menuitem>
  </menulist>
  <menulist id=menuinpopover2>
    <menuitem>Submenu item</menuitem>
  </menulist>
</div>

<style>
  [popover] {
    width: 400px;
    height: 400px;
  }
  menuitem {
    interest-delay: 1000s;
  }
</style>

<script>

function bgcolor_is_open(element) {
  return getComputedStyle(element).backgroundColor == "rgb(12, 19, 8)";
}

promise_test(async () => {
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover starts closed");
  assert_false(openMainMenu.matches(":open"), "openMainMenu item starts closed");
  assert_false(bgcolor_is_open(openMainMenu), "openMainMenu item starts closed (style)");
  await clickOn(openMainMenu);
  assert_true(mainmenu.matches(":popover-open"), "mainmenu opens");
  assert_true(openMainMenu.matches(":open"), "openMainMenu item opens");
  assert_true(bgcolor_is_open(openMainMenu), "openMainMenu item opens (style)");

  assert_false(submenu.matches(":popover-open"), "submenu popover starts closed");
  assert_false(openSubMenu.matches(":open"), "openSubMenu item starts closed");
  await clickOn(openSubMenu);
  assert_true(submenu.matches(":popover-open"), "submenu opens");
  assert_true(openSubMenu.matches(":open"), "openSubMenu item opens");

  // Close the submenu.
  await clickOn(openSubMenu);

  assert_false(submenu.matches(":popover-open"), "submenu popover gets closed");
  assert_false(openSubMenu.matches(":open"), "openSubMenu item gets closed");
  assert_true(mainmenu.matches(":popover-open"), "mainmenu still open");

  // Close the mainmenu.
  await clickOn(openMainMenu);
  assert_false(mainmenu.matches(":popover-open"), "mainmenu gets closed");
  assert_false(openMainMenu.matches(":open"), "openMainMenu item gets closed");
}, 'User menuitem activation works with the toggle-menu command');

promise_test(async () => {
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover starts closed");
  assert_false(openMainMenu.matches(":open"), "openMainMenu item starts closed");
  assert_false(bgcolor_is_open(openMainMenu), "openMainMenu item starts closed (style)");
  await clickOn(openMainMenu);
  assert_true(mainmenu.matches(":popover-open"), "mainmenu popover opens");
  assert_true(openMainMenu.matches(":open"), "openMainMenu item opens");
  assert_true(bgcolor_is_open(openMainMenu), "openMainMenu item opens (style)");

  assert_false(popover.matches(":popover-open"), "div popover starts closed");
  assert_false(showPopoverMenuItem.matches(":open"), "showPopoverMenuItem item starts closed");
  await clickOn(showPopoverMenuItem);
  assert_true(popover.matches(":popover-open"), "div popover opens");
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover closes");
  assert_false(showPopoverMenuItem.matches(":open"), "showPopoverMenuItem item stays closed");

  // Close the popover.
  await clickOn(openMainMenu);
  assert_false(popover.matches(":popover-open"), "div popover gets closed");
  assert_true(mainmenu.matches(":popover-open"), "mainmenu gets opened");
  await clickOn(openMainMenu);
  assert_false(mainmenu.matches(":popover-open"), "mainmenu gets closed");
}, 'User menuitem activation works with show-popover command');

promise_test(async (t) => {
  assert_false(popoverwithmenu.matches(":popover-open"),
      "popover with menu starts closed");

  // Open the popover that hosts two menulists.
  await clickOn(
      document.querySelector("button[popovertarget=popoverwithmenu]"));
  assert_true(popoverwithmenu.matches(":popover-open"),
      "popover with menu opens");
  assert_false(menuinpopover.matches(":popover-open"),
      "menu in popover starts closed");

  // Open the first menu in the popover.
  await clickOn(
      document.querySelector('button[popovertarget=menuinpopover]'));
  assert_true(menuinpopover.matches(":popover-open"), "menu in popover opens");
  assert_true(popoverwithmenu.matches(":popover-open"),
      "outer popover remains open");
  assert_false(menuinpopover2.matches(":popover-open"),
      "menu 2 in popover starts closed");

  // Open the second menu in the popover.
  await clickOn(menuinpopoveritem2);
  assert_true(menuinpopover2.matches(":popover-open"),
      "menu 2 in popover opens");
  assert_true(popoverwithmenu.matches(":popover-open"),
      "outer popover remains open after opening menu 2");
  assert_true(menuinpopover.matches(":popover-open"),
      "menu in popover remains open");

  // Close the second, "sub", menu within the popover by just clicking off of
  // it.
  await clickOn(menuinpopoveritem2);
  assert_false(menuinpopover2.matches(":popover-open"),
      "menu 2 in popover closes");
  assert_true(popoverwithmenu.matches(":popover-open"),
      "outer popover remains open after closing menu 2");
  assert_true(menuinpopover.matches(":popover-open"),
      "menu in popover remains open");
}, 'Menulist inside a popover works correctly; does not get accidentally ' +
   'dismissed by opening submenus');

async function getMenuItemCoords(invoker, targetMenuItem) {
  // test_driver isn't suited to mousedown-drag-mouseup interactions when the
  // mousedown triggers visibility of one of the elements.
  const menulist = targetMenuItem.parentElement;
  assert_false(menulist.matches(":popover-open"), "menulist popover should start closed");
  await clickOn(invoker);
  assert_true(menulist.matches(":popover-open"), "menulist popover opens when clicked");
  let rect = targetMenuItem.getBoundingClientRect();
  let coords = {x: Math.round(rect.x + rect.width / 2),
      y: Math.round(rect.y + rect.height / 2)};
  await clickOn(invoker);
  assert_false(menulist.matches(":popover-open"), "menulist popover closes when clicked");
  return coords;
}

promise_test(async (t) => {
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover starts closed");
  const doNothingCoordinates = await getMenuItemCoords(openMainMenu, doNothing);
  let invokerClicks = 0;
  let itemClicks = 0;
  openMainMenu.addEventListener('click',() => (++invokerClicks));
  doNothing.addEventListener('click',() => (++itemClicks));
  let openStateAfterPointerdown = "none";
  let gotPointerMove = new Promise(resolve => {
    openMainMenu.addEventListener('pointermove',async () => {
      // There will be two move events, one before the pointerdown and one after.
      // Just capture the one after.
      if (openStateAfterPointerdown === "none") {
        openStateAfterPointerdown = "first-move";
      } else if (openStateAfterPointerdown === "first-move") {
        await waitForRender();
        openStateAfterPointerdown = mainmenu.matches(":popover-open") ? "open" : "closed";
        resolve();
      }
    },{signal: t.get_signal()});
  })
  await new test_driver.Actions()
    .addPointer('mouse', 'mouse')
    .pointerMove(0, 0, {origin: openMainMenu})
    .pointerDown()
    // Extra move to trigger event on openMainMenu:
    .pointerMove(2, 2, {origin: openMainMenu})
    .pointerMove(doNothingCoordinates.x, doNothingCoordinates.y, {})
    .pointerUp()
    .send();
  await gotPointerMove;
  assert_equals(openStateAfterPointerdown,"open", "mainmenu popover should open after pointer down");
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover should be closed after interaction");
  assert_equals(invokerClicks,0, "the invoking menu didn't get a click");
  // TODO: Menu items should fire a click event when they are selected.
  // assert_equals(itemClicks,1, "the invoked menu did get a click");
}, 'A mousedown-drag-mouseup gesture on a normal menuitem picks the item');

promise_test(async (t) => {
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover starts closed");
  assert_false(submenu.matches(":popover-open"), "submenu popover starts closed");
  const openSubMenuCoordinates = await getMenuItemCoords(openMainMenu, openSubMenu);
  await new test_driver.Actions()
    .addPointer('mouse', 'mouse')
    .pointerMove(0, 0, {origin: openMainMenu})
    .pointerDown()
    .pointerMove(openSubMenuCoordinates.x, openSubMenuCoordinates.y, {})
    .pointerUp()
    .send();
  await waitForRender();
  assert_true(mainmenu.matches(":popover-open"), "mainmenu popover should remain open, because submenu chosen");
  assert_true(submenu.matches(":popover-open"), "submenu popover should be open");
  await clickOn(openMainMenu); // Cleanup.
  assert_false(mainmenu.matches(":popover-open"), "mainmenu popover should be closed");
  assert_false(submenu.matches(":popover-open"), "submenu popover should be closed");
}, 'A mousedown-drag-mouseup gesture on a submenu item leaves both menus open');

promise_test(async () => {
  assert_false(submenu.matches(":popover-open"), "submenu popover starts closed");
  assert_false(openMainMenu.matches(":open"), "openMainMenu item starts closed");
  assert_false(bgcolor_is_open(openMainMenu), "openMainMenu item starts closed (style)");
  await clickOn(toggleSubMenu1);
  assert_true(submenu.matches(":popover-open"), "submenu opens");
  assert_true(toggleSubMenu1.matches(":open"), "toggleSubMenu1 item opens");
  assert_true(bgcolor_is_open(toggleSubMenu1), "toggleSubMenu1 item opens (style)");
  assert_false(toggleSubMenu2.matches(":open"), "toggleSubMenu2 item stays closed");
  assert_false(bgcolor_is_open(toggleSubMenu2), "toggleSubMenu2 item stays closed (style)");
  assert_false(showSubMenu.matches(":open"), "showSubMenu item stays closed");
  assert_false(bgcolor_is_open(showSubMenu), "showSubMenu item stays closed (style)");
  // FIXME(https://crbug.com/406566432): Should closing the menu first be needed?
  await clickOn(toggleSubMenu1);
  await clickOn(toggleSubMenu2);
  assert_true(submenu.matches(":popover-open"), "submenu again open after toggle");
  assert_false(toggleSubMenu1.matches(":open"), "toggleSubMenu1 item closes");
  assert_false(bgcolor_is_open(toggleSubMenu1), "toggleSubMenu1 item closes (style)");
  assert_true(toggleSubMenu2.matches(":open"), "toggleSubMenu2 item opens");
  assert_true(bgcolor_is_open(toggleSubMenu2), "toggleSubMenu2 item opens (style)");
  assert_false(showSubMenu.matches(":open"), "showSubMenu item stays closed");
  assert_false(bgcolor_is_open(showSubMenu), "showSubMenu item stays closed (style)");
  // FIXME(https://crbug.com/406566432): Should closing the menu first be needed?
  await clickOn(toggleSubMenu2);
  await clickOn(showSubMenu);
  assert_true(submenu.matches(":popover-open"), "submenu again open after show");
  assert_false(toggleSubMenu1.matches(":open"), "toggleSubMenu1 item stays closed");
  assert_false(bgcolor_is_open(toggleSubMenu1), "toggleSubMenu1 item stays closed (style)");
  assert_false(toggleSubMenu2.matches(":open"), "toggleSubMenu2 item closes");
  assert_false(bgcolor_is_open(toggleSubMenu2), "toggleSubMenu2 item closes (style)");
  assert_false(showSubMenu.matches(":open"), "showSubMenu item stays closed since :open does not apply");
  assert_false(bgcolor_is_open(showSubMenu), "showSubMenu item stays closed since :open does not apply (style)");
}, ':open only applies to the invoker and only works for toggle-menu commands');
</script>
