<!DOCTYPE html>
<title>Service Worker: navigator.serviceWorker.ready</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
test(function() {
  const promise = navigator.serviceWorker.ready;
  assert_equals(promise, navigator.serviceWorker.ready,
                'repeated access to ready without intervening ' +
                'registrations should return the same Promise object');
  }, 'ready returns the same Promise object');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-installing';
  await service_worker_unregister(t, SCOPE);
  const frame = await with_iframe(SCOPE);

  let registration = await navigator.serviceWorker.register(
    SCRIPT,
    {scope: SCOPE}
  );
  await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (frame) frame.remove();
    if (registration) await registration.unregister();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_not_equals(registration.active, null,
                    'active after ready should not be null');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');

 }, 'ready on an iframe whose parent registers a new service worker');

promise_test(async t => {
  const frame = await with_iframe('resources/blank.html?uncontrolled');
  const registration = frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(function() {
    if (frame) frame.remove();
  });

  assert_equals(Object.getPrototypeOf(registration),
                frame.contentWindow.Promise.prototype,
                'the Promise should be in the context of the ' +
                'related document');
}, 'ready returns a Promise object in the context of the related document');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-controlled';
  const expected_url = normalizeURL(SCRIPT);

  let registration = await service_worker_unregister_and_register(
    t,
    SCRIPT,
    SCOPE
  );
  await wait_for_state(t, registration.installing, 'activated');
  const frame = await with_iframe(SCOPE);
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration)
      await registration.unregister();
    if (frame)
      frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_equals(registration.active.scriptURL, expected_url,
                'active after ready should not be null');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                registration.active,
                'the controller should be the active worker');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');

}, 'ready on a controlled document');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/blank.html?ready-potential-controlled';
  const expected_url = normalizeURL(SCRIPT);

  const frame = await with_iframe(SCOPE);
  let registration = await navigator.serviceWorker.register(
    SCRIPT,
    {scope:SCOPE}
  );

  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration) await registration.unregister();
    if (frame) frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null.');
  assert_equals(registration.active.scriptURL, expected_url,
                'active after ready should not be null');
  assert_in_array(registration.active.state,
                  ['activating', 'activated'],
                  '.ready should be resolved when the registration ' +
                  'has an active worker');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                null,
                'uncontrolled document should not have a controller');

  }, 'ready on a potential controlled document');


promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const SCOPE = 'resources/register-iframe.html';
  const expected_url = normalizeURL(SCRIPT);
  const frame = await with_iframe(SCOPE);
  const registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration) await registration.unregister();
    if (frame) frame.remove();
  });

  assert_equals(registration.installing, null, 'installing should be null');
  assert_equals(registration.waiting, null, 'waiting should be null');
  assert_not_equals(registration.active, null,
                    'active after ready should not be null');
  assert_in_array(registration.active.state, ['activating', 'activated'],
                  '.ready should be resolved with "active worker"');

 }, 'ready on an iframe that installs a new service worker');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const MATCHED_SCOPE = 'resources/blank.html?ready-after-resolve';
  const LONGER_MATCHED_SCOPE =
      'resources/blank.html?ready-after-resolve-longer';

  let registration =
      await service_worker_unregister_and_register(t, SCRIPT, MATCHED_SCOPE);
  await wait_for_state(t, registration.installing, 'activated');
  const frame = await with_iframe(LONGER_MATCHED_SCOPE);
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration) await registration.unregister();
  });

  assert_equals(registration.scope, normalizeURL(MATCHED_SCOPE),
                'matched registration should be returned');
  registration = await navigator.serviceWorker.register(
      SCRIPT, {scope: LONGER_MATCHED_SCOPE});
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration) await registration.unregister();
    if (frame) frame.remove();
  });

  assert_equals(registration.scope, normalizeURL(MATCHED_SCOPE),
                'ready should only be resolved once');

  }, 'access ready after it has been resolved');

promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const MATCHED_SCOPE = 'resources/blank.html?ready-after-match';
  const LONGER_MATCHED_SCOPE = 'resources/blank.html?ready-after-match-longer';

  await service_worker_unregister(t, MATCHED_SCOPE);
  await service_worker_unregister(t, LONGER_MATCHED_SCOPE);
  const frame = await with_iframe(LONGER_MATCHED_SCOPE);
  let registration = await navigator.serviceWorker.register(
    SCRIPT,
    {scope: MATCHED_SCOPE}
  );
  await wait_for_state(t, registration.installing, 'activated');
  registration = await navigator.serviceWorker.register(
    SCRIPT,
    {scope: LONGER_MATCHED_SCOPE}
  );
  registration = await frame.contentWindow.navigator.serviceWorker.ready;

  t.add_cleanup(async() => {
    if (registration) await registration.unregister();
    if (frame) frame.remove();
  });

  assert_equals(registration.scope, normalizeURL(LONGER_MATCHED_SCOPE),
                'longer matched registration should be returned');
  assert_equals(frame.contentWindow.navigator.serviceWorker.controller,
                null, 'controller should be null');

  }, 'ready after a longer matched registration registered');


promise_test(async t => {
  const SCRIPT = 'resources/empty-worker.js';
  const MATCHED_SCOPE = 'resources/blank.html?ready-after-resurrect';

  const registration1 = await service_worker_unregister_and_register(
    t,
    SCRIPT,
    MATCHED_SCOPE
  );

  t.add_cleanup(async()  => {
    if (frame) frame.remove();
    if (registration1) await registration1.unregister();
    if (registration2) await registration1.unregister();
  });

  await wait_for_state(t, registration1.installing, 'activated');

  // Hold the worker alive with a controlled worker
  const frame = await with_iframe(MATCHED_SCOPE);

  // Access the ready promise while the registration is doomed.
  const readyPromise = await frame.contentWindow.navigator.serviceWorker.ready;

  // Resurrect the doomed registration;
  const registration2 = await service_worker_unregister_and_register(
    t,
    SCRIPT,
    MATCHED_SCOPE
  );
  assert_equals(registration1, registration2,
                'existing registration should be resurrected');

  // We are trying to test if the ready promise ever resolves here.  Use
  // an explicit timeout check here rather than forcing a full infrastructure
  // level timeout.
  let timeoutId;
  const timeoutPromise = new Promise(resolve => {
    timeoutId = setTimeout(_ => {
      timeoutId = null;
      resolve();
    }, 500);
  });

  // This should resolve immediately since there is an alive registration
  // with an active promise for the matching scope.
  await Promise.race([readyPromise, timeoutPromise]);
  assert_not_equals(timeoutId, null,
                    'ready promise should resolve before timeout');
  clearTimeout(timeoutId);
}, 'access ready on uninstalling registration that is resurrected');
</script>
