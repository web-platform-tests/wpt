<!DOCTYPE html>
<html>
<title>Test MediaSourceHandle transfer characteristics</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="mediasource-message-util.js"></script>
<body>
<script>

function assert_mseiw_supported() {
  // Fail fast if MSE-in-Workers is not supported.
  assert_true(
      MediaSource.hasOwnProperty('canConstructInDedicatedWorker'),
      'MediaSource hasOwnProperty \'canConstructInDedicatedWorker\'');
  assert_true(
      MediaSource.canConstructInDedicatedWorker,
      'MediaSource.canConstructInDedicatedWorker');
  assert_true(
      window.hasOwnProperty('MediaSourceHandle'),
      'window must have MediaSourceHandle visibility');
}

function get_handle_from_new_worker(t) {
  return new Promise((r) => {
    let worker = new Worker('mediasource-worker-handle-transfer-to-main.js');
    worker.addEventListener(
        'message', t.step_func(e => {
          let subject = e.data.subject;
          assert_true(
              subject != undefined, 'message must have a subject field');
          switch (subject) {
            case messageSubject.ERROR:
              assert_unreached('Worker error: ' + e.data.info);
              break;
            case messageSubject.HANDLE:
              const handle = e.data.info;
              assert_not_equals(
                  handle, null, 'must have a non-null MediaSourceHandle');
              r({worker, handle});
              break;
            default:
              assert_unreached('Unexpected message subject: ' + subject);
          }
        }),
        {once: true});
  });
}

promise_test(async t => {
  assert_mseiw_supported();
  let {worker, handle} = await get_handle_from_new_worker(t);
  assert_true(
      handle instanceof MediaSourceHandle, 'must be a MediaSourceHandle');
  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle);
  }, 'serializing handle without transfer');
}, 'MediaSourceHandle serialization without transfer must fail, tested in window context');

promise_test(async t => {
  assert_mseiw_supported();
  let {worker, handle} = await get_handle_from_new_worker(t);
  assert_true(
      handle instanceof MediaSourceHandle, 'must be a MediaSourceHandle');
  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle, handle]);
  }, 'transferring same handle more than once in same postMessage');
}, 'Same MediaSourceHandle transferred multiple times in single postMessage must fail, tested in window context');

promise_test(async t => {
  assert_mseiw_supported();
  let {worker, handle} = await get_handle_from_new_worker(t);
  assert_true(
      handle instanceof MediaSourceHandle, 'must be a MediaSourceHandle');

  // Transferring handle to worker without including it in the message is still
  // a valid transfer, though the recipient will not be able to obtain the
  // handle itself. Regardless, the handle in this sender's context will be
  // detached.
  worker.postMessage(null, [handle]);

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(null, [handle]);
  }, 'transferring handle that was already detached should fail');

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle]);
  }, 'transferring handle that was already detached should fail, even if this time it\'s included in the message');
}, 'Attempt to transfer detached MediaSourceHandle must fail, tested in window context');

promise_test(async t => {
  assert_mseiw_supported();
  let {worker, handle} = await get_handle_from_new_worker(t);
  assert_true(
      handle instanceof MediaSourceHandle, 'must be a MediaSourceHandle');

  let video = document.createElement('video');
  document.body.appendChild(video);
  video.srcObject = handle;

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle]);
  }, 'transferring handle that is currently srcObject fails');
  assert_equals(video.srcObject, handle);

  // Clear |handle| from being the srcObject value.
  video.srcObject = null;

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle]);
  }, 'transferring handle that was briefly srcObject before srcObject was reset to null should also fail');
  assert_equals(video.srcObject, null);
}, 'MediaSourceHandle cannot be transferred, immediately after set as srcObject, even if srcObject immediately reset to null');

promise_test(async t => {
  assert_mseiw_supported();
  let {worker, handle} = await get_handle_from_new_worker(t);
  assert_true(
      handle instanceof MediaSourceHandle, 'must be a MediaSourceHandle');

  let video = document.createElement('video');
  document.body.appendChild(video);
  video.srcObject = handle;
  assert_not_equals(video.networkState, HTMLMediaElement.NETWORK_LOADING);
  // Initial step of resource selection algorithm sets networkState to
  // NETWORK_NO_SOURCE. networkState only becomes NETWORK_LOADING after stable
  // state awaited and resource selection algorithm continues with, in this
  // case, an assigned media provider object (which is the MediaSource
  // underlying the handle).
  assert_equals(video.networkState, HTMLMediaElement.NETWORK_NO_SOURCE);

  // Wait until 'loadstart' media element event is dispatched.
  await new Promise((r) => {
    video.addEventListener(
        'loadstart', t.step_func(e => {
          r();
        }),
        {once: true});
  });
  assert_equals(video.networkState, HTMLMediaElement.NETWORK_LOADING);

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle]);
  }, 'transferring handle that is currently srcObject, after loadstart, fails');
  assert_equals(video.srcObject, handle);

  // Clear |handle| from being the srcObject value.
  video.srcObject = null;

  assert_throws_dom('DataCloneError', function() {
    worker.postMessage(handle, [handle]);
  }, 'transferring handle that was srcObject until \'loadstart\' when srcObject was reset to null should also fail');
  assert_equals(video.srcObject, null);
}, 'MediaSourceHandle cannot be transferred, if it was srcObject when asynchronous load starts (loadstart), even if srcObject is then immediately reset to null');

fetch_tests_from_worker(new Worker('mediasource-worker-handle-transfer.js'));

</script>
</body>
</html>
