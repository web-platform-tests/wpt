from __future__ import annotations

import time
from typing import Any, List, Optional

import ctypes
from ctypes import POINTER, byref
from ctypes.wintypes import BOOL, HWND, LPARAM

# Type aliases for COM interface pointers.
# These are dynamically generated by comtypes at runtime.
IAccessiblePtr = Any
IAccessible2Ptr = Any

import comtypes.client
from comtypes import IServiceProvider

from ..platformaccessibility.ia2.constants import (  # type: ignore[attr-defined]
    IAccessible2_2,
    Role,
    msaa_state_list_to_string,
    state_list_to_string,
)

CHILDID_SELF = 0
OBJID_CLIENT = -4

user32 = ctypes.windll.user32  # type: ignore
oleacc = ctypes.oledll.oleacc  # type: ignore
oleacc_mod = comtypes.client.GetModule("oleacc.dll")
IAccessible = oleacc_mod.IAccessible  # noqa: N816

def accessible_object_from_window(hwnd: HWND) -> IAccessiblePtr:
    p = POINTER(IAccessible)()
    oleacc.AccessibleObjectFromWindow(
        hwnd, OBJID_CLIENT, byref(IAccessible._iid_), byref(p)
    )
    return p


def name_from_hwnd(hwnd: HWND) -> str:
    MAX_CHARS = 257
    buffer = ctypes.create_unicode_buffer(MAX_CHARS)
    user32.GetWindowTextW(hwnd, buffer, MAX_CHARS)
    return buffer.value


def get_browser_hwnd(product_name: str) -> HWND:
    found: List[HWND] = []

    @ctypes.WINFUNCTYPE(BOOL, HWND, LPARAM)  # type: ignore[attr-defined, misc]
    def check_window_name(hwnd: HWND, lParam: LPARAM) -> bool:  # noqa: N803
        window_name = name_from_hwnd(hwnd)
        if product_name not in window_name.lower():
            # EnumWindows should continue enumerating
            return True
        found.append(hwnd)
        # EnumWindows should stop enumerating (since we found the right window)
        return False

    user32.EnumWindows(check_window_name, LPARAM(0))
    if not found:
        raise LookupError(f"Couldn't find {product_name} HWND")
    return found[0]


def to_ia2(node: IAccessiblePtr) -> IAccessible2Ptr:
    service = node.QueryInterface(IServiceProvider)
    return service.QueryService(IAccessible._iid_, IAccessible2_2)


def find_browser(product_name: str) -> IAccessible2Ptr:
    hwnd = get_browser_hwnd(product_name)
    root = accessible_object_from_window(hwnd)
    return to_ia2(root)


def poll_for_tab(url: str, root: IAccessible2Ptr, timeout: float) -> IAccessible2Ptr:
    tab = find_tab(url, root)
    stop = time.time() + timeout
    while not tab:
        if time.time() > stop:
            raise TimeoutError(f"Timeout looking for url: {url}")
        time.sleep(0.01)
        tab = find_tab(url, root)
    return tab


def find_tab(url: str, root: IAccessible2Ptr) -> Optional[IAccessible2Ptr]:
    targets, count = root.relationTargetsOfType("embeds", 1)
    if count >= 1:
        ia2 = to_ia2(targets[0])
        if ia2.accValue(CHILDID_SELF) == url:
            return ia2

    return find_tab_by_searching_tree(url, root)


def find_tab_by_searching_tree(url: str, root: IAccessible2Ptr) -> Optional[IAccessible2Ptr]:
    for i in range(1, root.accChildCount + 1):
        child = to_ia2(root.accChild(i))
        if child.accRole(CHILDID_SELF) == Role.ROLE_SYSTEM_DOCUMENT:
            if child.accValue(CHILDID_SELF) == url:
                return child
            # No need to search within documents.
            return None
        descendant = find_tab_by_searching_tree(url, child)
        if descendant:
            return descendant
    return None


def find_ia2_node(root: IAccessible2Ptr, dom_id: str) -> Optional[IAccessible2Ptr]:
    id_attribute = f"id:{dom_id};"
    for i in range(1, root.accChildCount + 1):
        child = to_ia2(root.accChild(i))
        if child.attributes and id_attribute in child.attributes:
            return child
        descendant = find_ia2_node(child, dom_id)
        if descendant:
            return descendant
    return None


class Ia2Wrapper:
    def __init__(self, pid: int, product_name: str, timeout: float) -> None:
        """Setup for accessibility API testing.

        :pid: The PID of the process which exposes the accessibility API.
        :product_name: The name of the browser, used to find the browser in the accessibility API.
        :timeout: The timeout the test harness has set for this test, local timeouts can be set based on it.
        """
        self.product_name: str = product_name
        self.pid: int = pid
        self.test_url: Optional[str] = None
        self.timeout: float = timeout

        self.root: Optional[IAccessible2Ptr] = find_browser(self.product_name)
        if not self.root:
            raise Exception(f"Couldn't find browser {self.product_name}.")

    def find_node(self, dom_id: str, url: str) -> IAccessible2Ptr:
        """
        :param dom_id: The dom id of the node to test.
        :param url: The url of the test.
        """

        tab = poll_for_tab(url, self.root)
        node = find_ia2_node(tab, dom_id)
        if not node:
            raise Exception(f"Couldn't find node with ID {dom_id}.")

        return node

    def get_role(self, node: IAccessible2Ptr) -> str:
        return Role(node.role()).name

    def get_msaa_role(self, node: IAccessible2Ptr) -> str:
        return Role(node.accRole(CHILDID_SELF)).name

    def get_state_list(self, node: IAccessible2Ptr) -> str:
        return state_list_to_string(node.states)

    def get_msaa_state_list(self, node: IAccessible2Ptr) -> str:
        return msaa_state_list_to_string(node.accState(CHILDID_SELF))
