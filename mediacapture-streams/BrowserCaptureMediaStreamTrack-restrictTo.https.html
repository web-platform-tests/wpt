<!doctype html>
<html>

<head>
  <title>BrowserCaptureMediaStreamTrack restrictTo()</title>
  <link rel="help" href="https://screen-share.github.io/element-capture/">
</head>

<body>
  <p class="instructions">
    When prompted, accept to give permission to use your audio, video devices.
  </p>
  <h1 class="instructions">Description</h1>
  <p class="instructions">
    This test checks that restricting BrowserCaptureMediaStreamTrack works as
    expected.
  </p>

  <style>
    div {
      height: 100px;
    }
    .stacking {
      opacity: 0.9;
    }
    #container {
      columns:4;
      column-fill:auto;
    }
    .fragmentize {
      height: 50px;
    }
    #target {
      background: linear-gradient(red, blue);
    }
  </style>


  <button id="button">Start Test</button>
  <div id='container'>
    <div id='target'></div>
  </div>
  <video id="video"
         style="border: 2px blue dotted; width: 250px; height: 250px;"
         autoplay playsinline muted></video>

  <script src=/resources/testharness.js></script>
  <script src=/resources/testharnessreport.js></script>
  <script src=/resources/testdriver.js></script>
  <script src=/resources/testdriver-vendor.js></script>

  <script>
    "use strict";

    // For more information, see:
    // https://screen-share.github.io/element-capture/#elements-eligible-for-restriction
    const EligibilityRequirement = {
      StackingContext: 0,
      OnlyOneBoxFragment: 1,
      FlattenedIn3D: 2,
    };

    async function run_test(eligibilityParam) {
      const div = document.getElementById('target');
      let count = 0;
      function animate() {
        count += 1;
        div.innerText = count;
        window.requestAnimationFrame(animate);
      }
      animate();

      async function getDisplayMedia() {
        const p = new Promise(r => button.onclick = r);
        await test_driver.click(button);
        await p;
        return navigator.mediaDevices.getDisplayMedia(
          {
            selfBrowserSurface: "include"
          });
      }

      let frame_count = 0;
      // Updates the `frame_count` global whenever a new frame is received on the
      // passed in media stream track.
      async function readFromTrack(track) {
        const reader = new MediaStreamTrackProcessor(track).readable.getReader();
        while (true) {
          const frameOrDone = await reader.read();
          if (frameOrDone.done) {
            break;
          }
          frameOrDone.value.close();
          frame_count += 1;
        }
      }

      // Asserts that at least one frame is read after this method is called.
      async function assertFrameRead(t, message) {
        const last_frame_count = frame_count;
        // Test will fail if no frames are read before the step_wait timeout.
        await t.step_wait(() => frame_count > last_frame_count, message);
      }

      // Assert that there are no frames produced after calling restrictTo.
      async function assertStopsProducingFrames(t, message) {
        let last_frame_count = frame_count;
        await t.step_timeout(() => {
          assert_equals(frame_count, last_frame_count);
        }, 1000);
      }

      function makeElementEligible(element) {
        // Must always have a stacking context to be eligible.
        element.classList.add("stacking");
        switch(eligibilityParam) {
          case EligibilityRequirement.OnlyOneBoxFragment:
            element.parentElement.classList.remove("fragmented");
            break;

          case EligibilityRequirement.FlattenedIn3D:
            element.style.transform = "";
            break;
        }
      }

      function makeElementIneligible(element) {
        switch(eligibilityParam) {
          case EligibilityRequirement.StackingContext:
            element.classList.remove("stacking");
            break;

          case EligibilityRequirement.OnlyOneBoxFragment:
            element.parentElement.classList.add("fragmented");
            break;

          case EligibilityRequirement.FlattenedIn3D:
            element.style.transform = "rotateY(90deg)";
            break;
        }
      }

      // Restore element state after each test.
      function cleanupElement(element) {
            element.classList.remove("stacking");
            element.parentElement.classList.remove("fragmented");
            element.style.transform = "";
      }

      const stream = await getDisplayMedia();
      assert_true(stream.active, "stream should be active.");
      assert_equals(stream.getVideoTracks().length, 1);

      const [videoTrack] = stream.getVideoTracks();
      assert_true(videoTrack instanceof MediaStreamTrack,
        "track should be either MediaStreamTrack or a subclass thereof.");
      assert_equals(videoTrack.readyState, "live", "track should be live.");

      // Consume the stream in a video element.
      const video = document.querySelector('video');
      video.srcObject = stream;

      // Keep track of the number of frames used.
      let readPromise = readFromTrack(videoTrack);
      await assertFrameRead(t, "Track should produce frames.");

      assert_true(!!RestrictionTarget, "RestrictionTarget exposed.");
      assert_true(!!RestrictionTarget.fromElement,
        "RestrictionTarget.fromElement exposed.");
      const restrictionTarget = await RestrictionTarget.fromElement(div);

      assert_true(!!videoTrack.restrictTo, "restrictTo exposed.");
      assert_true(typeof videoTrack.restrictTo === 'function',
        "restrictTo is a function.");
      await videoTrack.restrictTo(restrictionTarget);

      // By default, elements are not eligible for restriction due to not being
      // placed in their own stacking context.
      await assertStopsProducingFrames(t,
        "No new frames after restriction.");

      // Should be unpaused now that the element is eligible.
      makeElementEligible(div);

      // Make sure the element state is restored to default between tests.
      t.add_cleanup(function() {
        cleanupElement(div);
      });

      // Restart the reader now that the stream is producing frames again.
      readPromise = readPromise.then(() => {
        return readFromTrack(track);
      });
      await assertFrameRead(t,
        "Received at least one frame after becoming eligible.");

      // Should pause if it becomes ineligible again.
      makeElementIneligible(div);
      await assertStopsProducingFrames(t,
        "No new frames after becoming ineligible again.");
    }

    // Test parameterizations.
    promise_test(async t => {
      run_test(EligibilityRequirement.StackingContext)
    }, "Tests that restricting MediaStreamTrack objects with and without stacking contexts works as expected.");

    promise_test(async t => {
      run_test(EligibilityRequirement.OnlyOneBoxFragment)
    }, "Tests that restricting MediaStreamTrack objects with multiple box fragments works as expected.");

    promise_test(async t => {
      run_test(EligibilityRequirement.FlattenedIn3D)
    }, "Tests that restricting MediaStreamTrack objects not flattened in 3D works as expected.");

  </script>
</body>

</html>
