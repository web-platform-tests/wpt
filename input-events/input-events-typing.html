<!DOCTYPE html>
<meta charset="utf-8">
<title>execCommand() should only trigger 'input'</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-actions.js"></script>
<div id="rich" contenteditable></div>
<textarea id="plain"></textarea>
<script>
let inputEventsLog;

function log(event) {
    inputEventsLog.push({
        type: event.type,
        inputType: event.inputType,
        data: event.data,
        isComposing: event.isComposing,
        cancelable: event.cancelable,
        state: encodeURI(document.getElementById('rich').innerHTML)
    });
}

function resetEditor(content = '') {
    inputEventsLog = [];
    document.getElementById('rich').innerHTML = content;
}

document.getElementById('rich').addEventListener('beforeinput', event => log(event));
document.getElementById('rich').addEventListener('input', event => log(event));
</script>
<script>
(function() {
    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        const message = 'Hello';
        await test_driver.send_keys(document.getElementById('rich'), message);
        // 10 events (5 beforeinput + 5 input events)
        assert_equals(inputEventsLog.length, 10);
        for (let i = 0; i < inputEventsLog.length; i += 2) {
            const beforeInputEvent = inputEventsLog[i];
            const inputEvent = inputEventsLog[i + 1];
            assert_equals(beforeInputEvent.type, 'beforeinput');
            assert_equals(inputEvent.type, 'input');
            assert_equals(beforeInputEvent.inputType, 'insertText');
            assert_equals(inputEvent.inputType, 'insertText');
            assert_equals(beforeInputEvent.data, inputEvent.data);
            assert_equals(inputEvent.data, message[i / 2]);
            assert_equals(beforeInputEvent.state + message[i / 2], inputEvent.state);
        }
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on text typing');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        await test_driver.send_keys(document.getElementById('rich'), "\uE006"); // Return

        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'insertParagraph');
        assert_equals(inputEvent.inputType, 'insertParagraph');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing RETURN');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        await new test_driver.Actions()
            .keyDown('\uE008') // Shift
            .keyDown('\uE006') // Enter
            .keyUp('\uE006')
            .keyUp('\uE008')
            .send();

        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'insertLineBreak');
        assert_equals(inputEvent.inputType, 'insertLineBreak');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing Shift+RETURN');

    promise_test(async () => {
        resetEditor('<p>Preexisting <i id="caret">c</i>ontent</p>');
        await test_driver.click(document.querySelector('#caret'));
        await test_driver.send_keys(document.querySelector('#caret'), "\uE017"); // Delete

        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'deleteContentForward');
        assert_equals(inputEvent.inputType, 'deleteContentForward');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing DELETE with pre-existing content');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        await test_driver.send_keys(document.getElementById('rich'), "\uE017"); // Delete
        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'deleteContentForward');
        assert_equals(inputEvent.inputType, 'deleteContentForward');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing DELETE with no pre-existing content');

    promise_test(async () => {
        resetEditor('<p>Preexisting <i id="caret">c</i>ontent</p>');

        await test_driver.click(document.querySelector('#caret'));
        await test_driver.send_keys(document.getElementById('rich'), "\uE003"); // Back Space

        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'deleteContentBackward');
        assert_equals(inputEvent.inputType, 'deleteContentBackward');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing BACK_SPACE with pre-existing content');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        await test_driver.send_keys(document.getElementById('rich'), "\uE003"); // Back Space

        assert_equals(inputEventsLog.length, 2);
        const beforeInputEvent = inputEventsLog[0];
        const inputEvent = inputEventsLog[1];
        assert_equals(beforeInputEvent.type, 'beforeinput');
        assert_equals(inputEvent.type, 'input');
        assert_equals(beforeInputEvent.inputType, 'deleteContentBackward');
        assert_equals(inputEvent.inputType, 'deleteContentBackward');
        assert_equals(beforeInputEvent.data, inputEvent.data);
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing BACK_SPACE with no pre-existing content');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        await test_driver.send_keys(document.getElementById('rich'), "hello");

        // Decide whether to use  Key.COMMAND (mac) or Key.CONTROL (everything else)
        const modifierKey = navigator.userAgent.toLowerCase().includes('mac') ? '\u2318' : '\uE009';

        // Undo
        await new test_driver.Actions()
            .keyDown(modifierKey)
            .keyDown('z')
            .keyUp('z')
            .keyUp(modifierKey)
            .send();
        // Redo
        await new test_driver.Actions()
            .keyDown(modifierKey)
            .keyDown('\uE008') // Shift
            .keyDown('z')
            .keyUp('z')
            .keyUp('\uE008')
            .keyUp(modifierKey)
            .send();

        // Ignore the initial typing of 'hello'
        inputEventsLog = inputEventsLog.slice(10);

        assert_equals(inputEventsLog.length, 4);
        const inputTypes = ['historyUndo', 'historyRedo'];
        for (let i = 0; i < inputEventsLog.length; i += 2) {
            const beforeInputEvent = inputEventsLog[i];
            const inputEvent = inputEventsLog[i + 1];
            assert_equals(beforeInputEvent.type, 'beforeinput');
            assert_equals(inputEvent.type, 'input');
            assert_equals(beforeInputEvent.inputType, inputTypes[i / 2]);
            assert_equals(inputEvent.inputType, inputTypes[i / 2]);
            assert_equals(beforeInputEvent.data, inputEvent.data);
        }
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing Undo and Redo key combinations with an existing history');

    promise_test(async () => {
        resetEditor();
        document.getElementById('rich').focus();
        // Decide whether to use  Key.COMMAND (mac) or Key.CONTROL (everything else)
        const modifierKey = navigator.userAgent.toLowerCase().includes('mac') ? '\u2318' : '\uE009';

        // Undo
        await new test_driver.Actions()
            .keyDown(modifierKey)
            .keyDown('z')
            .keyUp('z')
            .keyUp(modifierKey)
            .send();
        // Redo
        await new test_driver.Actions()
            .keyDown(modifierKey)
            .keyDown('\uE008') // Shift
            .keyDown('z')
            .keyUp('z')
            .keyUp('\uE008')
            .keyUp(modifierKey)
            .send();

        assert_equals(inputEventsLog.length, 4);
        const inputTypes = ['historyUndo', 'historyRedo'];
        for (let i = 0; i < inputEventsLog.length; i += 2) {
            const beforeInputEvent = inputEventsLog[i];
            const inputEvent = inputEventsLog[i + 1];
            assert_equals(beforeInputEvent.type, 'beforeinput');
            assert_equals(inputEvent.type, 'input');
            assert_equals(beforeInputEvent.inputType, inputTypes[i / 2]);
            assert_equals(inputEvent.inputType, inputTypes[i / 2]);
            assert_equals(beforeInputEvent.data, inputEvent.data);
        }
        resetEditor();
        return Promise.resolve();
    }, 'It triggers beforeinput and input events on typing Undo and Redo key combinations without an existing history');

    promise_test(async () => {
        resetEditor();
        const expectedResult = [
            // Pressing 'a'.
            'plain-keydown-a',
            'plain-keypress-a',
            'plain-beforeinput-a-null',
            'plain-input-a-null',
            'plain-keyup-a',
            // Pressing Shift-'b'.
            'plain-keydown-B',
            'plain-keypress-B',
            'plain-beforeinput-B-null',
            'plain-input-B-null',
            'plain-keyup-B',
            // Pressing 'c'.
            'rich-keydown-c',
            'rich-keypress-c',
            'rich-beforeinput-c-null',
            'rich-input-c-null',
            'rich-keyup-c',
            // Pressing Shift-'d'.
            'rich-keydown-D',
            'rich-keypress-D',
            'rich-beforeinput-D-null',
            'rich-input-D-null',
            'rich-keyup-D',
        ];
        const result = [];

        for (const targetId of ['plain', 'rich']) {
            for (const eventType of ['beforeinput', 'input', 'keydown', 'keypress', 'keyup']) {
                document.getElementById(targetId).addEventListener(eventType, event => {
                    if (event.key === 'Shift')
                        return;
                    result.push(`${targetId}-${event.type}-${event.data || event.key}${ event instanceof InputEvent ? `-${event.dataTransfer}` : ''}`);
                });
            }
        }

        document.getElementById('plain').focus();
        await new test_driver.Actions()
            .keyDown('a')
            .keyUp('a')
            .keyDown('\uE008') // Shift
            .keyDown('B')
            .keyUp('B')
            .keyUp('\uE008')
            .send();

        document.getElementById('rich').focus();
        await new test_driver.Actions()
            .keyDown('c')
            .keyUp('c')
            .keyDown('\uE008') // Shift
            .keyDown('D')
            .keyUp('D')
            .keyUp('\uE008')
            .send();

        assert_equals(expectedResult.length, result.length);
        expectedResult.forEach((er, index) => assert_equals(er, result[index]));
        resetEditor();
        return Promise.resolve();
    }, 'InputEvents have correct data/order when typing on textarea and contenteditable');
})();
</script>
