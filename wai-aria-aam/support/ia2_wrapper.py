from __future__ import annotations

from typing import Any, List, Optional

import ctypes
from ctypes import POINTER, byref
from ctypes.wintypes import BOOL, HWND, LPARAM

# Type aliases for COM interface pointers.
# These are dynamically generated by comtypes at runtime.
IAccessiblePtr = Any
IAccessible2Ptr = Any

import comtypes.client
from comtypes import IServiceProvider

from .api_wrapper import ApiWrapper
from .ia2.constants import (  # type: ignore[attr-defined]
    IAccessible2_2,
    Role,
    msaa_state_list_to_string,
    state_list_to_string,
)

CHILDID_SELF = 0
OBJID_CLIENT = -4

user32 = ctypes.windll.user32  # type: ignore
oleacc = ctypes.oledll.oleacc  # type: ignore
oleacc_mod = comtypes.client.GetModule("oleacc.dll")
IAccessible = oleacc_mod.IAccessible  # noqa: N816


def accessible_object_from_window(hwnd: HWND) -> IAccessiblePtr:
    p = POINTER(IAccessible)()
    oleacc.AccessibleObjectFromWindow(
        hwnd, OBJID_CLIENT, byref(IAccessible._iid_), byref(p)
    )
    return p


def name_from_hwnd(hwnd: HWND) -> str:
    MAX_CHARS = 257
    buffer = ctypes.create_unicode_buffer(MAX_CHARS)
    user32.GetWindowTextW(hwnd, buffer, MAX_CHARS)
    return buffer.value


def get_browser_hwnd(product_name: str) -> HWND:
    found: List[HWND] = []

    @ctypes.WINFUNCTYPE(BOOL, HWND, LPARAM)  # type: ignore[attr-defined, misc]
    def check_window_name(hwnd: HWND, lParam: LPARAM) -> bool:  # noqa: N803
        window_name = name_from_hwnd(hwnd)
        if product_name not in window_name.lower():
            # EnumWindows should continue enumerating
            return True
        found.append(hwnd)
        # EnumWindows should stop enumerating (since we found the right window)
        return False

    user32.EnumWindows(check_window_name, LPARAM(0))
    if not found:
        raise LookupError(f"Couldn't find {product_name} HWND")
    return found[0]


def to_ia2(node: IAccessiblePtr) -> IAccessible2Ptr:
    service = node.QueryInterface(IServiceProvider)
    return service.QueryService(IAccessible._iid_, IAccessible2_2)


class Ia2Wrapper(ApiWrapper):

    @property
    def ApiName(self):
        return "IA2"

    def find_node(self, dom_id: str, url: str) -> IAccessible2Ptr:
        """
        :param dom_id: The dom id of the node to test.
        :param url: The url of the test.
        """
        if self.test_url != url or not self.document:
            self.test_url = url
            self.document = self._poll_for(
                self._find_tab,
                f"Timeout looking for url: {self.test_url}",
            )

        test_node = self._poll_for(
            lambda: self._find_node_by_id(self.document, dom_id),
            f"Timeout looking for node with id {dom_id} in accessibility API IA2.",
        )

        return test_node

    def get_role(self, node: IAccessible2Ptr) -> str:
        return Role(node.role()).name

    def get_msaa_role(self, node: IAccessible2Ptr) -> str:
        return Role(node.accRole(CHILDID_SELF)).name

    def get_state_list(self, node: IAccessible2Ptr) -> str:
        return state_list_to_string(node.states)

    def get_msaa_state_list(self, node: IAccessible2Ptr) -> str:
        return msaa_state_list_to_string(node.accState(CHILDID_SELF))

    def _find_browser(self) -> IAccessible2Ptr:
        """Find the IAccessible2 node representing the browser.

        :return: IAccessible2Ptr.
        """
        hwnd = get_browser_hwnd(self.product_name)
        root = accessible_object_from_window(hwnd)
        return to_ia2(root)

    def _find_tab(self) -> Optional[IAccessible2Ptr]:
        """Find the tab with the test url. Only returns the tab when the tab is ready.

        :return: IAccessible2Ptr representing test document or None.
        """
        targets, count = self.root.relationTargetsOfType("embeds", 1)
        if count >= 1:
            ia2 = to_ia2(targets[0])
            if ia2.accValue(CHILDID_SELF) == self.test_url:
                return ia2

        return self._find_tab_by_searching_tree(self.root)

    def _find_tab_by_searching_tree(
        self, root: IAccessible2Ptr
    ) -> Optional[IAccessible2Ptr]:
        """Find the tab by searching the accessibility tree.

        :param root: The root node to search from.
        :return: IAccessible2Ptr representing test document or None.
        """
        for i in range(1, root.accChildCount + 1):
            child = to_ia2(root.accChild(i))
            if child.accRole(CHILDID_SELF) == Role.ROLE_SYSTEM_DOCUMENT:
                if child.accValue(CHILDID_SELF) == self.test_url:
                    return child
                # No need to search within documents.
                return None
            descendant = self._find_tab_by_searching_tree(child)
            if descendant:
                return descendant
        return None

    def _find_node_by_id(
        self, root: IAccessible2Ptr, dom_id: str
    ) -> Optional[IAccessible2Ptr]:
        """Find the IAccessible2 node with a specified dom_id.

        :param root: The root node to search from.
        :param dom_id: The dom ID.
        :return: IAccessible2Ptr or None if not found.
        """
        id_attribute = f"id:{dom_id};"
        for i in range(1, root.accChildCount + 1):
            child = to_ia2(root.accChild(i))
            if child.attributes and id_attribute in child.attributes:
                return child
            descendant = self._find_node_by_id(child, dom_id)
            if descendant:
                return descendant
        return None
