<!DOCTYPE html>
<html>
<head>
<title>GB18030 encoding other (form, pua)</title>
<meta charset="gb18030"> <!-- test breaks if the server overrides this -->
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="gb18030_index.js"></script>
<script src="gb18030-encoder.js"></script>
<link rel="author" title="Richard Ishida" href="mailto:ishida@w3.org">
<link rel="help" href="http://www.w3.org/TR/encoding/#shift_jis">
<meta name="assert" content="The browser produces the expected byte sequences for pua characters not in the gb18030 index when encoding bytes for a URL produced by a form, using the  encoder steps in the specification.">
<meta name="timeout" content="long">
<style>
 iframe { display:none }
 form { display:none }
</style>
</head>
<body>
<div id="log"></div>
<script>
var tests = []
var cplist = []
var numTests = null
var numFrames = 2
var chunkSize = 500
var numChunks = null
var frames = null
var frames = null
var forms = null
var seperator = ","
var encodedSeperator = encodeURIComponent(",")
var currentChunkIndex = 0

setup(function() {
 // create a simple list of just those code points for which there is no entry in the index, from a representative subset of the BMP
codepoints = [ ]

    for (i=0xE000;i<0xF8FF;i++) {
        result =gbEncoder(String.fromCodePoint(i))
        if (result) {
            var item = {}
            codepoints.push(item)
            item.cp = i
            item.expected = '%'+result.replace(/ /g,'%')
            item.desc = 'pua '
            }
        }



    // convert the information into a simple array of objects that can be easily traversed
    var currentChunk = []
    var currentTests = []
    cplist = [currentChunk]
    tests = [currentTests]
    for (i=0; i< codepoints.length; i++) {
        if (currentChunk.length == chunkSize) {
            currentChunk = []
            cplist.push(currentChunk)
            currentTests = []
            tests.push(currentTests)
            }
        var item = {}
        currentChunk.push(item)
        item.cp = codepoints[i].cp
        item.expected = codepoints[i].expected
        currentTests.push(async_test("U+"+item.cp.toString(16).toUpperCase() + ' ' + String.fromCodePoint(item.cp) + " " +normalizeStr(item.expected)))
        }

    numChunks = cplist.length

    for (var i=0; i<numFrames; i++) {
        var frame = document.createElement("iframe")
        frame.id = frame.name = "frame-" + i
        document.body.appendChild(frame)
        var form = document.createElement("form")
        form.id = 'form-' + i
        form.method = "GET"
        form.action = "/common/blank.html"
        form.acceptCharset = "gb18030"
        form.target = frame.id
        var input = document.createElement("input")
        input.id = input.name = "input-" + i
        form.appendChild(input)
        document.body.appendChild(form)
        }

    addEventListener("load", function () {
        frames = Array.prototype.slice.call(document.getElementsByTagName("iframe"))
        forms = Array.prototype.slice.call(document.getElementsByTagName("form"))
        inputs = Array.prototype.slice.call(document.getElementsByTagName("input"))
        for (var i=0; i<Math.min(numFrames, numChunks); i++) {
            runNext(i)
            }
        })

    })

function runNext(id) {
    var i = currentChunkIndex
    currentChunkIndex += 1

    var iframe = frames[id]
    var form = forms[id]
    var input = inputs[id]

    input.value = cplist[i].map(function(x) {
        return String.fromCodePoint(x.cp)
        }).join(seperator);
    form.submit()

    iframe.onload = function () {
        var url = iframe.contentWindow.location
        var query = url.search
        var result_string = query.substr(query.indexOf('=') + 1)
        var results = result_string.split(encodedSeperator)

        for (var j=0; j<cplist[i].length; j++) {
            var t = tests[i][j]
            t.step(function() {
               //if (results[j].length != 6) results[j] = results[j].substr(0,3)+'%'+results[j].charCodeAt(3).toString(16).toUpperCase()  // handles trailing ASCII
                assert_equals(normalizeStr(results[j]), normalizeStr(cplist[i][j].expected))
                })
            t.done()
            }
        if (currentChunkIndex < numChunks) {
            runNext(id)
            }
        }
    }


function makePercentEncodedEsc (pointer) {
    // uses the Encoding spec algorithm to generate a %-encoded byte sequence representing a ShiftJIS character
    // excluding ASCII
    // pointer: integer, a number from the first column in the Shift-JIS index
   //   if (pointer == 0x203E) return '%7E'
    var lead = Math.floor(pointer/190)+0x81
    var trail = (pointer % 190)
    if (trail < 0x3F) trail += 0x40
    else trail += 0x41
    return '%'+lead.toString(16).toUpperCase()+'%'+trail.toString(16).toUpperCase()
    }

</script>
</body>
</html>
