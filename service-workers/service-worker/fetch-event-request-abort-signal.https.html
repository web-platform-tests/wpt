<!DOCTYPE html>
<meta charset="utf-8">
<title>Fetch event request abort signal</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
const SW_URL = 'resources/abort-monitor-worker.js';
const SCOPE = 'resources/blank.html';

function raf() {
  return new Promise(r => requestAnimationFrame(r));
}

async function nextFrame() {
  await raf();
  await raf();
}

function broadcastResponse(bc) {
  return new Promise(resolve => {
    bc.onmessage = event => {
      resolve(event.data);
    };
  });
}

function reset() {
  for (const iframe of [...document.querySelectorAll('.test-iframe')]) {
    iframe.remove();
  }
  return navigator.serviceWorker.getRegistrations().then(registrations => {
    return Promise.all(registrations.map(r => r.unregister()));
  });
}

function abortTest(callback, name) {
  return promise_test(async t => {
    await reset();

    // Register and activate.
    const reg = await service_worker_unregister_and_register(t, SW_URL, SCOPE);
    await wait_for_state(t, reg.installing, 'activated');

    // Create a channel for communication with the service worker.
    const channelName = Math.random() + '';
    const channel = new BroadcastChannel(channelName);

    // Promise for the next broadcast (from the service worker).
    const bcResponse = broadcastResponse(channel);

    // URL to fetch.
    // This will always be caught by the service worker.
    // 'whatever' doesn't need to exist.
    const fetchUrl = new URL('whatever', location);
    fetchUrl.searchParams.set('bc', channelName);

    await callback(t, channel, bcResponse, fetchUrl);
  }, name);
}

abortTest(async (t, channel, bcResponse, fetchUrl) => {
  fetchUrl.searchParams.set('wait-for-abort', '');

  const frame = await with_iframe(SCOPE);
  const controller = new AbortController();
  const signal = controller.signal;

  frame.contentWindow.fetch(fetchUrl, { signal });
  await nextFrame();
  controller.abort();
  await nextFrame();
  channel.postMessage('abort-expected');

  assert_equals(await bcResponse, 'aborted');
}, 'SW signal reacts to fetch abort');

abortTest(async (t, channel, bcResponse, fetchUrl) => {
  fetchUrl.searchParams.set('wait-for-abort', '');

  const frame = await with_iframe(SCOPE);
  const xhr = new frame.contentWindow.XMLHttpRequest();
  xhr.open('GET', fetchUrl);
  xhr.send();

  await nextFrame();
  xhr.abort();
  await nextFrame();
  channel.postMessage('abort-expected');

  assert_equals(await bcResponse, 'aborted');
}, 'SW signal reacts to XHR abort');

abortTest(async (t, channel, bcResponse, fetchUrl) => {
  fetchUrl.searchParams.set('wait-for-abort', '');

  const frame = await with_iframe(SCOPE);

  let img = new frame.contentWindow.Image();
  img.src = fetchUrl;
  frame.contentDocument.body.appendChild(img);
  img = undefined;

  await nextFrame();
  frame.remove();
  await nextFrame();
  channel.postMessage('abort-expected');

  assert_equals(await bcResponse, 'aborted');
}, 'SW signal reacts to fetch group termination');

abortTest(async (t, channel, bcResponse, fetchUrl) => {
  fetchUrl.searchParams.set('wait-for-abort', '');
  // The fetch URL isn't 'whatever' in this case, it's the SW scope.
  fetchUrl.pathname = new URL(SCOPE, location).pathname;

  const frame = document.createElement('iframe');
  frame.src = fetchUrl;
  document.body.append(frame);

  await nextFrame();
  frame.remove();
  await nextFrame();
  channel.postMessage('abort-expected');

  assert_equals(await bcResponse, 'aborted');
}, 'SW signal reacts to navigation termination');

abortTest(async (t, channel, bcResponse, fetchUrl) => {
  fetchUrl.searchParams.set('abort-not-expected', '');

  const frame = await with_iframe(SCOPE);
  const response = await frame.contentWindow.fetch(fetchUrl);
  const data = await response.json();

  assert_true(data.ok);

  channel.postMessage('ping');

  assert_equals(await bcResponse, 'aborted-false');
}, `SW signal doesn't react to successful fetch`);

promise_test(async t => {
  await reset();
}, 'Cleanup');
</script>

