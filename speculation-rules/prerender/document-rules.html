<!DOCTYPE html>
<title>Document rules prerendering</title>
<meta name="timeout" content="long">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/common/utils.js"></script>
<script src="/common/dispatcher/dispatcher.js"></script>
<script src="/html/browsers/browsing-the-web/remote-context-helper/resources/remote-context-helper.js"></script>
<script src="resources/utils.js"></script>

<script>
setup(() => assertSpeculationRulesIsSupported());

// TODO(domenic): it would be better if we parameterized the more-comprehensive ../prefetch/document-rules.https.html
// test. Notes about that, for the future:
// - The main work is abstracting out getPrefetchUrl()/isUrlPrefetched()/insertDocumentRule(), to have both prefetch
//   and prerender versions. The prerender versions could just check the header in a slightly different way.
// - We'd need to figure out where to put common resources and tests, which could be a bit of a pain.
// - The prefetch tests don't actually activate prefetches, whereas the tests below activate the prerenders. That seems
//   fine though; there's plenty of coverage for activation elsewhere.

promise_test(async t => {
  const rcHelper = new RemoteContextHelper();
  const referrerRC = await rcHelper.addWindow(undefined, { features: 'noopener' });

  const prerenderedRC = await referrerRC.helper.createContext({
    executorCreator(url) {
      return referrerRC.executeScript(url => {
        const script = document.createElement("script");
        script.type = "speculationrules";
        script.textContent = JSON.stringify({
          prerender: [
            {
              source: "document",
              eagerness: "eager"
            }
          ]
        });
        document.head.append(script);

        const link = document.createElement("a");
        link.href = url;
        document.body.append(link);
      }, [url]);
    }
  });

  await activatePrerenderRC(referrerRC, prerenderedRC, () => {
    document.querySelector("a").click();
  });
}, "no-predicate document rule");

promise_test(async t => {
  const rcHelper = new RemoteContextHelper();
  const referrerRC = await rcHelper.addWindow(undefined, { features: 'noopener' });

  const prerenderedRC = await referrerRC.helper.createContext({
    executorCreator(url) {
      return referrerRC.executeScript(url => {
        const script = document.createElement("script");
        script.type = "speculationrules";
        script.textContent = JSON.stringify({
          prerender: [
            {
              source: "document",
              eagerness: "eager",
              where: { selector_matches: "a.prerender-me" }
            }
          ]
        });
        document.head.append(script);

        const link = document.createElement("a");
        link.classList.add("prerender-me");
        link.href = url;
        document.body.append(link);
      }, [url]);
    }
  });

  const notPrerenderedRC = await referrerRC.helper.createContext({
    executorCreator(url) {
      return referrerRC.executeScript(url => {
        const link = document.createElement("a");
        link.classList.add("no-prerendering");
        link.href = url;
        document.body.append(link);
      }, [url]);
    }
  });

  const prerenderedPromise = prerenderedRC.executeScript(() => document.prerendering);
  const notPrerenderedPromise = notPrerenderedRC.executeScript(() => document.prerendering);

  referrerRC.navigate(() => {
    document.querySelector("a.no-prerendering").click();
  });

  assert_equals(await prerenderedPromise, true, "link that matches the selector must be prerendered");
  assert_equals(await notPrerenderedPromise, false, "link that does not match the selector must not be prerendered");
}, "selector_matches document rule");
</script>
