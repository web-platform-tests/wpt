!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.WebIDL2=t():e.WebIDL2=t()}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(r,s,function(t){return e[t]}.bind(null,s));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";function r(e){return e.startsWith("_")?e.slice(1):e}function s(e,{parser:t,allowDangler:n,listName:r="list"}){const s=t(e);if(!s)return[];s.tokens.separator=e.consume(",");const a=[s];for(;s.tokens.separator;){const s=t(e);if(!s){n||error(`Trailing comma in ${r}`);break}if(s.tokens.separator=e.consume(","),a.push(s),!s.tokens.separator)break}return a}function a(e){return e.consume("true","false","Infinity","-Infinity","NaN","decimal","integer")}function i({type:e,value:t}){switch(e){case"true":case"false":return{type:"boolean",value:"true"===e};case"Infinity":case"-Infinity":return{type:"Infinity",negative:e.startsWith("-")};case"[":return{type:"sequence",value:[]};case"decimal":case"integer":return{type:"number",value:t};case"string":return{type:"string",value:t.slice(1,-1)};default:return{type:e}}}function o(e,t,n,r,s){function a(n){return n>0?e.slice(t,t+n):e.slice(Math.max(t+n,0),t)}function i(n,{precedes:r}={}){const s=n.map(e=>e.trivia+e.value).join(""),a=e[t];return"eof"===a.type?s:r?s+a.trivia:s.slice(a.trivia.length)}const o="eof"!==e[t].type?e[t].line:e.length>1?e[t-1].line:1,u=function(e){const t=e.split("\n");return t[t.length-1]}(i(a(-5),{precedes:!0})),c=a(5),l=i(c),p=u+l.split("\n")[0]+"\n"+(" ".repeat(u.length)+"^ "+r);return{message:`${s} error at line ${o}${n?`, ${"Syntax"===s?"since":"inside"} \`${n.partial?"partial ":""}${n.type} ${n.name}\``:""}:\n${p}`,line:o,input:l,tokens:c}}function u(e,t,n,r){return o(e,t.index,n,r,"Validation").message}n.r(t);const c={decimal:/-?(?=[0-9]*\.|[0-9]+[eE])(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y,integer:/-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y,identifier:/[_-]?[A-Za-z][0-9A-Z_a-z-]*/y,string:/"[^"]*"/y,whitespace:/[\t\n\r ]+/y,comment:/((\/(\/.*|\*([^*]|\*[^\/])*\*\/)[\t\n\r ]*)+)/y,other:/[^\t\n\r 0-9A-Za-z]/y},l=["ByteString","DOMString","USVString"],p=["attribute","callback","const","deleter","dictionary","enum","getter","includes","inherit","interface","iterable","maplike","namespace","partial","required","setlike","setter","static","stringifier","typedef","unrestricted"],d=["-Infinity","FrozenArray","Infinity","NaN","Promise","boolean","byte","double","false","float","implements","legacyiterable","long","mixin","null","octet","optional","or","readonly","record","sequence","short","true","unsigned","void"].concat(p,l),f=["(",")",",","...",":",";","<","=",">","?","[","]","{","}"];class m{constructor(e){this.source=function(e){const t=[];let n=0,r="",s=1,a=0;for(;n<e.length;){const o=e.charAt(n);let u=-1;if(/[\t\n\r ]/.test(o)?u=i("whitespace",{noFlushTrivia:!0}):"/"===o&&(u=i("comment",{noFlushTrivia:!0})),-1!==u){const e=t.pop().value;s+=(e.match(/\n/g)||[]).length,r+=e,a-=1}else if(/[-0-9.A-Z_a-z]/.test(o)){if(-1===(u=i("decimal"))&&(u=i("integer")),-1===u){u=i("identifier");const e=t[t.length-1];-1!==u&&d.includes(e.value)&&(e.type=e.value)}}else'"'===o&&(u=i("string"));for(const i of f)if(e.startsWith(i,n)){t.push({type:i,value:i,trivia:r,line:s,index:a}),r="",u=n+=i.length;break}if(-1===u&&(u=i("other")),-1===u)throw new Error("Token stream not progressing");n=u,a+=1}return t.push({type:"eof",value:"",trivia:r}),t;function i(i,{noFlushTrivia:o}={}){const u=c[i];u.lastIndex=n;const l=u.exec(e);return l?(t.push({type:i,value:l[0],trivia:r,line:s,index:a}),o||(r=""),u.lastIndex):-1}}(e),this.position=0}error(e){throw new y(function(e,t,n,r){return o(e,t,n,r,"Syntax")}(this.source,this.position,this.current,e))}probe(e){return this.source.length>this.position&&this.source[this.position].type===e}consume(...e){for(const t of e){if(!this.probe(t))continue;const e=this.source[this.position];return this.position++,e}}unconsume(e){this.position=e}}class y extends Error{constructor({message:e,line:t,input:n,tokens:r}){super(e),this.name="WebIDLParseError",this.line=t,this.input=n,this.tokens=r}}class k{constructor({source:e,tokens:t}){Object.defineProperties(this,{source:{value:e},tokens:{value:t}})}toJSON(){const e={type:void 0,name:void 0};let t=this;for(;t!==Object.prototype;){const n=Object.getOwnPropertyDescriptors(t);for(const[t,r]of Object.entries(n))(r.enumerable||r.get)&&(e[t]=this[t]);t=Object.getPrototypeOf(t)}return e}}class b extends k{static parser(e,t){return()=>{const n=e.consume(t);if(n)return new b({source:e.source,tokens:{value:n}})}}get value(){return this.tokens.value.value}}class g extends k{static parse(e){const t=e.consume("=");if(!t)return null;const n=a(e)||e.consume("string","null","[")||e.error("No value for default"),r=[n];if("["===n.type){const t=e.consume("]")||error("Default sequence value must be empty");r.push(t)}return new g({source:e.source,tokens:{assign:t},expression:r})}constructor({source:e,tokens:t,expression:n}){super({source:e,tokens:t}),Object.defineProperty(this,"expression",{value:n})}get type(){return i(this.expression[0]).type}get value(){return i(this.expression[0]).value}get negative(){return i(this.expression[0]).negative}}class h extends b{static parse(e){const t=e.consume("string");if(t)return new h({source:e.source,tokens:{value:t}})}get type(){return"enum-value"}get value(){return super.value.slice(1,-1)}}class v extends k{static parse(e){const t={};if(t.base=e.consume("enum"),!t.base)return;t.name=e.consume("identifier")||e.error("No name for enum");const n=e.current=new v({source:e.source,tokens:t});return t.open=e.consume("{")||e.error("Bodyless enum"),n.values=s(e,{parser:h.parse,allowDangler:!0,listName:"enumeration"}),e.probe("string")&&e.error("No comma between enum values"),t.close=e.consume("}")||e.error("Unexpected value in enum"),n.values.length||e.error("No value in enum"),t.termination=e.consume(";")||e.error("No semicolon after enum"),n}get type(){return"enum"}get name(){return r(this.tokens.name.value)}}class x extends k{static parse(e){const t=e.consume("identifier");if(!t)return;const n={target:t};if(n.includes=e.consume("includes"),n.includes)return n.mixin=e.consume("identifier")||e.error("Incomplete includes statement"),n.termination=e.consume(";")||e.error("No terminating ; for includes statement"),new x({source:e.source,tokens:n});e.unconsume(t.index)}get type(){return"includes"}get target(){return r(this.tokens.target.value)}get includes(){return r(this.tokens.mixin.value)}}function w(e){const t=e.source,n="decimal",o="integer",u="identifier",c="string";function d(t){e.error(t)}function f(t){return e.probe(t)}function m(...t){return e.consume(...t)}function y(t){return e.unconsume(t)}function h(){const e=function(){const e=m("unsigned"),n=m("short","long");if(n){const r=m("long");return new T({source:t,tokens:{prefix:e,base:n,postfix:r}})}e&&d("Failed to parse integer type")}()||function(){const e=m("unrestricted"),n=m("float","double");if(n)return new T({source:t,tokens:{prefix:e,base:n}});e&&d("Failed to parse float type")}();if(e)return e;const n=m("boolean","byte","octet");return n?new T({source:t,tokens:{base:n}}):void 0}function w(e){const t=m("?");t&&(e.tokens.nullable=t),f("?")&&d("Can't nullable more than once")}class T extends k{constructor({source:e,tokens:t}){super({source:e,tokens:t}),Object.defineProperty(this,"subtype",{value:[]}),this.extAttrs=null}get generic(){return""}get nullable(){return!!this.tokens.nullable}get union(){return!1}get idlType(){if(this.subtype.length)return this.subtype;return r([this.tokens.prefix,this.tokens.base,this.tokens.postfix].filter(e=>e).map(e=>e.value).join(" "))}}class N extends T{static parse(e){const n=m("FrozenArray","Promise","sequence","record");if(!n)return;const r=new N({source:t,tokens:{base:n}});switch(r.tokens.open=m("<")||d(`No opening bracket after ${n.type}`),n.type){case"Promise":{f("[")&&d("Promise type cannot have extended attribute");const t=F(e)||d("Missing Promise subtype");r.subtype.push(t);break}case"sequence":case"FrozenArray":{const t=j(e)||d(`Missing ${n.type} subtype`);r.subtype.push(t);break}case"record":{f("[")&&d("Record key cannot have extended attribute");const n=m(...l)||d(`Record key must be one of: ${l.join(", ")}`),s=new T({source:t,tokens:{base:n}});s.tokens.separator=m(",")||d("Missing comma after record key type"),s.type=e;const a=j(e)||d("Error parsing generic type record");r.subtype.push(s,a);break}}return r.idlType||d(`Error parsing generic type ${n.type}`),r.tokens.close=m(">")||d(`Missing closing bracket after ${n.type}`),r}get generic(){return this.tokens.base.value}}class A extends T{static parse(e){const n={};if(n.open=m("("),!n.open)return;const r=new A({source:t,tokens:n});for(r.type=e||null;;){const e=j()||d("No type after open parenthesis or 'or' in union type");"any"===e.idlType&&d("Type `any` cannot be included in a union type"),r.subtype.push(e);const t=m("or");if(!t)break;e.tokens.separator=t}return r.idlType.length<2&&d("At least two types are expected in a union type but found less"),n.close=m(")")||d("Unterminated union type"),w(r),r}get union(){return!0}}function $(e){return function(e){let n=N.parse(e)||h();if(!n){const e=m(u,...l);if(!e)return;n=new T({source:t,tokens:{base:e}}),f("<")&&d(`Unsupported generic type ${e.value}`)}return"Promise"===n.generic&&f("?")&&d("Promise type cannot be nullable"),n.type=e||null,w(n),n.nullable&&"any"===n.idlType&&d("Type `any` cannot be made nullable"),n}(e)||A.parse(e)}function j(e){const t=U.parse(),n=$(e);return n&&(n.extAttrs=t),n}class M extends k{static parse(){const n=e.position,r={},s=new M({source:t,tokens:r});return r.optional=m("optional"),s.idlType=j("argument-type"),s.idlType?(r.optional||(r.variadic=m("...")),r.name=m(u,...p),r.name?(s.default=r.optional?g.parse(e):null,s):y(n)):y(n)}get optional(){return!!this.tokens.optional}get variadic(){return!!this.tokens.variadic}get name(){return r(this.tokens.name.value)}}function O(){return s(e,{parser:M.parse,listName:"arguments list"})}class P extends k{static parse(){const r={assign:m("=")},a=new P({source:t,tokens:r});return r.assign&&(r.secondaryName=m(u,n,o,c)),r.open=m("("),r.open?(a.list="identifier-list"===a.rhsType?function(){const t=s(e,{parser:b.parser(e,u),listName:"identifier list"});return t.length||d("Expected identifiers but none found"),t}():O(),r.close=m(")")||d("Unexpected token in extended attribute argument list")):a.hasRhs&&!r.secondaryName&&d("No right hand side to extended attribute assignment"),a}get rhsType(){return this.tokens.assign?this.tokens.secondaryName?this.tokens.secondaryName.type:"identifier-list":null}}class q extends k{static parse(){const e=m(u);if(e)return new q({tokens:{name:e},params:P.parse()})}constructor({source:e,tokens:t,params:n}){super({source:e,tokens:t}),Object.defineProperty(this,"params",{value:n})}get type(){return"extended-attribute"}get name(){return this.tokens.name.value}get rhs(){const{rhsType:e,tokens:t,list:n}=this.params;return e?{type:e,value:"identifier-list"===e?n:t.secondaryName.value}:null}get arguments(){const{rhsType:e,list:t}=this.params;return t&&"identifier-list"!==e?t:[]}}class U extends k{static parse(){const n={};if(n.open=m("["),!n.open)return null;const r=new U({source:t,tokens:n});return r.items=s(e,{parser:q.parse,listName:"extended attribute"}),n.close=m("]")||d("Unexpected form of extended attribute"),r.items.length||d("Found an empty extended attribute"),r}}class I extends k{static parse(){const n={};if(n.base=m("const"),!n.base)return;let r=h();if(!r){const e=m(u)||d("No type for const");r=new T({source:t,tokens:{base:e}})}f("?")&&d("Unexpected nullable constant type"),r.type="const-type",n.name=m(u)||d("No name for const"),n.assign=m("=")||d("No value assignment for const"),n.value=a(e)||d("No value for const"),n.termination=m(";")||d("Unterminated const");const s=new I({source:t,tokens:n});return s.idlType=r,s}get type(){return"const"}get name(){return r(this.tokens.name.value)}get value(){return i(this.tokens.value)}}class S extends k{static parse(n){const r={base:n},s=new S({source:t,tokens:r});return r.name=m(u)||d("No name for callback"),e.current=s,r.assign=m("=")||d("No assignment in callback"),s.idlType=F()||d("Missing return type"),r.open=m("(")||d("No arguments in callback"),s.arguments=O(),r.close=m(")")||d("Unterminated callback"),r.termination=m(";")||d("Unterminated callback"),s}get type(){return"callback"}get name(){return r(this.tokens.name.value)}}class E extends k{static parse({special:n,noInherit:r=!1,readonly:s=!1}={}){const a=e.position,i={special:n},o=new E({source:t,tokens:i});if(n||r||(i.special=m("inherit")),i.readonly=m("readonly"),s&&!i.readonly&&f("attribute")&&d("Attributes must be readonly in this context"),i.base=m("attribute"),i.base){switch(o.idlType=j("attribute-type")||d("No type in attribute"),o.idlType.generic){case"sequence":case"record":d(`Attributes cannot accept ${o.idlType.generic} types`)}return i.name=m(u,"required")||d("No name in attribute"),i.termination=m(";")||d("Unterminated attribute"),o}y(a)}get type(){return"attribute"}get special(){return this.tokens.special?this.tokens.special.value:""}get readonly(){return!!this.tokens.readonly}get name(){return r(this.tokens.name.value)}}function F(e){const n=$(e||"return-type");if(n)return n;const r=m("void");if(r){const e=new T({source:t,tokens:{base:r}});return e.type="return-type",e}}class _ extends k{static parse(){const e={},n=new _({source:t,tokens:e});return n.idlType=F()||d("Missing return type"),e.name=m(u),e.open=m("(")||d("Invalid operation"),n.arguments=O(),e.close=m(")")||d("Unterminated operation"),n}get name(){const{name:e}=this.tokens;return e?r(e.value):""}}class D extends k{static parse({special:e,regular:n}={}){const r={special:e},s=new D({source:t,tokens:r});return e&&"stringifier"===e.value&&(r.termination=m(";"),r.termination)?(s.body=null,s):(e||n||(r.special=m("getter","setter","deleter")),s.body=_.parse(),r.termination=m(";")||d("Unterminated attribute"),s)}get type(){return"operation"}get name(){return this.body&&this.body.name||""}get special(){return this.tokens.special?this.tokens.special.value:""}}function z(){const e=m("static");if(e)return E.parse({special:e})||D.parse({special:e})||d("No body in static member")}function R(){const e=m("stringifier");if(e)return E.parse({special:e})||D.parse({special:e})||d("Unterminated stringifier")}class W extends k{static parse(){const n=e.position,r={},s=new W({source:t,tokens:r});if(r.readonly=m("readonly"),r.base=r.readonly?m("maplike","setlike"):m("iterable","maplike","setlike"),!r.base)return void y(n);const{type:a}=s,i="maplike"===a,o=i||"iterable"===a;r.open=m("<")||d(`Error parsing ${a} declaration`);const u=j()||d(`Error parsing ${a} declaration`);return s.idlType=[u],o&&(u.tokens.separator=m(","),u.tokens.separator?s.idlType.push(j()):i&&d(`Missing second type argument in ${a} declaration`)),r.close=m(">")||d(`Unterminated ${a} declaration`),r.termination=m(";")||d(`Missing semicolon after ${a} declaration`),s}get type(){return this.tokens.base.value}get readonly(){return!!this.tokens.readonly}}class Z extends k{static parse(){const e=m(":");if(!e)return;const n=m(u)||d("No type in inheritance");return new Z({source:t,tokens:{colon:e,name:n}})}get name(){return r(this.tokens.name.value)}}class B extends k{static parse(t,{type:n,inheritable:r,allowedMembers:s}){const{tokens:a}=t;for(a.name=m(u)||d("No name for interface"),e.current=t,r&&(t.inheritance=Z.parse()||null),a.open=m("{")||d(`Bodyless ${n}`),t.members=[];;){if(a.close=m("}"),a.close)return a.termination=m(";")||d(`Missing semicolon after ${n}`),t;const e=U.parse();let r;for(const[e,...t]of s)if(r=e(...t))break;r||d("Unknown member"),r.extAttrs=e,t.members.push(r)}}get partial(){return!!this.tokens.partial}get name(){return r(this.tokens.name.value)}}class L extends B{static parse(e,{callback:n=null,partial:r=null}={}){const s={callback:n,partial:r,base:e};return B.parse(new L({source:t,tokens:s}),{type:"interface",inheritable:!r,allowedMembers:[[I.parse],[z],[R],[W.parse],[E.parse],[D.parse]]})}get type(){return this.tokens.callback?"callback interface":"interface"}}class V extends B{static parse(e,{partial:n}={}){const r={partial:n,base:e};if(r.mixin=m("mixin"),r.mixin)return B.parse(new V({source:t,tokens:r}),{type:"interface mixin",allowedMembers:[[I.parse],[R],[E.parse,{noInherit:!0}],[D.parse,{regular:!0}]]})}get type(){return"interface mixin"}}function C(e){const t=m("interface");if(t)return V.parse(t,e)||L.parse(t,e)||d("Interface has no proper body")}class J extends B{static parse({partial:e}={}){const n={partial:e};if(n.base=m("namespace"),n.base)return B.parse(new J({source:t,tokens:n}),{type:"namespace",allowedMembers:[[E.parse,{noInherit:!0,readonly:!0}],[D.parse,{regular:!0}]]})}get type(){return"namespace"}}class X extends B{static parse({partial:e}={}){const n={partial:e};if(n.base=m("dictionary"),n.base)return B.parse(new X({source:t,tokens:n}),{type:"dictionary",inheritable:!e,allowedMembers:[[G.parse]]})}get type(){return"dictionary"}}class G extends k{static parse(){const n={},r=new G({source:t,tokens:n});return r.extAttrs=U.parse(),n.required=m("required"),r.idlType=j("dictionary-type")||d("No type for dictionary member"),n.name=m(u)||d("No name for dictionary member"),r.default=g.parse(e),n.required&&r.default&&d("Required member must not have a default"),n.termination=m(";")||d("Unterminated dictionary member"),r}get type(){return"field"}get name(){return r(this.tokens.name.value)}get required(){return!!this.tokens.required}}class H extends k{static parse(){const n={},r=new H({source:t,tokens:n});if(n.base=m("typedef"),n.base)return r.idlType=j("typedef-type")||d("No type in typedef"),n.name=m(u)||d("No name in typedef"),e.current=r,n.termination=m(";")||d("Unterminated typedef"),r}get type(){return"typedef"}get name(){return r(this.tokens.name.value)}}function K(){return function(){const e=m("callback");if(!e)return;const t=m("interface");return t?L.parse(t,{callback:e}):S.parse(e)}()||C()||function(){const e=m("partial");if(e)return X.parse({partial:e})||C({partial:e})||J.parse({partial:e})||d("Partial doesn't apply to anything")}()||X.parse()||v.parse(e)||H.parse()||x.parse(e)||J.parse()}const Q=function(){if(!t.length)return[];const e=[];for(;;){const t=U.parse(),n=K();if(!n){t&&d("Stray extended attributes");break}n.extAttrs=t,e.push(n)}return e.push(m("eof")),e}();return e.position<t.length&&d("Unrecognised tokens"),Q}function T(e){return w(new m(e))}function N(e){return e}const A={wrap:e=>e.join(""),trivia:N,name:N,reference:N,type:N,generic:N,inheritance:N,definition:N,extendedAttribute:N,extendedAttributeReference:N};function $(e,{templates:t=A}={}){function n(e,n){return t.reference(e,n||e)}function r(e,n=N,...r){if(!e)return"";const s=n(e.value,...r);return t.wrap([t.trivia(e.trivia),s])}function s(e,t){return r(e,n,t)}function a(e,n){return r(e,t.name,n)}function i(e){if(e.union||e.generic)return t.wrap([r(e.tokens.base,t.generic),r(e.tokens.open),...e.subtype.map(o),r(e.tokens.close)]);const s=e.tokens.prefix||e.tokens.base,a=e.tokens.prefix?[e.tokens.prefix.value,t.trivia(e.tokens.base.trivia)]:[],i=n(t.wrap([...a,e.tokens.base.value,r(e.tokens.postfix)]),e.idlType);return t.wrap([t.trivia(s.trivia),i])}function o(e){return t.wrap([d(e.extAttrs),i(e),r(e.tokens.nullable),r(e.tokens.separator)])}function u(e){return e?t.wrap([r(e.tokens.assign),...e.expression.map(e=>r(e))]):""}function c(e){return t.wrap([d(e.extAttrs),r(e.tokens.optional),t.type(o(e.idlType)),r(e.tokens.variadic),a(e.tokens.name,{data:e}),u(e.default),r(e.tokens.separator)])}function l(e){return t.wrap([s(e.tokens.value),r(e.tokens.separator)])}function p(e){const{rhsType:n}=e.params;return t.wrap([t.trivia(e.tokens.name.trivia),t.extendedAttribute(t.wrap([t.extendedAttributeReference(e.name),r(e.params.tokens.assign),s(e.params.tokens.secondaryName),r(e.params.tokens.open),...e.params.list?e.params.list.map("identifier-list"===n?l:c):[],r(e.params.tokens.close)])),r(e.tokens.separator)])}function d(e){return e?t.wrap([r(e.tokens.open),...e.items.map(p),r(e.tokens.close)]):""}function f(e){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.callback),r(e.tokens.partial),r(e.tokens.base),r(e.tokens.mixin),a(e.tokens.name,{data:e}),(s=e.inheritance,s?t.wrap([r(s.tokens.colon),t.trivia(s.tokens.name.trivia),t.inheritance(n(s.tokens.name.value,s.name))]):""),r(e.tokens.open),k(e.members,e),r(e.tokens.close),r(e.tokens.termination)]),{data:e});var s}function m(e,n){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.readonly),r(e.tokens.base,t.generic),r(e.tokens.open),t.wrap(e.idlType.map(o)),r(e.tokens.close),r(e.tokens.termination)]),{data:e,parent:n})}t=Object.assign({},A,t);const y={interface:f,"interface mixin":f,namespace:f,operation:function(e,n){const s=e.body?[t.type(o(e.body.idlType)),a(e.body.tokens.name,{data:e,parent:n}),r(e.body.tokens.open),t.wrap(e.body.arguments.map(c)),r(e.body.tokens.close)]:[];return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.special),...s,r(e.tokens.termination)]),{data:e,parent:n})},attribute:function(e,n){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.special),r(e.tokens.readonly),r(e.tokens.base),t.type(o(e.idlType)),a(e.tokens.name,{data:e,parent:n}),r(e.tokens.termination)]),{data:e,parent:n})},dictionary:f,field:function(e,n){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.required),t.type(o(e.idlType)),a(e.tokens.name,{data:e,parent:n}),u(e.default),r(e.tokens.termination)]),{data:e,parent:n})},const:function(e,n){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.base),t.type(o(e.idlType)),a(e.tokens.name,{data:e,parent:n}),r(e.tokens.assign),r(e.tokens.value),r(e.tokens.termination)]),{data:e,parent:n})},typedef:function(e){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.base),t.type(o(e.idlType)),a(e.tokens.name,{data:e}),r(e.tokens.termination)]),{data:e})},includes:function(e){return t.definition(t.wrap([d(e.extAttrs),s(e.tokens.target,e.target),r(e.tokens.includes),s(e.tokens.mixin,e.includes),r(e.tokens.termination)]),{data:e})},callback:function(e){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.base),a(e.tokens.name,{data:e}),r(e.tokens.assign),t.type(o(e.idlType)),r(e.tokens.open),...e.arguments.map(c),r(e.tokens.close),r(e.tokens.termination)]),{data:e})},enum:function(e){return t.definition(t.wrap([d(e.extAttrs),r(e.tokens.base),a(e.tokens.name,{data:e}),r(e.tokens.open),k(e.values,e),r(e.tokens.close),r(e.tokens.termination)]),{data:e})},"enum-value":function(e,n){return t.wrap([t.trivia(e.tokens.value.trivia),t.definition(t.wrap(['"',t.name(e.value,{data:e,parent:n}),'"']),{data:e,parent:n}),r(e.tokens.separator)])},iterable:m,legacyiterable:m,maplike:m,setlike:m,"callback interface":f,eof:function(e){return t.trivia(e.trivia)}};function k(e,n){if(!e)return;const r=e.map(e=>(function(e,t){if(!y[e.type])throw new Error(`Type "${e.type}" is unsupported`);return y[e.type](e,t)})(e,n));return t.wrap(r)}return k(e)}function*j({unique:e,duplicates:t}){for(const n of t){const{name:t}=n,r=`The name "${t}" of type "${e.get(t).type}" was already seen`;yield u(n.source,n.tokens.name,n,r)}}function*M(e){const t=[...e.unique.values()].filter(e=>"interface"===e.type),n=function(){const t=new Map,n=e.all.filter(e=>"includes"===e.type);for(const r of n){const n=t.get(r.target),s=e.unique.get(r.includes);s&&(n?n.push(s):t.set(r.target,[s]))}return t}();for(const e of t)yield*r(e);function*r(t){const r=new Set(a(t).map(e=>e.name)),i=e.partials.get(t.name)||[],o=n.get(t.name)||[];for(const e of[...i,...o]){const n=a(e);yield*s(n,r,e,t);for(const e of n)r.add(e.name)}}function*s(e,t,n,r){for(const s of e){const{name:e}=s;if(e&&t.has(e)){const t=`The operation "${e}" has already been defined for the base interface "${r.name}" either in itself or in a mixin`;yield u(n.source,s.body.tokens.name,n,t)}}}function a(e){return e.members.filter(({type:e})=>"operation"===e)}}function O(e){const t=function(e){const t=new Map,n=new Set,r=new Map;for(const s of e)if(s.partial){const e=r.get(s.name);e?e.push(s):r.set(s.name,[s])}else s.name&&(t.has(s.name)?n.add(s):t.set(s.name,s));return{all:e,unique:t,partials:r,duplicates:n}}(e);return[...j(t),...M(t)]}n.d(t,"parse",function(){return T}),n.d(t,"write",function(){return $}),n.d(t,"validate",function(){return O})}])});
//# sourceMappingURL=webidl2.js.map