<!doctype html>
<!-- @{ -->
<meta charset=utf-8>
<title>HTML Editing APIs</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<style>
pre, code, xmp { font-family:monospace, sans-serif; }
h2 code, h3 code, h3 code,
h2 :link, h3 :link, h3 :link,
h2 :visited, h3 :visited, h3 :visited
{ font:inherit; color:inherit; font-style:italic; }
@media print {
  :not([data-anolis-spec]) > [data-anolis-spec]::after {
    content: "[" attr(data-anolis-spec) "]";
    font-size: 0.6em;
    vertical-align: super;
    text-transform: uppercase;
  }
}
xmp {
  font-size: inherit;
  font-variant: normal;
  margin-left: 2em;
  white-space: pre-wrap;
}
div.note > p:first-child::before { content: 'Note: '; }
.XXX > :last-child { margin-bottom: 0 }
.XXX li {
  margin-top: 0;
  margin-bottom: 0;
}
dd .XXX p { margin: 1em 0 }
ol li { margin: 1em 0 }
li li { margin: 0 }
table { margin: 1em 0 }
/* Overwrite the underline so it's orange instead of blue, thus looks less
 * silly */
a code { text-decoration: underline }
</style>
<body class=draft>
<div class=head id=head>
<h1>HTML Editing APIs</h1>
<h2 class="no-num no-toc">Work in Progress &mdash; Last Update [DATE: 01 Jan 1901]</h2>
<dl>
 <dt>Editor
 <dd>Aryeh Gregor &lt;<a href=mailto:ayg@aryeh.name>ayg@aryeh.name</a>>

 <dt>Latest version (may be unstable)
 <dd><a href=http://aryeh.name/spec/editing/editing.html>http://aryeh.name/spec/editing/editing.html</a>

 <dt>Version history
 <dd><a href=http://aryeh.name/gitweb.cgi?p=editing>http://aryeh.name/gitweb.cgi?p=editing</a>
 <dd><a href=https://github.com/ayg/editing>https://github.com/ayg/editing</a>
</dl>
</div>
<!-- @} -->

<h2 class=no-num>Status of this Document</h2>
<!-- @{ -->
<p>This document is a preliminary draft of a specification for HTML editing
APIs, mainly defining <code>execCommand()</code> and related functions.  It
largely replaces the <a
href=http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#editing-apis>Editing
APIs</a> section of the <a href=http://www.whatwg.org/html>HTML</a>
specification.  Feedback should preferably be sent to <a
href=http://lists.whatwg.org/listinfo.cgi/whatwg-whatwg.org>the WHATWG
list</a>.  Include the string "[editing]" somewhere in the subject, and CC <a
href=mailto:ayg@aryeh.name>ayg@aryeh.name</a> (or any of my other e-mail
addresses) to make sure I see it.

<p>This specification, along with the accompanying JavaScript implementation
and tests, are copyright Google, 2011.  They may be used under the terms of the
<a href=http://creativecommons.org/publicdomain/zero/1.0/>CC0 1.0 Universal
License</a>.
<!-- @} -->

<h2 class=no-num>Table of contents</h2>
<!--toc-->

<h2>Introduction</h2>
<!-- @{ -->
<p>This specification defines commands to edit HTML documents programmatically.
The APIs specified here were originally introduced in Microsoft's Internet
Explorer, but have subsequently been copied by other browsers in a haphazard
and imprecise fashion.  Although the behavior specified here does not exactly
match any browser at the time of writing, it can serve as a target to converge
to in the future.

<p>Where the reasoning behind the specification is of interest, such as when
major preexisting rendering engines are known not to match it, the reasoning is
included in HTML comments so as not to distract the reader.  If you have
questions about why the specification says something, check for comments in the
source first.  They're sometimes longer than the specification text itself, and
commonly record what the major browsers do and other essential information.

<p>The principles I've used for writing this specification so far are:

<ul>
  <li>If all browsers that implement a particular feature agree on some detail
  of how it works, match them unless there's very good reason not to.  When
  it's not clear what behavior is best, try to follow the implementations with
  the most market share.  But if one browser's behavior is clearly better than
  the others', go with the better behavior.

  <li>If a command is issued to format some text in a particular way, we will
  format the text that way no matter what.  If the user clicks the "bold"
  button, they don't care that the text didn't become bold because of an
  external CSS rule or for any other reason, they only care that it didn't
  work.  The only exception (beyond where it's simply impossible, like
  propagated text-decorations we can't remove) is that we don't try to override
  !important rules from external stylesheets, although we also don't go out of
  our way to respect them.

  <li>When we're given a presentational command like "bold", don't modify
  anything other than presentational markup related to that command.  If an
  element has non-presentational attributes like id or class, don't split it up
  or remove it or anything.  At most convert it to a span, if it's some type of
  presentational element.  ("Presentational" here really means "browsers
  produce it in response to execCommand() so we need to treat it as
  presentational", so it includes things like [[strong]] and [[em]].)  Of
  course, in some cases we have to remove elements, like when merging two
  blocks.

  <li>Don't interfere with more markup than necessary.  If the user modifies
  only a small run of text, don't go around simplifying ancestors or siblings
  or whatever unless it's necessary to produce simpler markup in the place that
  was actually modified.

  <li>But if we are already changing around something's style, convert existing
  styles to the preferred format.  For instance, we use <code
  title>&lt;b></code> for bold (if the CSS styling flag is false), and convert
  <code title>&lt;strong></code> and <code title>&lt;span style="font-weight:
  bold"></code> if we happen to be modifying that node anyway.

  <li>Try not to make the document less conforming than it originally was.  If
  we happen to make it more conforming, good, although we don't have to go out
  of our way to do that.  In some cases we do make the document less
  conforming, generally because there's some clear use-case that requires it or
  because it matches existing browsers behavior.  (For instance, see the
  styleWithCSS = false mode, and the fact that insertImage doesn't add an
  alt attribute, etc.)

  <li>Keep the markup as concise as possible.  (I've received feedback that
  this is very important to authors.)  Ideally, the markup should look as
  simple and neat as what a human would have produced by hand-editing.  We do
  complicated manipulation to pull styles down from ancestors rather than
  having to use inline CSS, and make sure to tidy up any styles on elements
  that we happen to be modifying anyway.  Previous principles take precedence
  over this one, however.
</ul>
<!-- @} -->

<h2>Issues</h2>
<!-- @{ -->
<p>This specification is mostly feature-complete.  It's more or less fully
implemented in JavaScript, and has been tested on a fairly significant amount
of artificial input.  It has not been tested on real-world sites that use
execCommand(), and has not been thoroughly reviewed by anyone other than me.
It should be considered mostly stable and awaiting implementater review and
feedback.

<p>Significant known issues that I need feedback on, or otherwise am not
planning to fix just yet:

<ul>
  <li>Need to make CSS terminology more precise, about setting/unsetting CSS
  properties.  The intent is to modify the style attribute, CSSOM-style.
  Likewise, CSS value comparisons need to be done after serializing both
  values, so "bold" == "700" and "red" == "#f00" and so on.  Suggestions
  appreciated on how I should spec this.

  <li>I use [[resval]] instead of computed or used or anything like that, just
  because that's what my test implementation uses (via getComputedStyle).  This
  is not necessarily the best actual choice: if it should be something else,
  please tell me.

  <li><p>I haven't paid much attention to performance.  The algorithms here
  aren't performance-critical in most cases, but I might have accidentally
  included some algorithms that are too slow anyway on large pages.  Generally
  I haven't worried about throwing nodes away and recreating them multiple
  times or things like that, as long as it produces the correct result.

  <p>If it would be useful to implementers for me to spend time and spec
  complexity on avoiding some of the masses of useless operations that are
  currently required, please say so.  All intermediate DOM states are
  black-box detectable via mutation events or whatever their replacement will
  be, so implementers theoretically can't optimize most of this stuff too much
  themselves, but in practice I doubt anyone will rely on the intermediate DOM
  states much.

  <li>[[br]]s are a nightmare.  I have tons of hacks all over the place which
  are totally wrong, mostly to account for the fact that sometimes [[br]]s do
  nothing and we need to treat that case magically.  I don't know what a good
  way is to fix this.  At this point I've mostly gotten the evil concentrated
  in the definitions "collapsed line break", "extraneous line break", and
  "collapsed block prop", but there's lots of other special-case handling
  scattered about.  Feedback appreciated.  How do browsers handle this?

  <li>The CSS styling flag is an issue.  Currently authors are forced to turn
  it entirely on or entirely off.  If it's on, it produces stuff like <code
  title>&lt;span style=font-weight:bold></code> instead of <code
  title>&lt;b></code>, while if it's off, it produces stuff like <code
  title>&lt;font color=red></code> instead of <code title>&lt;span
  style=color:red></code>.  The issue is that authors might want a mix, like
  making the markup as concise as possible while still conforming, and they
  can't do that.  Changing the flag on a per-command basis doesn't help because
  of things like the "restore the values" algorithm, which might create several
  different types of style at once and has to use the same styling flag for all
  of them.  This was discussed back in March in <a
  href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-March/030714.html>this
  thread</a>, along with a number of other things, but at that time I hadn't
  written commands that change multiple styles at once, so it seemed feasible
  to ask authors to switch styleWithCSS on or off on a per-command basis.

  <li>I haven't defined the "undo" or "redo" commands yet.  They look very
  complicated to define precisely, and other people are working on them right
  now.
</ul>

<p class=XXX>A variety of other issues are also noted in the text, formatted
like this.  Feedback would be appreciated on all of them.

<p>Things that would be useful to address for the future but aren't important
to fix right now are in comments prefixed with "TODO".

<!--
TODO:

* Scour browser bug trackers to try spotting issues I haven't thought of.

* The wording I use for DOM stuff is not maximally precise.  Really I want DOM
  Core to define nice concepts that I can xref, like "insert a node".  I
  don't want to have to explicitly refer to DOM methods like insertBefore()
  every time I want to move things.

* JavaScript can modify the DOM synchronously in some cases, such as DOM
  mutation events and onunload when moving around iframes and objects.  This
  has to be dealt with somehow.  (Pointed out by Ryosuke Niwa of WebKit:
  http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030730.html
  http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-March/030751.html)

* What happens if you do something like delete a selection or insert text or
  whatnot in the middle of a surrogate pair?  This could make the content not
  serialize through a character encoding change.

* Probably need to record and restore overrides in some more places.

* Some more thought needs to go into what happens to the selection when you
  mutate the DOM.  In some cases the results are pretty arbitrary.  It might
  make sense to do some kind of normalization.

* I'm sloppy about handling things like nodes that don't descend from a
  Document, comments that are children of a Document, that sort of thing.  Not
  essential for prototyping, but needs to be cleaned up eventually.  Mostly we
  should be able to avoid the problems by requiring that everything be
  editable, since that immediately means it has to descend from an element or
  Document (and cannot be parentless itself).

* I need to pay more attention to invisible nodes.  These will have no visual
  effect, but they'll make many algorithms behave differently: decomposing a
  range, block-extending, etc.  Also, need to improve the definition to include
  things like whitespace-only nodes.

* Have to make sure that in all the places where we set a selection, it's
  valid.

* Redefine things in terms of ranges, not selections.

* Allow some type of switch to affect non-editable regions too, perhaps on a
  per-command basis.
-->

<!--
TODO: Things that are only implemented by a couple of browsers and may or may
not be useful to spec:

* decreaseFontSize, increaseFontSize: Only implemented in Gecko and Opera.
* contentReadOnly, enableInlineTableEditing, enableObjectResizing, heading,
  insertBrOnReturn: MDC docs say not implemented in IE (didn't test).
* readOnly: MDC docs say it's a deprecated equivalent of contentReadOnly, so
  presumably like useCSS but less popular.
* 2D-Position, absolutePosition, clearAuthenticationCache, createBookmark,
  insertButton, insertFieldset, insertIframe, insertInput*, insertMarquee,
  insertSelectDropdown, insertSelectListbox, insertTextarea, liveResize,
  multipleSelection, overwrite, print, refresh, saveAs, unbookmark: Mentioned
  in MSDN docs but not MDC, so presumably IE-only.  Some of these seem
  inappropriate or useless, others will bear investigation.
* findString, fontSizeDelta, insertNewlineInQuotedContent, justifyNone, print,
  transpose: There's code for these in WebKit,
  Source/WebCore/editing/EditorCommand.cpp, but I didn't see them mentioned
  elsewhere.  Some might be worth adding.
* unselect: Seems to not be implemented by Gecko or Opera, and IE behaves
  oddly: it seems to collapse the selection instead of removing it.  Will only
  implement if there seems to be demand; it's redundant to
  Selection.removeAllRanges() anyway.

Things I haven't looked at that multiple browsers implement:

* redo, undo: Needs review of the Google work on this; will probably be
  quite complicated.

Also need to look at contenteditable=plaintext-only.
-->
<!-- @} -->

<h2>Commands</h2>

<h3>Properties of commands</h3>
<!-- @{ -->
<p>This specification defines a number of <dfn title=command>commands</dfn>,
identified by <span data-anolis-spec=domcore>ASCII case-insensitive</span>
strings.  Each <span>command</span> can have several pieces of data associated
with it:

<ul>
  <li><dfn>Action</dfn>: What the <span>command</span> does when executed via
  <code>execCommand()</code>.  Every <span>command</span> defined in this
  specification has an <span>action</span> defined for it in the relevant
  section.  For example, <span>the <code title>bold</code> command</span>'s
  <span>action</span> generally makes the current selection bold, or removes
  bold if the selection is already bold.  An editing toolbar might provide
  buttons that execute the <span>action</span> for a <span>command</span> if
  clicked, or a script might run an <span>action</span> without user
  interaction to achieve some particular effect.

  <li><dfn>Indeterminate</dfn>: A boolean value returned by
  <code>queryCommandIndeterm()</code>, depending on the current state of the
  document.  Generally, a <span>command</span> that has a <span>state</span>
  defined will be <span>indeterminate</span> if the <span>state</span> is true
  for part but not all of the current selection, and a <span>command</span>
  that has a <span>value</span> defined will be <span>indeterminate</span> if
  different parts of the selection have different <span
  title=value>values</span>.  An editing toolbar might display a button or
  control in a special way if the <span>command</span> is
  <span>indeterminate</span>, like showing a "bold" button as partially
  depressed, or leaving a font size selector blank instead of showing the font
  size of the current selection.  As a rule, a <span>command</span> can only be
  <span>indeterminate</span> if its <span>state</span> is false, supposing it
  has a <span>state</span>.

  <li><dfn>State</dfn>: A boolean value returned by
  <code>queryCommandState()</code>, depending on the current state of the
  document.  The <span>state</span> of a <span>command</span> is true if it is
  already in effect, in some sense specific to the <span>command</span>.  Most
  <span title=command>commands</span> that have a <span>state</span> defined
  will take opposite <span title=action>actions</span> depending on whether the
  <span>state</span> is true or false, such as making the selection bold if the
  <span>state</span> is false and removing bold if the <span>state</span> is
  true.  Others will just have no effect if the <span>state</span> is true,
  like <span>the <code title>justifyCenter</code> command</span>.  Still others
  will have the same effect regardless, like <span>the <code
  title>styleWithCss</code> command</span>.  An editing toolbar might display a
  button or control differently depending on the <span>state</span> and <span
  title=indeterminate>indeterminacy</span> of the <span>command</span>.

  <li><dfn>Value</dfn>: A string returned by <code>queryCommandValue()</code>,
  depending on the current state of the document.  A <span>command</span>
  usually has a <span>value</span> instead of a <span>state</span> if the
  property it modifies can take more than two different values, like <span>the
  <code title>foreColor</code> command</span>.  If the <span>command</span> is
  <span>indeterminate</span>, its <span>value</span> is generally based on the
  start of the selection.  Otherwise, in most cases the <span>value</span>
  holds true for the entire selection, but see <span>the <code
  title>justifyCenter</code> command</span> and <span title="the justifyFull
  command">its</span> <span title="the justifyLeft command">three</span> <span
  title="the justifyRight command">companions</span> for an exception.  An
  editing toolbar might display the <span>value</span> of a
  <span>command</span> as selected in a drop-down or filled in in a text box,
  if the <span>command</span> isn't <span>indeterminate</span>.

  <li><dfn>Relevant CSS property</dfn>: This is defined for certain <a
  href=#inline-formatting-commands>inline formatting commands</a>, and is used
  in algorithms specific to those commands.  It is an implementation detail,
  and is not exposed to authors.  If a <span>command</span> does not have a
  <span>relevant CSS property</span> specified, it defaults to null.
</ul>

<!-- @} -->
<h3>Supported commands</h3>
<!-- @{ -->
<p>Some <span title=command>commands</span> will be <dfn>supported</dfn> in a
given user agent, and some will not.  All <span title=command>commands</span>
defined in this specification must be <span>supported</span>, except optionally
<span>the <code title>copy</code> command</span>, <span>the <code
title>cut</code> command</span>, and/or <span>the <code title>paste</code>
command</span>.  Additional <span title=command>commands</span> can also be
<span>supported</span>, but implementers should prefix any nonstandard
<span>command</span> names with a vendor-specific string (e.g., "ms", "gecko",
"webkit", "opera").
<!-- If you try doing anything with an unrecognized command, IE9 throws an
"Invalid argument" exception, and Firefox 6.0a2 throws
NS_ERROR_NOT_IMPLEMENTED.  Chrome 14 dev and Opera 11.11 both just return a
useless value.  I go with IE/Gecko, although of course with a standard
exception type. -->

<p>A <span>command</span> that does absolutely nothing in a particular user
agent, such that <code>execCommand()</code> never has any effect and
<code>queryCommandEnabled()</code> and <code>queryCommandIndeterm()</code> and
<code>queryCommandState()</code> and <code>queryCommandValue()</code> each
return the same value all the time, must not be <span>supported</span>.
<!-- I.e., no trying to look good on lazy conformance tests by just sticking in
a stub implementation that does nothing. -->

<p>In a particular user agent, every <span>command</span> must be consistently
either <span>supported</span> or not.  Specifically, a user agent must not
permit one page to see the same <span>command</span> sometimes
<span>supported</span> and sometimes not over the course of the same browsing
session, unless the user agent has been upgraded or reconfigured in the middle
of a session.  However, user agents may treat the same <span>command</span> as
<span>supported</span> for some pages and not others, e.g., if the
<span>command</span> is only supported for certain origins for security
reasons.

<p>Authors can tell whether a <span>command</span> is <span>supported</span>
using <code>queryCommandSupported()</code>.

<!-- @} -->
<h3>Enabled commands</h3>
<!-- @{ -->
<p>At any given time, a <span>supported</span> command can be either
<dfn>enabled</dfn> or not.  Authors can tell whether a <span>command</span> is
currently <span>enabled</span> using <code>queryCommandEnabled()</code>.  <span
title=command>Commands</span> that are not <span>enabled</span> do nothing, as
described in the definitions of the various methods that invoke <span
title=command>commands</span>.

<p>Among <span title=command>commands</span> defined in this specification,
those listed in <a href=#miscellaneous-commands>Miscellaneous commands</a> are
always <span>enabled</span>.  The other <span title=command>commands</span>
defined here are <span>enabled</span> if the <span>active range</span> is not
null, and disabled otherwise.

<!--
Testing with bold:

IE10PP2 seems to return true if the active range's start node is editable,
false otherwise.

Firefox 6.0a2 seems to always return true if there's anything editable on the
page, and throw otherwise.

Chrome 14 dev seems to behave the same as IE10PP2.

Opera 11.11 seems to always return true if there's anything editable on the
page, and false otherwise.

Firefox and Opera behave more or less uselessly.  IE doesn't make much sense,
in that whether a command is enabled seems meaningless: it will execute it on
all nodes in the selection, editable or not.  Chrome's definition makes sense
in that it will only run the command if it's enabled, but it doesn't make much
sense to only have the command run if the start is editable.

It's not clear to me what the point of this method is.  There's no way we're
going to always return true if the command will do something and false if it
won't.  I just stuck with a really conservative definition that happens to be
convenient: if there's nothing selected, obviously nothing will work, and we
want to bail out early in that case anyway because all the algorithms will talk
about the active range.  If there are use-cases for it to be more precise, I
could make it so.
-->

<!-- @} -->

<h2>Methods of the <code data-anolis-spec=html>HTMLDocument</code> interface</h2>
<!-- @{ -->
<p>When the <dfn title=execCommand()><code>execCommand(<var>command</var>,
<var>show UI</var>, <var>value</var>)</code></dfn> method on the <code
data-anolis-spec=html>HTMLDocument</code> interface is invoked, the user agent
must run the following steps:

<ol>
  <li>If only one argument was provided, let <var>show UI</var> be false.

  <li>If only one or two arguments were provided, let <var>value</var> be the
  empty string.

  <li>If <var>command</var> is not <span>supported</span>, raise a
  [[NOT_SUPPORTED_ERR]] exception.

  <li>If <var>command</var> has no <span>action</span>, raise an
  [[INVALID_ACCESS_ERR]] exception.

  <p class=note>No such <span>command</span> is defined in this specification.
  <!-- I'm just speccing INVALID_ACCESS_ERR for consistency.  I don't expect
  real-world commands are likely to not have an action defined, but you never
  know. -->

  <li>If <var>command</var> is not <span>enabled</span>, return false.
  <!--
  I didn't research this closely, but at a first glance, this is possibly how
  Chrome 14 dev and Opera 11.11 behave.  Maybe also Firefox 6.0a2, except it
  throws if the command isn't enabled, I think.  IE9 returns true in at least
  some cases even if the command is disabled.
  -->
  <!-- TODO: Is this right?  Maybe we should be returning false in other cases
  too? -->

  <li>Take the <span>action</span> for <var>command</var>, passing
  <var>value</var> to the instructions as an argument.

  <li>Return true.
</ol>

<!-- TODO: Define behavior for <var>show UI</var>. -->

<p>When the <dfn
title=queryCommandEnabled()><code>queryCommandEnabled(<var>command</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface is
invoked, the user agent must run the following steps:

<ol>
  <li>If <var>command</var> is not <span>supported</span>, raise a
  [[NOT_SUPPORTED_ERR]] exception.

  <li>Return true if <var>command</var> is <span>enabled</span>, false
  otherwise.
</ol>

<p>When the <dfn
title=queryCommandIndeterm()><code>queryCommandIndeterm(<var>command</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface is
invoked, the user agent must run the following steps:

<ol>
  <li>If <var>command</var> is not <span>supported</span>, raise a
  [[NOT_SUPPORTED_ERR]] exception.

  <li>If <var>command</var> has no <span
  title=indeterminate>indeterminacy</span>, raise an [[INVALID_ACCESS_ERR]]
  exception.

  <li>If <var>command</var> is not <span>enabled</span>, return false.

  <li>Return true if <var>command</var> is <span>indeterminate</span>,
  otherwise false.
</ol>
<!--
What happens if you call queryCommand(Indeterm|State|Value)() on a command
where it makes no sense?

IE9 consistently returns false for all three.

Firefox 6.0a2 consistently throws NS_ERROR_FAILURE for indeterm/state if not
supported, and returns an empty string for value.  Exceptions include unlink
(seems to always return indeterm/state false), and styleWithCss/useCss (throw
NS_ERROR_FAILURE even for value).

Chrome 14 dev returns false for all three, and even does this for unrecognized
commands.  It also always defines value if state is defined: it returns the
state cast to a string, either "true" or "false".

Opera 11.11 returns false for state and "" for value (it doesn't support
indeterm).  Like Chrome, this is even for unrecognized commands.

Gecko's behavior is the most useful.  If the author tries querying some aspect
of a command that makes no sense, they shouldn't receive a value that looks
like it might make sense but is actually just a constant.  However, I go even
further than Gecko: I require exceptions even for value, since doing otherwise
makes no sense.
-->

<p>When the <dfn
title=queryCommandState()><code>queryCommandState(<var>command</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface is
invoked, the user agent must run the following steps:

<ol>
  <li>If <var>command</var> is not <span>supported</span>, raise a
  [[NOT_SUPPORTED_ERR]] exception.

  <li>If <var>command</var> has no <span>state</span>, raise an
  [[INVALID_ACCESS_ERR]] exception.

  <li>If <var>command</var> is not <span>enabled</span>, return false.

  <li>If the <span>state override</span> for <var>command</var> is set, return
  it.

  <li>Return true if <var>command</var>'s <span>state</span> is true, otherwise
  false.
</ol>

<p>When the <dfn
title=queryCommandSupported()><code>queryCommandSupported(<var>command</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface is
invoked, the user agent must return true if <var>command</var> is
<span>supported</span>, and false otherwise.
<!--
Firefox 6.0a2 always throws an exception when this is called.  Opera 11.11
seems to return false if there's nothing editable on the page, which is
unhelpful.  The spec follows IE9 and Chrome 14 dev.  The reason this is useful,
compared to just running one of the other methods and seeing if you get a
NOT_SUPPORTED_ERR, is that other methods might throw different exceptions for
other reasons.  It's easier to check a boolean than to check exception types,
especially since as of June 2011 UAs aren't remotely consistent on what they do
with unsupported commands.
-->

<p>When the <dfn
title=queryCommandValue()><code>queryCommandValue(<var>command</var>)</code></dfn>
method on the <code data-anolis-spec=html>HTMLDocument</code> interface is
invoked, the user agent must run the following steps:

<ol>
  <li>If <var>command</var> is not <span>supported</span>, raise a
  [[NOT_SUPPORTED_ERR]] exception.

  <li>If <var>command</var> has no <span>value</span>, raise an
  [[INVALID_ACCESS_ERR]] exception.

  <li>If <var>command</var> is not <span>enabled</span>, return the empty
  string.
  <!-- This is what Firefox 6.0a2 and Opera 11.11 seem to do.  Chrome 14 dev
  seems to return the string "false", and IE9 seems to return boolean false.
  -->

  <li>If the <span>value override</span> for <var>command</var> is set, return
  it.

  <li>Return <var>command</var>'s <span>value</span>.
</ol>

<p>All of these methods must treat their <var>command</var> argument <span
data-anolis-spec=domcore title="ASCII case-insensitive">ASCII
case-insensitively</span>.

<div class=note>
<p>The methods in this section have mostly been designed so that the following
invariants hold after <code title>execCommand()</code> is called, assuming it
didn't throw an exception:

<ul>
  <li><code title>queryCommandIndeterm()</code> will return false (or throw an
  exception).

  <li><code title>queryCommandState()</code> will return the opposite of what it did
  before <code title>execCommand()</code> was called (or throw an exception).

  <li><code title>queryCommandValue()</code> will return something equivalent to the
  value passed to <code title>execCommand()</code> (or throw an exception).
  "Equivalent" here needs to be construed broadly in some cases, such as
  <code title>fontSize</code>.
</ul>

<p>The first two points do not always hold for <code title>strikethrough</code>
or <code title>underline</code>, because it can be impossible to unset
text-decoration in CSS.  Also, by design, the state of <code
title>insertOrderedList</code> and <code title>insertUnorderedList</code> might
be true both before and after calling, because they only remove one level of
indentation.  <code title>unlink</code> should set the value to null.  And
finally, the state of the various <code title>justify</code> commands should
always be true after calling, and the value should always be the appropriate
string ("center", "justify", "left", or "right").  Any other deviations from
these invariants are bugs in the specification.
</div>
<!-- @} -->

<h2>Common definitions</h2>
<!-- @{ -->
<p>An <dfn>HTML element</dfn> is an [[element]] whose [[namespace]] is the
[[htmlnamespace]].

<p>A <dfn>prohibited paragraph child name</dfn> is "address", "article",
"aside", "blockquote", "caption", "center", "col", "colgroup", "dd", "details",
"dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form",
"h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "li", "listing",
"menu", "nav", "ol", "p", "plaintext", "pre", "section", "summary", "table",
"tbody", "td", "tfoot", "th", "thead", "tr", "ul", or "xmp".

<p>A <dfn>prohibited paragraph child</dfn> is an <span>HTML element</span>
whose [[localname]] is a <span>prohibited paragraph child name</span>.
<!-- These are all the things that will close a <p> if found as a descendant.
I think.  Plus table stuff, since that can't be a descendant of a p either,
although it won't auto-close it. -->

<p>A <dfn>block node</dfn> is either an [[element]] whose "display" property
does not have [[resval]] "inline" or "inline-block" or "inline-table" or
"none", or a [[document]], or a [[documentfragment]].

<p>An <dfn>inline node</dfn> is a [[node]] that is not a <span>block
node</span>.
<!--
The block/inline node definitions are CSS-based.  "Prohibited paragraph child"
is conceptually similar to "block node", but based on the element name.
Generally we want to use block/inline node when we're interested in the visual
effect, and prohibited paragraph children when we're concerned about parsing or
semantics.
-->

<p>An <dfn>editing host</dfn> is a [[node]] that is either an [[element]] with
a <code data-anolis-spec=html title=attr-contenteditable>contenteditable</code>
attribute set to the true state, or the [[element]] [[child]] of a [[document]]
whose <code data-anolis-spec=html>designMode</code> is enabled.

<p>Something is <dfn>editable</dfn> if it is a [[node]] which is not an
<span>editing host</span>, does not have a <code data-anolis-spec=html
title=attr-contenteditable>contenteditable</code> attribute set to the false
state, and whose [[parent]] is an <span>editing host</span> or
<span>editable</span>.

<p class=note>An <span>editable</span> node cannot be a [[document]] or
[[documentfragment]], its [[parent]] cannot be null, and it must descend from
either an [[element]] or a [[document]].

<p>The <dfn>editing host of</dfn> <var>node</var> is null if <var>node</var> is
neither <span>editable</span> nor an <span>editing host</span>; <var>node</var>
itself, if <var>node</var> is an <span>editing host</span>; or the nearest
[[ancestor]] of <var>node</var> that is an <span>editing host</span>, if
<var>node</var> is <span>editable</span>.

<p>Two [[nodes]] are <dfn>in the same editing host</dfn> if the <span>editing
host of</span> the first is non-null and the same as the <span>editing host
of</span> the second.

<p class=note>Barring bugs, the algorithms here will not alter the attributes
of a non-editable element; will not remove a non-editable node from its parent
(except to immediately give it a new parent in the same editing host); and will
not add, remove, or reorder children of a node unless it is either editable or
an editing host.  An editing host is never editable, so authors are assured
that editing commands will only modify the editing host's contents and not the
editing host itself.

<p>A <dfn>collapsed line break</dfn> is a [[br]] that begins a line box which
has nothing else in it, and therefore has zero height.

<p class=XXX>Is this a good definition at all?  I mean things like
&lt;p>foo&lt;br>&lt;/p>, or the second one in &lt;p>foo&lt;br>&lt;br>&lt;/p>.
The way I test it is by adding a text node after it containing a zwsp; if that
changes the offsetHeight of its nearest non-inline ancestor, I deem it
collapsed.  But what if it happens to be display: none right now, for instance?
Or its ancestor has a fixed height?  Would it be better to use some DOM-based
definition?

<p>An <dfn>extraneous line break</dfn> is a [[br]] that has no visual effect,
in that removing it from the DOM would not change layout, except that a [[br]]
that is the sole child of an [[li]] is not extraneous.

<p class=XXX>Also possibly a bad definition.  Again, I test by just removing it
and seeing what happens.  (Actually, setting display: none, so that it doesn't
mess up ranges.)

<!-- TODO: The thing about li is a not very nice hack.  The issue is that an li
won't collapse even if it has no children at all, but that's not true in all
browsers (at least not in Opera 11.11), and also it breaks assumptions
elsewhere.  E.g., if it gets turned into a p. -->

<p>Something is <dfn>visible</dfn> if it is a [[node]] that either is a
<span>block node</span>, or a [[text]] node whose [[cddata]] is not empty, or
an [[img]], or a [[br]] that is not an <span>extraneous line break</span>, or
any [[node]] with a <span>visible</span> [[descendant]].

<p>Something is <dfn>invisible</dfn> if it is a [[node]] that is not
<span>visible</span>.

<p class=XXX>I don't know if the visible/invisible node definitions are really
the way we want to do things.  If they are, they need some adjustment, like to
handle collapsed whitespace nodes.

<p>A <dfn>collapsed block prop</dfn> is either a <span>collapsed line
break</span> that is not an <span>extraneous line break</span>, or an
[[element]] that is an <span>inline node</span> and whose [[children]] are all
either <span>invisible</span> or <span title="collapsed block prop">collapsed
block props</span> and that has at least one [[child]] that is a
<span>collapsed block prop</span>.

<p class=note>A collapsed block prop is something like the <code
title>&lt;br></code> in <code title>&lt;p>&lt;br>&lt;/p></code>, or the <code
title>&lt;br></code> and <code title>&lt;span></code> in <code
title>&lt;p>&lt;span>&lt;br>&lt;/span>&lt;/p></code>.  These are necessary to
stop the block from having zero height when it has no other contents, but serve
no purpose and should be removed once the block has other contents that stop it
from collapsing.

<p>The <dfn>active range</dfn> is the first [[range]] in the [[selection]]
given by calling [[getselection]] on the [[contextobject]], or null if there is
no such [[range]].

<!-- TODO: I say "first range" because I think that's what Gecko actually does,
and Gecko is the only one that allows multiple ranges in a selection.  This is
keeping in mind that it stores ranges sorted by start, not by the order the
user added them, and silently removes or shortens existing ranges to avoid
overlap.  It probably makes the most sense in the long term to have the command
affect all ranges.  But I'll leave this for later. -->

<p>Each [[htmldocument]] has a boolean <dfn>CSS styling flag</dfn> associated
with it, which must initially be false.  (<span>The <code
title>styleWithCSS</code> command</span> can be used to modify or query it, by
means of the <code>execCommand()</code> and <code>queryCommandState()</code>
methods.)

<p>For some <span title=command>commands</span>, each [[htmldocument]] must
have a boolean <dfn>state override</dfn> and/or a string <dfn>value
override</dfn>.  These do not change the <span>command</span>'s
<span>state</span> or <span>value</span>, but change the way some algorithms
behave, as specified in those algorithms' definitions.  Initially, both must be
unset for every <span>command</span>.  Whenever the number of [[ranges]] in the
[[selection]] changes to something different, and whenever a [[boundarypoint]]
of the [[range]] at a given index in the [[selection]] changes to something
different, the <span>state override</span> and <span>value override</span> must
be unset for every <span>command</span>.

<p class=XXX>Figure out exactly what commands need to preserve state/value
overrides.

<p>When this specification refers to a method or attribute that is defined in a
specification, the user agent must treat the method or attribute as defined by
that specification.  In particular, if a script has overridden a standard
property with a custom one, the user agent must only use the overridden
property when a script refers to it, and must continue to use the
specification-defined behavior when this specification refers to it.

<p>When a list or set of [[nodes]] is assigned to a variable without specifying
the order, they must be initially in [[treeorder]], if they share a root.
(If they don't share a root, the order will be specified.)  When the user agent
is instructed to run particular steps for each member of a list, it must do so
sequentially in the list's order.
<!-- @} -->

<h2>Common algorithms</h2>

<h3>Assorted common algorithms</h3>
<!-- @{ -->
<p>To move a [[node]] to a new location, <dfn>preserving ranges</dfn>, remove
the [[node]] from its original [[parent]] (if any), then insert it in the new
location.  In doing so, however, ignore the regular [[rangemutationrules]], and
instead follow these rules:

<ol>
  <li>Let <var>node</var> be the moved [[node]], <var>old parent</var> and
  <var>old index</var> be the old [[parent]] (which may be null) and [[index]],
  and <var>new parent</var> and <var>new index</var> be the new [[parent]] and
  [[index]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is the same as or a [[descendant]] of
  <var>node</var>, leave it unchanged, so it moves to the new location.  <!--
  This is actually implicit, but I state it anyway for completeness. -->

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>new parent</var> and its
  [[bpoffset]] is greater than <var>new index</var>, add one to its
  [[bpoffset]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>old parent</var> and its
  [[bpoffset]] is <var>old index</var> or <var>old index</var> + 1, set its
  [[bpnode]] to <var>new parent</var> and add <var>new index</var> &minus;
  <var>old index</var> to its [[bpoffset]].

  <li>If a [[boundarypoint]]'s [[bpnode]] is <var>old parent</var> and its
  [[bpoffset]] is greater than <var>old index</var> + 1, subtract one from its
  [[bpoffset]].
</ol>

<p>To <dfn>set the tag name</dfn> of an [[element]] <var>element</var> to
<var>new name</var>:

<!-- TODO: Do we want to get rid of attributes that are no longer allowed here?
-->

<ol>
  <li>If <var>element</var> is an <span>HTML element</span> with [[localname]]
  equal to <var>new name</var>, return <var>element</var>.

  <li>If <var>element</var>'s [[parent]] is null, return <var>element</var>.

  <li>Let <var>replacement element</var> be the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement(<var>new name</var>)</code> on
  the [[ownerdocument]] of <var>element</var>.

  <li>Insert <var>replacement element</var> into <var>element</var>'s
  [[parent]] immediately before <var>element</var>.

  <li>Copy all attributes of <var>element</var> to <var>replacement
  element</var>, in order.

  <li>While <var>element</var> has [[children]], append the first [[child]] of
  <var>element</var> as the last [[child]] of <var>replacement element</var>,
  <span>preserving ranges</span>.

  <li>Remove <var>element</var> from its [[parent]].

  <li>Return <var>replacement element</var>.
</ol>

<p>To <dfn>remove extraneous line breaks before</dfn> a [[node]]
<var>node</var>:

<ol>
  <li>Let <var>ref</var> be the [[previoussibling]] of <var>node</var>.

  <li>If <var>ref</var> is null, abort these steps.

  <li>While <var>ref</var> has [[children]], set <var>ref</var> to its
  [[lastchild]].

  <li>While <var>ref</var> is <span>invisible</span> but not an
  <span>extraneous line break</span>, and <var>ref</var> does not equal
  <var>node</var>'s [[parent]], set <var>ref</var> to the [[node]] before it in
  [[treeorder]].

  <li>If <var>ref</var> is an <span>editable</span> <span>extraneous line
  break</span>, remove it from its [[parent]].
</ol>

<p>To <dfn>remove extraneous line breaks at the end of</dfn> a [[node]]
<var>node</var>:

<ol>
  <li>Let <var>ref</var> be <var>node</var>.

  <li>While <var>ref</var> has [[children]], set <var>ref</var> to its
  [[lastchild]].

  <li>While <var>ref</var> is <span>invisible</span> but not an
  <span>extraneous line break</span>, and <var>ref</var> does not equal
  <var>node</var>, set <var>ref</var> to the [[node]] before it in
  [[treeorder]].

  <li>If <var>ref</var> is an <span>editable</span> <span>extraneous line
  break</span>, remove it from its [[parent]].
</ol>

<p>To <dfn>remove extraneous line breaks from</dfn> a [[node]], first
<span>remove extraneous line breaks before</span> it, then <span>remove
extraneous line breaks at the end of</span> it.

<!-- @} -->
<h3>Wrapping a list of nodes</h3>
<!-- @{ -->
<p>To <dfn>wrap</dfn> a list <var>node list</var> of consecutive [[sibling]]
[[nodes]], given <dfn>sibling criteria</dfn> and <dfn>new parent
instructions</dfn>, run the following algorithm.  If not provided,
<span>sibling criteria</span> match nothing and <span>new parent
instructions</span> return null.

<ol>
  <li>If <var>node list</var> is empty, or the first member of <var>node
  list</var> is not <span>editable</span>, return null and abort these steps.

  <li>If <var>node list</var>'s last member is an <span>inline node</span>
  that's not a [[br]], and <var>node list</var>'s last member's [[nextsibling]]
  is a [[br]], append that [[br]] to <var>node list</var>.
  <!-- Trailing br's like this always need to go along with their line.
  Otherwise they'll create an extra line if we wrap in a block element, instead
  of vanishing as they should. -->

  <li>If the [[previoussibling]] of the first member of <var>node list</var>
  is <span>editable</span> and meets the <span>sibling criteria</span>, let
  <var>new parent</var> be the [[previoussibling]] of the first member of
  <var>node list</var>.

  <li>Otherwise, if the [[nextsibling]] of the last member of <var>node
  list</var> is <span>editable</span> and meets the <span>sibling
  criteria</span>, let <var>new parent</var> be the [[nextsibling]] of the last
  member of <var>node list</var>.

  <li>Otherwise, run the <span>new parent instructions</span>, and let <var>new
  parent</var> be the result.

  <li>If <var>new parent</var> is null, abort these steps and return null.
  <!-- This can only happen if the new parent instructions are run and they
  return null.  This can be used to only merge with adjacent siblings, in case
  you don't want to create a new parent if that fails. -->

  <li>If <var>new parent</var>'s [[parent]] is null:

  <ol>
    <li>Insert <var>new parent</var> into the [[parent]] of the first member of
    <var>node list</var> immediately before the first member of <var>node
    list</var>.

    <li>If any [[range]] has a [[boundarypoint]] with [[bpnode]] equal to the
    [[parent]] of <var>new parent</var> and [[bpoffset]] equal to the [[index]]
    of <var>new parent</var>, add one to that [[boundarypoint]]'s [[bpoffset]].
    <!--
    Basically, we want any boundary points around the wrapped nodes to go
    inside the wrapper.  Without this step, wrapping "{}<br>" in a blockquote
    would go like

      {}<br>
      -> {}<blockquote></blockquote><br>
      -> {}<blockquote><br></blockquote>.

    The second line is due to range mutation rules: a boundary point with an
    offset equal to the index of a newly-inserted node stays put, so it remains
    before it.  With this step, it goes like

      {}<br>
      -> {}<blockquote></blockquote><br>
      -> <blockquote></blockquote>{}<br>
      -> <blockquote>{}<br></blockquote>.

    The difference in the final step is because we move the <br> "preserving
    ranges".  This means that adjacent boundary points get swept along with it.
    Previously, the <blockquote> intervened, so a boundary point after it would
    get taken along but one before it would not.

    Another solution that one might be tempted to consider would be to just put
    the wrapper after the wrapped elements.  Then the boundary points would
    stay put, before the wrapper, so they'd still be adjacent to the nodes to
    be wrapped, like:

      {<p>foo</p>}
      -> {<p>foo</p>}<blockquote></blockquote>
      -> <blockquote>{<p>foo</p>}</blockquote>.

    The problem is that this completely breaks if you're wrapping multiple
    things and not all are selected.  It would go like this:

      <p>foo</p>{<p>bar</p>}
      -> <p>foo</p>{<p>bar</p>}<blockquote></blockquote>
      -> <p>foo</p><blockquote>{<p>bar</p>}</blockquote>
      -> <blockquote>{<p>foo</p><p>bar</p>}</blockquote>.

    The last step is again because of the range mutation rules: the boundary
    point stays put when a new node is inserted.  They're fundamentally
    asymmetric.

    An alternative solution would be to define the concept of moving a list of
    adjacent sibling nodes while preserving ranges, and handle this explicitly
    at a more abstract level.

    TODO: Think about this some more.  Maybe there's a better way.
    -->
  </ol>

  <li>Let <var>original parent</var> be the [[parent]] of the first member of
  <var>node list</var>.

  <li>If <var>new parent</var> is before the first member of <var>node
  list</var> in [[treeorder]]:

  <ol>
    <li>If <var>new parent</var> is not an <span>inline node</span>, but the
    last [[child]] of <var>new parent</var> and the first member of <var>node
    list</var> are both <span title="inline node">inline nodes</span>, and the
    last [[child]] of <var>new parent</var> is not a [[br]], call <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("br")</code> on the
    [[ownerdocument]] of <var>new parent</var> and append the result as the
    last [[child]] of <var>new parent</var>.

    <li>For each <var>node</var> in <var>node list</var>, append
    <var>node</var> as the last [[child]] of <var>new parent</var>,
    <span>preserving ranges</span>.
  </ol>

  <li>Otherwise:

  <ol>
    <li>If <var>new parent</var> is not an <span>inline node</span>, but the
    first [[child]] of <var>new parent</var> and the last member of <var>node
    list</var> are both <span title="inline node">inline nodes</span>, and the
    last member of <var>node list</var> is not a [[br]], call <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("br")</code> on the
    [[ownerdocument]] of <var>new parent</var> and insert the result as the
    first [[child]] of <var>new parent</var>.

    <li>For each <var>node</var> in <var>node list</var>, <em>in reverse
    order</em>, insert <var>node</var> as the first [[child]] of <var>new
    parent</var>, <span>preserving ranges</span>.
  </ol>

  <li>If <var>original parent</var> is <span>editable</span> and has no
  [[children]], remove it from its [[parent]].
  <!-- This could happen if the new parent instructions returned a node whose
  parent wasn't null. -->

  <li>If <var>new parent</var>'s [[nextsibling]] is <span>editable</span> and
  meets the <span>sibling criteria</span>:
  <!-- Probably because both the previous and next sibling met them.  We want
  to merge them in this case. -->

  <ol>
    <li>If <var>new parent</var> is not an <span>inline node</span>, but
    <var>new parent</var>'s last [[child]] and <var>new parent</var>'s
    [[nextsibling]]'s first [[child]] are both <span title="inline node">inline
    nodes</span>, and <var>new parent</var>'s last [[child]] is not a [[br]],
    call <code data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("br")</code> on the
    [[ownerdocument]] of <var>new parent</var> and append the result as the
    last [[child]] of <var>new parent</var>.

    <li>While <var>new parent</var>'s [[nextsibling]] has [[children]], append
    its first [[child]] as the last [[child]] of <var>new parent</var>,
    <span>preserving ranges</span>.

    <li>Remove <var>new parent</var>'s [[nextsibling]] from its [[parent]].
  </ol>

  <li><span>Remove extraneous line breaks from</span> <var>new parent</var>.

  <li>Return <var>new parent</var>.
</ol>

<!-- @} -->
<h3>Allowed children</h3>
<!-- @{ -->
<p>A <dfn>name of an element with inline contents</dfn> is "a", "abbr", "b",
"bdi", "bdo", "cite", "code", "dfn", "em", "h1", "h2", "h3", "h4", "h5", "h6",
"i", "kbd", "mark", "p", "pre", "q", "rp", "rt", "ruby", "s", "samp", "small",
"span", "strong", "sub", "sup", "u", "var", "acronym", "listing", "strike",
"xmp", "big", "blink", "font", "marquee", "nobr", or "tt".
<!--
At the time of this writing (July 2011), dt is only allowed to contain inline
contents by HTML.  I deliberately omit it from the list regardless, because I
don't like the fact that including it will cause various commands to break
apart lists rather than put bad things inside dt.  I filed a bug asking that
the spec be changed: http://www.w3.org/Bugs/Public/show_bug.cgi?id=13201
-->

<p>An <dfn>element with inline contents</dfn> is an <span>HTML element</span>
whose [[localname]] is a <span>name of an element with inline contents</span>.
<!-- List is mostly based on current HTML5, together with obsolete elements.  I
mostly got the obsolete element list by testing what Firefox 5.0a2 splits when
you do insertHorizontalRule. -->

<!--
TODO: The definitions of prohibited paragraph children and elements with inline
contents should be in the HTML spec (possibly under a different name) so they
don't fall out of sync.  They'll do for now.
-->

<p>A [[node]] or string <var>child</var> is an <dfn>allowed child</dfn> of a
[[node]] or string <var>parent</var> if the following algorithm returns true:
<!--
TODO: This list doesn't currently match HTML's validity requirements for a few
reasons:

1) We need to handle invalid elements, which have no conformance requirements
but should be treated properly.  In particular, they can interfere with
serialization (e.g., center cannot descend from p).

2) Sometimes users give instructions that have to produce invalid DOMs to get
the expected effect, like indenting the first item of a list.

3) The HTML validity requirements are sometimes quite complicated.

4) I just haven't had bothered to be systematic about it yet.  I've only
covered what's come up in my tests.
-->

<ol>
  <li>If <var>parent</var> is "colgroup", "table", "tbody", "tfoot", "thead",
  "tr", or an <span>HTML element</span> with [[localname]] equal to one of
  those, and <var>child</var> is a [[text]] node whose [[cddata]] does not
  consist solely of [[spacecharacters]], return false.

  <li>If <var>parent</var> is "script", "style", "plaintext", or "xmp", or an
  <span>HTML element</span> with [[localname]] equal to one of those, and
  <var>child</var> is not a [[text]] node, return false.
  <!-- Actually, no node can occur in the DOM after plaintext, generally.  But
  let's not get too carried away. -->

  <li>If <var>child</var> is a [[document]], [[documentfragment]], or
  [[documenttype]], return false.

  <li>If <var>child</var> is an <span>HTML element</span>, set <var>child</var>
  to the [[localname]] of <var>child</var>.

  <li>If <var>child</var> is not a string, return true.

  <li>If <var>parent</var> is an <span>HTML element</span>:

  <ol>
    <li>If <var>child</var> is "a", and <var>parent</var> or some [[ancestor]]
    of <var>parent</var> is an [[a]], return false.
    <!-- Cannot be serialized as text/html.  In some cases it can, like
    <a>foo<table><td><a>bar</a></td></table>baz</a>, but it's invalid in those
    cases too, so no need for complication. -->

    <li>If <var>child</var> is a <span>prohibited paragraph child name</span>
    and <var>parent</var> or some [[ancestor]] of <var>parent</var> is an
    <span>element with inline contents</span>, return false.
    <!-- This generally cannot be serialized either, for p.  For other elements
    with inline contents, this serves to prevent things like
    <span><p>foo</p></span>, which will parse fine but aren't supposed to
    happen anyway. -->

    <li>If <var>child</var> is "h1", "h2", "h3", "h4", "h5", or "h6", and
    <var>parent</var> or some [[ancestor]] of <var>parent</var> is an
    <span>HTML element</span> with [[localname]] "h1", "h2", "h3", "h4", "h5",
    or "h6", return false.
    <!-- Nor this. -->

    <li>Let <var>parent</var> be the [[localname]] of <var>parent</var>.
    <!-- Further requirements only care about the parent itself, not ancestors,
    so we don't need to know the node itself. -->
  </ol>

  <li>If <var>parent</var> is an [[element]] or [[documentfragment]], return
  true.

  <li>If <var>parent</var> is not a string, return false.

  <li>If <var>parent</var> is on the left-hand side of an entry on the
  following list, then return true if <var>child</var> is listed on the
  right-hand side of that entry, and false otherwise.
  <!-- We allow children even where some intervening nodes will be inserted,
  like tr as a child of table. -->

  <ul>
    <li>colgroup: col
    <li>table: caption, col, colgroup, tbody, td, tfoot, th, thead, tr
    <li>tbody, tfoot, thead: td, th, tr
    <li>tr: td, th
    <li>dl: dt, dd
    <li>dir, ol, ul: dir, li, ol, ul
    <li>hgroup: h1, h2, h3, h4, h5, h6
  </ul>

  <li>If <var>child</var> is "body", "caption", "col", "colgroup", "frame",
  "frameset", "head", "html", "tbody", "td", "tfoot", "th", "thead", or "tr",
  return false.

  <!-- dd/dt/li will serialize fine as the child of random stuff, but it makes
  no sense at all, so we want to avoid it anyway. -->
  <li>If <var>child</var> is "dd" or "dt" and <var>parent</var> is not "dl",
  return false.

  <li>If <var>child</var> is "li" and <var>parent</var> is not "ol" or "ul",
  return false.

  <li>If <var>parent</var> is on the left-hand side of an entry on the
  following list and <var>child</var> is listed on the right-hand side of that
  entry, return false.

  <ul>
    <li>a: a
    <li>dd, dt: dd, dt
    <li>h1, h2, h3, h4, h5, h6: h1, h2, h3, h4, h5, h6
    <li>li: li
    <li>nobr: nobr
    <li>All <span title="name of an element with inline contents">names of an
    element with inline contents</span>: all <span title="prohibited
    paragraph child name">prohibited paragraph child names</span>
    <li>td, th: caption, col, colgroup, tbody, td, tfoot, th, thead, tr
  </ul>

  <li>Return true.
</ol>
<!-- @} -->

<h2 id=inline-formatting-commands>Inline formatting commands</h2>

<h3>Inline formatting command definitions</h3>
<!-- @{ -->
<p>A [[node]] <var>node</var> is <dfn>effectively contained</dfn> in a
[[range]] <var>range</var> if at least one of the following holds:
<!--
The difference between "contained" and "effectively contained" is basically
that 1) in <b>[foo]</b>, the text node and the <b> are effectively contained
but not contained; and 2) in <b>f[o]o</b>, the text node is effectively
contained but not contained, and the <b> is neither effectively contained nor
contained.
-->
<ul>
  <li><var>node</var> is [[contained]] in <var>range</var>.

  <li><var>node</var> is <var>range</var>'s [[startnode]], it is a [[text]]
  node, its [[nodelength]] is different from <var>range</var>'s
  [[startoffset]], and <var>range</var> is not [[rangecollapsed]].
  <!-- So like <b>f[oo]</b> or <b>f[o]o</b> or <b>f[oo</b>}, but not
  <b>foo[</b>} or <b>f[]oo</b>. -->

  <li><var>node</var> is <var>range</var>'s [[endnode]], it is a [[text]] node,
  <var>range</var>'s [[endoffset]] is not 0, and <var>range</var> is not
  [[rangecollapsed]].

  <li><var>node</var> has at least one [[child]]; and all its [[children]] are
  <span>effectively contained</span> in <var>range</var>; and either
  <var>range</var>'s [[startnode]] is not a [[descendant]] of <var>node</var>
  or is not a [[text]] node or <var>range</var>'s [[startoffset]] is zero or
  <var>range</var> is [[rangecollapsed]]; and either <var>range</var>'s [[endnode]]
  is not a [[descendant]] of <var>node</var> or is not a [[text]] node or
  <var>range</var>'s [[endoffset]] is its [[endnode]]'s [[length]] or
  <var>range</var> is [[rangecollapsed]].
  <!--
  Basically, anything whose children are all effectively contained should be
  effectively contained itself, except that in a case like <b>f[o]o</b> we
  don't want <b> to be effectively contained even though the text node is.
  That's because we split the text node before we actually do anything, and the
  <b> will no longer be effectively contained.
  -->
</ul>

<p>A <dfn>modifiable element</dfn> is a [[b]], [[em]], [[i]], [[s]], [[span]],
[[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with no attributes
except possibly [[style]]; or a [[font]] element with no attributes except
possibly [[style]], [[fontcolor]], [[fontface]], and/or [[fontsize]]; or an
[[a]] element with no attributes except possibly [[style]] and/or [[href]].

<p>A <dfn>simple modifiable element</dfn> is an <span>HTML element</span> for
which at least one of the following holds:

<ul>
  <li>It is an [[a]], [[b]], [[em]], [[font]], [[i]], [[s]], [[span]],
  [[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with no
  attributes.

  <li>It is an [[a]], [[b]], [[em]], [[font]], [[i]], [[s]], [[span]],
  [[strike]], [[strong]], [[sub]], [[sup]], or [[u]] element with exactly one
  attribute, which is [[style]], which sets no CSS properties (including
  invalid or unrecognized properties).

  <li>It is an [[a]] element with exactly one attribute, which is [[href]].

  <li>It is a [[font]] element with exactly one attribute, which is either
  [[fontcolor]], [[fontface]], or [[fontsize]].

  <li>It is a [[b]] or [[strong]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "font-weight".

  <li>It is an [[i]] or [[em]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "font-style".

  <li>It is a [[sub]] or [[sup]] element with exactly one attribute, which is
  [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), which is "vertical-align".

  <li>It is an [[a]], [[font]], or [[span]] element with exactly one attribute,
  which is [[style]], and the [[style]] attribute sets exactly one CSS property
  (including invalid or unrecognized properties), and that property is not
  "text-decoration".

  <li>It is an [[a]], [[font]], [[s]], [[span]], [[strike]], or [[u]] element
  with exactly one attribute, which is [[style]], and the [[style]] attribute
  sets exactly one CSS property (including invalid or unrecognized properties),
  which is "text-decoration", which is set to "line-through" or "underline" or
  "overline" or "none".
</ul>

<p class=note>Conceptually, a simple modifiable element is a modifiable element
which specifies a value for at most one command.

<p>If a <span>command</span> has <dfn>inline command activated values</dfn>
defined but nothing else defines when it is <span>indeterminate</span>, it is
<span>indeterminate</span> if among <span>editable</span> [[text]] nodes
<span>effectively contained</span> in the <span>active range</span>, there is
at least one whose <span>effective command value</span> is one of the given
values and at least one whose <span>effective command value</span> is not one
of the given values.

<p>If a <span>command</span> has <span>inline command activated values</span>
defined, its <span>state</span> is true if either no <span>editable</span>
[[text]] node is <span>effectively contained</span> in the <span>active
range</span>, and the <span>active range</span>'s [[startnode]]'s
<span>effective command value</span> is one of the given values; or if there is
at least one <span>editable</span> [[text]] node <span>effectively
contained</span> in the <span>active range</span>, and all of them have an
<span>effective command value</span> equal to one of the given values.
<!--
For bold and similar commands, IE 9 RC seems to consider the state true or
false depending on the first element.  All other browsers follow the same
general idea as the spec, considering a range bold only if all text in it is
bold, and this seems to match at least OpenOffice.org's bold feature.  Opera
11.11 seemingly doesn't take CSS into account, and only looks at whether
something descends from a <b>.  I couldn't properly test IE9 because it threw
exceptions (Error: Unspecified error.) on most of the tests I ran.  But what I
have here seems to match Firefox 6.0a2 in every case, and Chrome 14 dev in all
cases with a few exceptions.
-->

<p>If a command is a <dfn>standard inline value command</dfn>, it is
<span>indeterminate</span> if among <span>editable</span> [[text]] nodes that
are <span>effectively contained</span> in the <span>active range</span>, there
are two that have distinct <span title="effective command value">effective
command values</span>.  Its <span>value</span> is the <span>effective command
value</span> of the first <span>editable</span> [[text]] node that is
<span>effectively contained</span> in the <span>active range</span>, or if
there is no such node, the <span>effective command value</span> of the
<span>active range</span>'s [[startnode]].

<p class=note>The effective command value of the active range's start node
cannot be null, since the boundary point node of a selection must always be
either an element or a text node that's the child of an element.
<!--
Testing with hiliteColor: Opera 11.11 seems to always return the effective
command value of the active range's start node.  Chrome 14 dev returns boolean
false consistently, bizarrely enough.  Firefox 6.0a2 seems to follow the same
idea as the spec, but it likes to return "transparent", including sometimes
when the answer really clearly should not be "transparent".  IE9 throws
exceptions most of the time for backColor, so I can't say for sure, but in the
few cases where it doesn't throw it returns a random-looking number, so I'll
assume it's crazy like for foreColor.

I decided on something that would guarantee the following invariant: whenever
you execute a command with a value provided (assuming value is relevant),
queryCommandValue() will always return something equivalent to what you set.
-->


<!-- @} -->
<h3>Assorted inline formatting command algorithms</h3>
<!-- @{ -->
<p>The <dfn>effective command value</dfn> of a [[node]] <var>node</var> for a
given <var>command</var> is returned by the following algorithm, which will
return either a string or null:

<ol>
  <li>If neither <var>node</var> nor its [[parent]] is an [[element]], return
  null.

  <li>If <var>node</var> is not an [[element]], return the <span>effective
  command value</span> of its [[parent]] for <var>command</var>.

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>While <var>node</var> is not null, and is not an [[a]] element that has
    an [[href]] attribute, set <var>node</var> to its [[parent]].

    <li>If <var>node</var> is null, return null.

    <li>Return the [[attrvalue]] of <var>node</var>'s [[href]] attribute.
  </ol>

  <li>If <var>command</var> is "backColor" or "hiliteColor":

  <ol>
    <li>While the [[resval]] of "background-color" on <var>node</var> is
    any fully transparent value, and <var>node</var>'s [[parent]] is an
    [[element]], set <var>node</var> to its [[parent]].

    <li>If the [[resval]] of "background-color" on <var>node</var> is
    a fully transparent value, return "rgb(255, 255, 255)".

    <li>Otherwise, return the [[resval]] of "background-color" for
    <var>node</var>.
  </ol>

  <li>If <var>command</var> is "subscript" or "superscript":

  <ol>
    <li>Let <var>affected by subscript</var> and <var>affected by
    superscript</var> be two boolean variables, both initially false.

    <li>While <var>node</var> is an <span>inline node</span>:

    <ol>
      <!-- Firefox 6.0a2 ignores vertical-align for this purpose, and only
      cares about <sub> and <sup> tags themselves.  Opera 11.11 is similar, and
      in fact behaves like that even for commands like bold.  The spec follows
      Chrome 14 dev, mainly because WebKit itself will produce spans with
      vertical-align sub or super, and we want to handle them correctly. -->
      <li>If <var>node</var>'s "vertical-align" property has [[resval]] "sub",
      set <var>affected by subscript</var> to true.

      <li>Otherwise, if <var>node</var>'s "vertical-align" property has
      [[resval]] "super", set <var>affected by superscript</var> to true.

      <li>Otherwise, if <var>node</var>'s "vertical-align" property has
      [[resval]] other than "baseline", return the string "other".

      <li>Set <var>node</var> to its [[parent]].
    </ol>

    <li>If <var>affected by subscript</var> and <var>affected by
    superscript</var> are both true, return the string "mixed".

    <li>If <var>affected by subscript</var> is true, return "sub".

    <li>If <var>affected by superscript</var> is true, return "super".

    <li>Return "baseline".
  </ol>

  <li>If <var>command</var> is "strikethrough", and the "text-decoration"
  property of <var>node</var> or any of its [[ancestors]] has [[resval]]
  containing "line-through", return "line-through".  Otherwise, return null.

  <li>If <var>command</var> is "underline", and the "text-decoration"
  property of <var>node</var> or any of its [[ancestors]] has [[resval]]
  containing "underline", return "underline".  Otherwise, return null.

  <li>Return the [[resval]] for <var>node</var> of the <span>relevant CSS
  property</span> for <var>command</var>.
</ol>

<p>The <dfn>specified command value</dfn> of an [[element]] <var>element</var>
for a given <var>command</var> is returned by the following algorithm, which
will return either a string or null:

<ol>
  <li>If <var>command</var> is "backColor" or "hiliteColor" and the
  [[element]]'s display property does not have [[resval]] "inline", return
  null.

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>If <var>element</var> is an [[a]] element and has an [[href]]
    attribute, return the [[attrvalue]] of that attribute.

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "subscript" or "superscript":

  <ol>
    <li>If <var>element</var> is not an <span>inline node</span>, return null.

    <li>If <var>element</var> has a [[style]] attribute set, and that attribute
    has the effect of setting "vertical-align", return the value that it sets
    "vertical-align" to.

    <li>If <var>element</var> is a [[sup]], return "super".

    <li>If <var>element</var> is a [[sub]], return "sub".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "strikethrough", and <var>element</var> has a
  [[style]] attribute set, and that attribute sets "text-decoration":

  <ol>
    <li>If <var>element</var>'s [[style]] attribute sets "text-decoration" to a
    value containing "line-through", return "line-through".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "strikethrough" and <var>element</var> is an
  [[s]] or [[strike]] element, return "line-through".

  <li>If <var>command</var> is "underline", and <var>element</var> has a
  [[style]] attribute set, and that attribute sets "text-decoration":

  <ol>
    <li>If <var>element</var>'s [[style]] attribute sets "text-decoration" to a
    value containing "underline", return "underline".

    <li>Return null.
  </ol>

  <li>If <var>command</var> is "underline" and <var>element</var> is a [[u]]
  element, return "underline".

  <li>Let <var>property</var> be the <span>relevant CSS property</span> for
  <var>command</var>.

  <li>If <var>property</var> is null, return null.

  <li>If <var>element</var> has a [[style]] attribute set, and that attribute has
  the effect of setting <var>property</var>, return the value that it sets
  <var>property</var> to.

  <li>If <var>element</var> is a [[font]] element that has an attribute whose
  effect is to create a [[presentationalhint]] for <var>property</var>, return
  the value that the hint sets <var>property</var> to.  (For a [[fontsize]] of
  7, this will be the non-CSS value "xxx-large".)

  <li>If <var>element</var> is in the following list, and <var>property</var> is
  equal to the CSS property name listed for it, return the string listed for
  it.

  <ul>
    <li>[[b]], [[strong]]: font-weight: "bold"

    <li>[[i]], [[em]]: font-style: "italic"
  </ul>

  <li>Return null.
</ol>

<p>To <dfn>reorder modifiable descendants</dfn> of a [[node]] <var>node</var>,
given a <span>command</span> <var>command</var> and a value <var>new
value</var>:

<ol>
  <li>Let <var>candidate</var> equal <var>node</var>.

  <li>While <var>candidate</var> is a <span>modifiable element</span>, and
  <var>candidate</var> has exactly one [[child]], and that [[child]] is also a
  <span>modifiable element</span>, and <var>candidate</var> is not a
  <span>simple modifiable element</span> or <var>candidate</var>'s
  <span>specified command value</span> for <var>command</var> is not <var>new
  value</var>, set <var>candidate</var> to its [[child]].

  <li>If <var>candidate</var> is <var>node</var>, or is not a <span>simple
  modifiable element</span>, or its <span>specified command value</span> and
  <span>effective command value</span> for <var>command</var> are not both
  <var>new value</var>, abort these steps.

  <li>While <var>candidate</var> has [[children]], insert the first [[child]]
  of <var>candidate</var> into <var>candidate</var>'s [[parent]] immediately
  before <var>candidate</var>, <span>preserving ranges</span>.

  <li>Insert <var>candidate</var> into <var>node</var>'s [[parent]] immediately
  after <var>node</var>.
  <!--
  If candidate had no children, any boundary point inside it will get moved to
  its parent here, which is okay.  We don't want to preserve ranges, because
  that would move boundary points that originally were in candidate but were
  moved to its parent by the last step to move to node's parent.

  We move to after node so that boundary points before and after node wind up
  consistently inside candidate when we move preserving ranges.  If we had
    {<node>foo<candidate></candidate></node>}
  it thus becomes
    {<node>foo</node>}<candidate></candidate>
  by the range mutation rules, and then when we move preserving ranges, it
  becomes
    <candidate>{<node>foo</node>}</candidate>
  which is reasonable.

  If we had inserted candidate before node, instead it would go
    {<candidate></candidate><node>foo</node>}
    {<candidate><node>foo</node>}</candidate>
  because of the interaction of regular range mutation rules with
  preserving-ranges rules.
  -->

  <li>Append the <var>node</var> as the last [[child]] of <var>candidate</var>,
  <span>preserving ranges</span>.
</ol>

<p>To <dfn>record the values</dfn> of a list of [[nodes]] <var>node list</var>:

<ol>
  <li>Let <var>values</var> be a list of ([[node]], <span>command</span>,
  <span>specified command value</span>) triples, initially empty.

  <li>For each <var>node</var> in <var>node list</var>, for each
  <var>command</var> in the list "subscript", "bold", "fontName", "fontSize",
  "foreColor", "hiliteColor", "italic", "strikethrough", and "underline" in
  that order:
  <!-- As with removeFormat, we put subscript first so it doesn't interfere
  with fontSize, and omit superscript because it's redundant with subscript.
  -->

  <ol>
    <li>Let <var>ancestor</var> equal <var>node</var>.

    <li>If <var>ancestor</var> is not an [[element]], set it to its [[parent]].

    <li>While <var>ancestor</var> is an [[element]] and its <span>specified
    command value</span> for <var>command</var> is null, set it to its
    [[parent]].

    <li>If <var>ancestor</var> is an [[element]], add (<var>node</var>,
    <var>command</var>, <var>ancestor</var>'s <span>specified command
    value</span> for <var>command</var>) to <var>values</var>.  Otherwise add
    (<var>node</var>, <var>command</var>, null) to <var>values</var>.  </ol>

  <li>Return <var>values</var>.
</ol>

<p>To <dfn>restore the values</dfn> specified by a list <var>values</var>
returned by the <span>record the values</span> algorithm:

<ol>
  <li>For each (<var>node</var>, <var>command</var>, <var>value</var>) triple
  in <var>values</var>:

  <ol>
    <li>Let <var>ancestor</var> equal <var>node</var>.

    <li>If <var>ancestor</var> is not an [[element]], set it to its [[parent]].

    <li>While <var>ancestor</var> is an [[element]] and its <span>specified
    command value</span> for <var>command</var> is null, set it to its
    [[parent]].

    <li>If <var>value</var> is null and <var>ancestor</var> is an [[element]],
    <span>push down values</span> on <var>node</var> for <var>command</var>,
    with <var>new value</var> null.

    <li>Otherwise, if <var>ancestor</var> is an [[element]] and its
    <span>specified command value</span> for <var>command</var> is different
    from <var>value</var>, or if <var>ancestor</var> is not an [[element]] and
    <var>value</var> is not null, <span>force the value</span> of
    <var>command</var> to <var>value</var> on <var>node</var>.
  </ol>
</ol>


<!-- @} -->
<h3>Clearing an element's value</h3>
<!-- @{ -->
<p>To <dfn>clear the value</dfn> of an [[element]] <var>element</var>:

<p class=note>Clearing the value of an element can remove it from its parent
and put other nodes in its place.  When implementations do something like clear
the value of all children of an element, they should take care not to assume
that the set of children won't change as they're cleared.  If the element is
removed, the algorithm will return the list of nodes inserted in its place.

<!-- If we wanted to be extra-pedantic, we could convert, e.g., <font color=red
id=foo> into <span id=foo> instead of <font id=foo>, but probably not worth it.
-->

<ol>
  <li>Let <var>command</var> be the current <span>command</span>.

  <li>If <var>element</var> is not <span>editable</span>, return the empty
  list.

  <li>If <var>element</var>'s <span>specified command value</span> for
  <var>command</var> is null, return the empty list.  <!-- We want to abort
  early so that we don't try unsetting background-color on a non-inline
  element. -->

  <li>If <var>element</var> is a <span>simple modifiable element</span>:

  <ol>
    <li>Let <var>children</var> be the [[children]] of <var>element</var>.

    <li>For each <var>child</var> in <var>children</var>, insert
    <var>child</var> into <var>element</var>'s [[parent]] immediately before
    <var>element</var>, <span>preserving ranges</span>.

    <li>Remove <var>element</var> from its [[parent]].

    <li>Return <var>children</var>.
  </ol>

  <li>If <var>command</var> is "strikethrough", and <var>element</var> has a
  [[style]] attribute that sets "text-decoration" to some value containing
  "line-through", delete "line-through" from the value.

  <li>If <var>command</var> is "underline", and <var>element</var> has a
  [[style]] attribute that sets "text-decoration" to some value containing
  "underline", delete "underline" from the value.

  <li>If the <span>relevant CSS property</span> for <var>command</var> is not
  null, unset that property of <var>element</var>.

  <li>If <var>element</var> is a [[font]] element:

  <ol>
    <li>If <var>command</var> is "foreColor", unset <var>element</var>'s
    [[fontcolor]] attribute, if set.

    <li>If <var>command</var> is "fontName", unset <var>element</var>'s
    [[fontface]] attribute, if set.

    <li>If <var>command</var> is "fontSize", unset <var>element</var>'s
    [[fontsize]] attribute, if set.
  </ol>

  <li>If <var>element</var> is an [[a]] element and <var>command</var> is
  "createLink" or "unlink", unset the [[href]] property of <var>element</var>.

  <li>If <var>element</var>'s <span>specified command value</span> for
  <var>command</var> is null, return the empty list.
  <!-- If we get past this step, we're something like <b class=foo> where we
  want to keep the extra attributes, so we stick them on a span. -->

  <li><span>Set the tag name</span> of <var>element</var> to "span", and return
  the one-[[node]] list consisting of the result.
</ol>

<!-- @} -->
<h3>Pushing down values</h3>
<!-- @{ -->
<p>To <dfn>push down values</dfn> to a [[node]] <var>node</var>, given a new
value <var>new value</var>:

<!--
This algorithm goes up to just below the nearest ancestor with the right
style, then re-applies the bad styles repeatedly going down, omitting the
things we want to have the new style.  This is basically what WebKit does,
although WebKit sometimes starts higher up and therefore makes more intrusive
changes, often creating more markup.  IE follows the same general approach too.

Gecko instead seems to start breaking up elements from the bottom, so that the
range consists of a few consecutive siblings, and it can then break up the
problematic element into a maximum of two pieces.  The spec's approach seems to
create fewer elements and simpler markup (or at least markup that's no more
complex) in most cases I throw at it.

Gecko's approach does have the major advantage that it gets underlines right in
many cases for free.  E.g.,

  <u>foo<font color=red>[bar]baz</font></u>
  -> <u>foo</u><font color=red>bar<u>baz</u></font> (spec)
  -> <u>foo</u><font color=red>bar</font><u><font color=red>baz</font></u> (Gecko)

The spec's markup here is much shorter and contains fewer elements, but is
wrong: the underline under "baz" has changed color from black to red.  It might
be worth trying to copy Gecko's results in such cases, but that won't solve all
underline problems, so perhaps it's not worth it.

Opera also seems to break up the markup surrounding the range, but even more
aggressively: even if it doesn't need to pull down styles.  In some cases this
does actually result in shorter markup, specifically if the existing tags are
short (like [[i]] or [[b]]) and we're adding tags that are long (like [[span]]
with a [[style]] attribute).
-->

<ol>
  <li>Let <var>command</var> be the current <span>command</span>.

  <li>If <var>node</var>'s [[parent]] is not an [[element]], abort this
  algorithm. <!-- E.g., a text node child of a document fragment. -->

  <li>If the <span>effective command value</span> of <var>command</var> is
  <var>new value</var> on <var>node</var>, abort this algorithm.

  <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

  <li>Let <var>ancestor list</var> be a list of [[nodes]], initially empty.

  <li>While <var>current ancestor</var> is an <span>editable</span> [[element]]
  and the <span>effective command value</span> of <var>command</var> is not
  <var>new value</var> on it, append <var>current ancestor</var> to
  <var>ancestor list</var>, then set <var>current ancestor</var> to its
  [[parent]].

  <li>If <var>ancestor list</var> is empty, abort this algorithm.

  <li>Let <var>propagated value</var> be the <span>specified command
  value</span> of <var>command</var> on the last member of <var>ancestor
  list</var>.

  <!-- We can only remove specified values, so if the value isn't specified,
  give up.  Unless we're actually trying to push down a null specified value,
  like for unlink. -->
  <li>If <var>propagated value</var> is null and is not equal to <var>new
  value</var>, abort this algorithm.

  <!--
  If we go all the way up to the root and still don't have the desired value,
  pushing down values is pointless.  It will create extra markup for no
  purpose.  Except if the value is null, which basically just means "try to get
  rid of anything affecting the current element but don't aim for any specific
  value".

  Nevertheless, Chrome 14 dev does seem to do this.  Running bold on <span
  style=font-weight:300>f[o]o</span> breaks up the span and adds a <b> as a
  sibling.  In IE9, Firefox 6.0a2, and Opera 11.50, it instead nests the <b>
  inside the <span>.  It's a tradeoff: WebKit's behavior is better for things
  like

    <font color=red>fo[o</font><font color=blue>b]ar</font>
    -> <font color=red>fo</font><font color=green>[ob]</font><font color=blue>ar</font>

  (where the spec adds two extra font tags instead of one), but the spec is
  simpler for things like

    <font color=red>f[o]o</font>
    -> <font color=red>f<font color=green>[o]</font>o</font>

  (where WebKit splits the existing tag up in addition to creating a new tag).
  I'm not particularly sure which approach is better overall, so I'll go with
  the majority of browsers.  If these algorithms move to use runs of
  consecutive siblings instead of doing everything node-by-node, it might make
  sense to break up the parent as long as it won't create an extra node (i.e.,
  we're styling something that includes the first or last child).
  -->
  <li>If the <span>effective command value</span> of <var>command</var> is not
  <var>new value</var> on the [[parent]] of the last member of <var>ancestor
  list</var>, and <var>new value</var> is not null, abort this algorithm.

  <li>While <var>ancestor list</var> is not empty:

  <ol>
    <li>Let <var>current ancestor</var> be the last member of <var>ancestor
    list</var>.

    <li>Remove the last member from <var>ancestor list</var>.

    <li>If the <span>specified command value</span> of <var>current
    ancestor</var> for <var>command</var> is not null, set <var>propagated
    value</var> to that value.

    <li>Let <var>children</var> be the [[children]] of <var>current
    ancestor</var>.

    <li>If the <span>specified command value</span> of <var>current
    ancestor</var> for <var>command</var> is not null, <span>clear the
    value</span> of <var>current ancestor</var>.

    <li>For every <var>child</var> in <var>children</var>:

    <ol>
      <li>If <var>child</var> is <var>node</var>, continue with the next
      <var>child</var>.

      <li>If <var>child</var> is an [[element]] whose <span>specified command
      value</span> for <var>command</var> is neither null nor equal to
      <var>propagated value</var>, continue with the next <var>child</var>.
      <!--
      TODO: This will be incorrect for relative font sizes.  If the font size
      on the parent was removed and the font size on the child is in ems or
      percents or something, it will now change value.  This isn't likely to
      come up, so we'll ignore it for now.
      -->

      <li>If <var>child</var> is the last member of <var>ancestor list</var>,
      continue with the next <var>child</var>.

      <li><span>Force the value</span> of <var>child</var>, with
      <var>command</var> as in this algorithm and <var>new value</var> equal
      to <var>propagated value</var>.
    </ol>
  </ol>
</ol>

<!-- @} -->
<h3>Forcing the value of a node</h3>
<!-- @{ -->
<p>To <dfn>force the value</dfn> of a [[node]] <var>node</var> to <var>new
value</var>:

<p class=note>This algorithm checks if the node has the desired value, and if
not, it wraps the node (or, if that's not possible, its descendants) in a
<span>simple modifiable element</span>.  This is only used as a last resort
after <span title="clear the value">clearing the value</span> and <span
title="push down values">pushing down values</span> don't work to achieve the
desired value.  After forcing the value, descendants might still have a
different value.

<ol>
  <li>Let <var>command</var> be the current <span>command</span>.

  <li>If <var>node</var>'s [[parent]] is null, abort this algorithm.

  <li>If <var>new value</var> is null, abort this algorithm.

  <li>If <var>node</var> is an <span>allowed child</span> of "span":

  <ol>
    <!-- Even if the value matches, we stick it in a preceding sibling if
    possible.  This ensures "a<cite>b</cite>c" -> "<i>a<cite>b</cite>c</i>"
    instead of "<i>a</i><cite>b</cite><i>c</i>".  While we're at it, we also
    handle more elaborate cases like <b>foo</b>[bar]<b>baz</b> and even
    <i><b>foo</b></i>[bar]<i><b>baz</b></i> (the latter becomes
    <b><i>foo</i>bar<i>baz</i></b>).

    Theoretically this algorithm could pointlessly reorganize the DOM in the
    event of unreasonable style rules, but it's not a big enough deal for us to
    care, since the resulting style will still be right. -->
    <li><span>Reorder modifiable descendants</span> of <var>node</var>'s
    [[previoussibling]].

    <li><span>Reorder modifiable descendants</span> of <var>node</var>'s
    [[nextsibling]].

    <li><span>Wrap</span> the one-[[node]] list consisting of <var>node</var>,
    with <span>sibling criteria</span> matching a <span>simple modifiable
    element</span> whose <span>specified command value</span> and
    <span>effective command value</span> for <var>command</var> are both
    <var>new value</var>, and with <span>new parent instructions</span>
    returning null.
    <!-- The new parent instructions are too complicated to reasonably feed
    into the wrap algorithm. -->
  </ol>

  <li>If the <span>effective command value</span> of <var>command</var> is
  <var>new value</var> on <var>node</var>, abort this algorithm.

  <li>If <var>node</var> is not an <span>allowed child</span> of "span":

  <ol>
    <li>Let <var>children</var> be all [[children]] of <var>node</var>,
    omitting any that are [[element]]s whose <span>specified command
    value</span> for <var>command</var> is neither null nor equal to <var>new
    value</var>.

    <li><span>Force the value</span> of each [[node]] in <var>children</var>,
    with <var>command</var> and <var>new value</var> as in this invocation of
    the algorithm.
    <!-- This means that if it has no children, we do nothing.  IE9 inserts an
    empty wrapper element in that case, but I'm not sure what the point is, and
    no one else does, so I don't.  WebKit seems to ignore the node if its only
    child consists solely of whitespace, but I don't see any grounds for that
    and no one else does, so I don't. -->

    <li>Abort this algorithm.
  </ol>

  <li>If the <span>effective command value</span> of <var>command</var> is
  <var>new value</var> on <var>node</var>, abort this algorithm.

  <li>Let <var>new parent</var> be null.

  <li>If the <span>CSS styling flag</span> is false:

  <ol>
    <li>If <var>command</var> is "bold" and <var>new value</var> is
    "bold", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("b")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "italic" and <var>new value</var> is
    "italic", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("i")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "strikethrough" and <var>new value</var> is
    "line-through", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("s")</code> on the
    [[ownerdocument]] of <var>node</var>.
    <!--
    TODO: Actual UAs use strike, not s, but s is shorter and HTML5 makes strike
    invalid.  I've gone with s for now, but maybe we want to change the spec to
    require strike.
    -->

    <li>If <var>command</var> is "underline" and <var>new value</var> is
    "underline", let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("u")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>If <var>command</var> is "foreColor", and <var>new value</var> is fully
    opaque with red, green, and blue components in the range 0 to 255:
    <!-- See comment for foreColor for discussion. -->

    <!-- TODO: Define more carefully what happens when things are out of range
    or not integers or whatever. -->

    <ol>
      <li>Let <var>new parent</var> be the result of calling <code
      data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("font")</code> on the
      [[ownerdocument]] of <var>node</var>.

      <li>If <var>new value</var> is an <a
      href=http://www.w3.org/TR/css3-color/#svg-color>extended color
      keyword</a>, set the [[fontcolor]] attribute of <var>new parent</var> to
      <var>new value</var>.

      <li>Otherwise, set the [[fontcolor]] attribute of <var>new parent</var>
      to the result of applying the <span data-anolis-spec=html>rules for
      serializing simple color values</span> to <var>new value</var>
      (interpreted as a <span data-anolis-spec=html>simple color</span>).
    </ol>

    <li>If <var>command</var> is "fontName", let <var>new parent</var> be
    the result of calling <code data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("font")</code> on the
    [[ownerdocument]] of <var>node</var>, then set the [[fontface]] attribute
    of <var>new parent</var> to <var>new value</var>.
  </ol>

  <li>If <var>command</var> is "createLink" or "unlink":

  <ol>
    <li>Let <var>new parent</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement("a")</code> on the
    [[ownerdocument]] of <var>node</var>.

    <li>Set the [[href]] attribute of <var>new parent</var> to <var>new
    value</var>.

    <!-- Nested a elements are bad, because they can't be serialized to
    text/html.  hrefs should already have been cleared in a previous step, but
    we might have <a name> or such lurking about. -->
    <li>Let <var>ancestor</var> be <var>node</var>'s [[parent]].

    <li>While <var>ancestor</var> is not null:

    <ol>
      <li>If <var>ancestor</var> is an [[a]], <span>set the tag name</span> of
      <var>ancestor</var> to "span", and let <var>ancestor</var> be the
      result.

      <!--
      TODO: This will mean any link-specific attributes will be transferred,
      which makes them both invalid and useless.  Is that okay?  I don't really
      want to list them all, because that sort of list is prone to bitrot.
      -->

      <li>Set <var>ancestor</var> to its [[parent]].
    </ol>
  </ol>

  <!-- WebKit is the only engine that ever outputs anything but font tags for
  fontSize.  For size=7, it uses font-size: -webkit-xxx-large.  We just output
  a font tag no matter what. -->
  <li>If <var>command</var> is "fontSize"; and <var>new value</var> is one of
  "xx-small", "small", "medium", "large", "x-large", "xx-large", or
  "xxx-large"; and either the <span>CSS styling flag</span> is false, or
  <var>new value</var> is "xxx-large": let <var>new parent</var> be the result
  of calling <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("font")</code> on the
  [[ownerdocument]] of <var>node</var>, then set the [[fontsize]] attribute of
  <var>new parent</var> to the number from the following table based on
  <var>new value</var>:

  <ul>
    <li>xx-small: 1
    <li>small: 2
    <li>normal: 3
    <li>large: 4
    <li>x-large: 5
    <li>xx-large: 6
    <li>xxx-large: 7
  </ul>

  <!-- We always use sup/sub elements, even in CSS mode, following Gecko and
  contradicting WebKit.  This is because <span value="vertical-align:
  sub/super">, the obvious equivalent (and what WebKit uses), behaves quite
  differently: it doesn't reduce font-size, which is ugly. -->
  <li>If <var>command</var> is "subscript" or "superscript" and <var>new
  value</var> is "sub", let <var>new parent</var> be the result of calling
  <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("sub")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>If <var>command</var> is "subscript" or "superscript" and <var>new
  value</var> is "super", let <var>new parent</var> be the result of calling
  <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("sup")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>If <var>new parent</var> is null, let <var>new parent</var> be the result
  of calling <code data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("span")</code> on the
  [[ownerdocument]] of <var>node</var>.

  <li>Insert <var>new parent</var> in <var>node</var>'s [[parent]] before
  <var>node</var>.  <!-- This preserves boundary points correctly, as usual.
  -->

  <li>If the <span>effective command value</span> of <var>command</var> for
  <var>new parent</var> is not <var>new value</var>, and the <span>relevant CSS
  property</span> for <var>command</var> is not null, set that CSS property of
  <var>new parent</var> to <var>new value</var> (if the new value would be
  valid).

  <li>If <var>command</var> is "strikethrough", and <var>new value</var> is
  "line-through", and the <span>effective command value</span> of
  "strikethrough" for <var>new parent</var> is not "line-through", set the
  "text-decoration" property of <var>new parent</var> to "line-through".

  <li>If <var>command</var> is "underline", and <var>new value</var> is
  "underline", and the <span>effective command value</span> of "underline" for
  <var>new parent</var> is not "underline", set the "text-decoration" property
  of <var>new parent</var> to "underline".

  <li>Append <var>node</var> to <var>new parent</var> as its last [[child]],
  <span>preserving ranges</span>.

  <li>If <var>node</var> is an [[element]] and the <span>effective command
  value</span> of <var>command</var> for <var>node</var> is not <var>new
  value</var>:

  <ol>
    <li>Insert <var>node</var> into the [[parent]] of <var>new parent</var>
    before <var>new parent</var>, <span>preserving ranges</span>.

    <li>Remove <var>new parent</var> from its [[parent]].

    <li>Let <var>children</var> be all [[children]] of <var>node</var>,
    omitting any that are [[element]]s whose <span>specified command
    value</span> for <var>command</var> is neither null nor equal to <var>new
    value</var>.

    <li><span>Force the value</span> of each [[node]] in <var>children</var>,
    with <var>command</var> and <var>new value</var> as in this invocation of
    the algorithm.
  </ol>
</ol>

<!-- @} -->
<h3>Setting the selection's value</h3>
<!-- @{ -->
<p>To <dfn>set the selection's value</dfn> to <var>new value</var>:

<div class=note>
<p>The effect of this algorithm is to ensure that all nodes effectively
contained in the selection have the style requested, no matter what, producing
the simplest markup possible to achieve that effect.  It's inspired by the
approach WebKit takes.  The only places where the algorithm should fail are
when there's an !important CSS rule that conflicts with the requested style
(which we don't try to override because we assume it's !important for a
reason), or when it's literally impossible to succeed (such as when a
text-decoration is propagated from an ancestor we can't reach).  Any other
failures are bugs.

<p>First, if a node is an element with an inline style rule for this
property, we unset it ("clearing styles").  This step also removes <span
title="simple modifiable element">simple modifiable elements</span> entirely, and
replaces elements like [[b]] or [[font]] with [[span]]s if they aren't simple
styling elements.  This will be sufficient if the desired style is inherited
from an ancestor, or if it's the default (like font-style: normal) and no
conflicting style is inherited from an ancestor.  Even if clearing styles
doesn't actually fix the style of the node we're dealing with, we do it anyway
to simplify the generated markup.

<p>If clearing styles didn't work, and it looks like an ancestor has inline
style that we're inheriting, we push the style down from that ancestor.  Thus
if we're unbolding the letter "r" in

<xmp><b>foo <i>bar</i> baz</b>,</xmp>

<p>we get

<xmp><b>foo </b><i><b>ba</b>r</i><b> baz</b>.</xmp>

<p>If we didn't push down styles, the final step (forcing styles) would instead
give us

<xmp><b>foo <i>ba<span style="font-weight: normal">r</span></i> baz</b>,</xmp>

<p>which is much longer and uglier.  We take care not to disturb the style or
semantics of anything but the node we're dealing with.

<p>We'll only push down styles if some ancestor actually has the style we want,
so we can inherit it.  Otherwise, it will just create useless markup.

<p>Finally, if neither of the above strategies worked, we have to add new
markup to get the desired style ("forcing styles").  First we try just sticking
it into its previous or next sibling, if that's a <span>simple modifiable
element</span> (so it won't add any styles or semantics we don't want).
Otherwise, we create a new simple styling element and wrap it in that.  It's
common that a previous sibling is the simple styling element we want, because
often we'll style several consecutive siblings in succession.  In that case,
the element created for the first can be reused for the later ones.

<p>This last step works a bit differently if the node isn't an <span>allowed
child</span> of "span".  In that case, wrapping it in a simple styling element
would make the document less conforming than it already was.  Instead, we
recursively force style on its children.  The recursion will terminate when we
hit a node that's wrappable, or when there are no further descendants.

<p>After all this, the node is guaranteed to have the style we want, barring
bugs in the algorithm or the two exceptions noted earlier (!important style
rules, and impossible cases).  We then re-run the algorithm on each child
recursively.  Typically this means just clearing the style of each descendant,
because it should then inherit the style we just set on its ancestor.  In the
unusual case that a descendant's style is wrong even after we clear style on
it, such as because of a non-inline style rule (like trying to unbold a
heading), we'll repeat the above steps to ensure that the style really gets set
as desired.
</div>

<ol>
  <li>Let <var>command</var> be the current <span>command</span>.

  <li>If there is no <span>editable</span> [[text]] node <span>effectively
  contained</span> in the <span>active range</span>:
  <!-- IE9 seems to wrap the whole line instead, or something like that,
  although it does nothing for createLink.  We follow all other browsers'
  general behavior: change the state/value, and then make sure that takes
  effect if the user types something before changing the cursor position. -->

  <ol>
    <li>If <var>command</var> has <span>inline command activated values</span>,
    set the <span>state override</span> to true if <var>new value</var> is
    among them and false if it's not.

    <li>If <var>command</var> is "subscript", unset the <span>state
    override</span> for "superscript".

    <li>If <var>command</var> is "superscript", unset the <span>state
    override</span> for "subscript".

    <li>If <var>new value</var> is null, unset the <span>value override</span>
    (if any).

    <li>Otherwise, if <var>command</var> is "fontSize", set the <span>value
    override</span> to the <span>legacy font size for</span> the result of
    converting <var>new value</var> to pixels.

    <li>Otherwise, if <var>command</var> has a <span>value</span> specified,
    set the <span>value override</span> to <var>new value</var>.

    <li>Abort these steps.
  </ol>

  <li>If the <span>active range</span>'s [[startnode]] is an
  <span>editable</span> [[text]] node, and its [[startoffset]] is neither zero
  nor its [[startnode]]'s [[length]], call [[splittext|]] on the <span>active
  range</span>'s [[startnode]], with argument equal to the <span>active
  range</span>'s [[startoffset]].  Then set the <span>active range</span>'s
  [[startnode]] to the result, and its [[startoffset]] to zero.
  <!-- This last sentence just prettifies the resulting range a bit. -->

  <li>If the <span>active range</span>'s [[endnode]] is an
  <span>editable</span> [[text]] node, and its [[endoffset]] is neither zero
  nor its [[endnode]]'s [[length]], call [[splittext|]] on the <span>active
  range</span>'s [[endnode]], with argument equal to the <span>active
  range</span>'s [[endoffset]].

  <li>Let <var>element list</var> be all <span>editable</span> [[element]]s
  <span>effectively contained</span> in the <span>active range</span>.

  <li>For each <var>element</var> in <var>element list</var>, <span>clear the
  value</span> of <var>element</var>.

  <li>Let <var>node list</var> be all <span>editable</span> [[nodes]]
  <span>effectively contained</span> in the <span>active range</span>.
  <!--
  We skip non-editable nodes.

  IE9: Allows everything to be modified by execCommand(), regardless of whether
    it's editable.
  Firefox 4.0: Ignores execCommand() if the start and end of the selection are
    not both editable.  If the start and end are editable but something in the
    middle is not, seems to relocate the non-editable part in the middle or
    something like that.
  Chrome 12 dev: Ignores execCommand() if the start and end of the selection
    are not both editable.  If the start and end are editable but something in
    the middle is not, applies the given command but skips the non-editable
    parts.  But the state doesn't ignore the non-editable parts, so if you bold
    such a selection you can't unbold it, for instance, since the middle part
    will remain bold (so it will keep on trying to bold it instead of switching
    to unbold).
  Opera 11.00: Ignores execCommand() if the start and end of the selection are
    not both editable.  If the start and end are editable but something in the
    middle is not, applies the command to everything, even the non-editable
    part.

  I chose to go with the non-IE behavior, per this discussion:
  http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-April/031147.html
  Ignoring non-editable things is convenient for the common use-case of an
  editor, where you don't want the user to bold random parts of the UI when
  they hit the bold button.  For cases where it's not desired, you can always
  turn designMode on briefly before using execCommand(), so the non-IE behavior
  is a lot easier to work around than the IE behavior.

  I don't see the value in ever just ignoring execCommand().  If the start and
  end are not editable, I'm going to say you should still style any editable
  nodes in between.  I'm also going to ignore non-editable nodes for the
  purposes of determining state, so (for instance) if all the editable nodes
  are bolded, it will unbold instead of bolding.
  -->

  <li>For each <var>node</var> in <var>node list</var>:

  <!--
  TODO: This is inefficient.  It would be most efficient to only push down
  values on the highest-level effectively contained nodes, and to batch
  operations so we handle runs of adjacent siblings at once.  Should we bother
  fixing this?
  -->

  <ol>
    <li><span>Push down values</span> on <var>node</var>.

    <li><span>Force the value</span> of <var>node</var>.
  </ol>
</ol>

<!-- @} -->
<h3><dfn>The <code title>backColor</code> command</dfn></h3>
<!-- @{ -->
<!--
We have three behaviors to choose from for this one:

1) Chrome 11 dev and IE 9 RC treat it the same as hiliteColor (although IE 9 RC
doesn't support hiliteColor itself).

2) Firefox 4 in non-CSS mode sets the bgcolor of the nearest td or body, or
something like that.  In testing, it seems to jump out of contenteditable
elements to style non-editable ancestors, which is alarming.

3) Firefox 4 in CSS mode and Opera 11 set the background of the nearest block
container, although it doesn't seem to be very dependable (probably I just
don't get what exactlyit's doing).

(1) is obviously redundant, but has plurality support, so we could spec it that
way if the other ways were useless.

(3) is incoherent from a user perspective.  For instance, if you try it on
paragraphs the background will have big gaps where the margins are.  If you try
it on an inline element that's a child of the editing host, it will do nothing
or apply the background to everything or such, even though such an inline
element is visually indistinguishable from one sitting inside a div.  This
would only make sense if we take considerable effort to ensure that block
elements all have no margins, or if we wrap things in a div if they have
margins, or something like that.

That leaves (2).  That might be useful if it actually set the document's
background color, but it seems like it sets table cell backgrounds sometimes
instead, which is really confusing.

The path of least resistance is to standardize this as meaning the same thing
as hiliteColor, and make up new commands if we want to do things like set the
document background color.  See hiliteColor for comments.
-->
<p class=note>For historical reasons, backColor and hiliteColor behave
identically.

<p><span>Action</span>:

<ol>
  <li>If <var>value</var> is not a valid CSS color, prepend "#" to it.

  <li>If <var>value</var> is still not a valid CSS color, or if it is
  currentColor, abort these steps and do nothing.

  <li><span>Set the selection's value</span> to <var>value</var>.
</ol>

<p><span>Standard inline value command</span>

<p><span>Relevant CSS property</span>: "background-color"

<!-- @} -->
<h3><dfn>The <code title>bold</code> command</dfn></h3>
<!-- @{ -->
<!-- If the selection is collapsed (but not if it contains nothing but is not
collapsed), IE9 wraps the whole line in a <strong>.  This seems bizarre and no
one else does it, so I don't do it.  It's a similar story for similar commands
(fontName, italic, etc.).  Except not for strikethrough, where it just does
nothing if the selection is empty.  Why strikethrough?  I don't know. -->

<p><span>Action</span>: If <code
title=queryCommandState()>queryCommandState("bold")</code> returns true,
<span>set the selection's value</span> to "normal".  Otherwise <span>set the
selection's value</span> to "bold".

<p><span>Inline command activated values</span>: "bold", "600", "700", "800",
or "900"
<!--
The cutoff of 600 (both here and for state) matches Chrome 14 dev.  The cutoff
used by IE9 and Firefox 6.0a2 seems to be 500, and the distinction isn't
relevant for Opera 11.11 (it doesn't use CSS here at all AFAICT).  On my test
systems with default fonts, Chrome 14 dev displays 700 and up as bold, while
the other three display 600 and up as bold.

Thus in Chrome on my system, the bold command will behave a bit oddly the first
time you hit it if there's anything in the range with font-weight: 600, but it
will look right in other browsers.  On the other hand, if I followed
IE/Firefox, it would look wrong on all my browsers for font-weight: 500.

700 actually makes more sense: then you'd view 100-300 as light, 400-600 as
medium, 700-900 as bold.  But that's not how it seems to work in browsers, so
I'll go with 600 as the cutoff.
-->

<p><span>Relevant CSS property</span>: "font-weight"

<!-- @} -->
<h3><dfn>The <code title>createLink</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!-- If the selection doesn't contain anything (meaning, e.g., deleteContents()
doesn't change anything), then Chrome 12 dev inserts a link at the selection
start, with the text equal to the link URL.  Other browsers don't do it, so I
don't either. -->
<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!--
  Firefox 4b11 and Chrome 11 dev both silently do nothing in this case.
  IE 9 RC and Opera 11 both treat the request literally.  Gecko and WebKit
  probably have it right here: users who enter no URL are very unlikely to want
  to link to a relative URL resolving to the current document.  If they really
  want to, they can always specify "#" for the value, or the author can rewrite
  it, so it's not like this makes the API less useful.
  -->

  <li>For each <span>editable</span> [[a]] element that has an [[href]]
  attribute and is an [[ancestor]] of some [[node]] <span>effectively
  contained</span> in the <span>active range</span>, set that [[a]] element's
  [[href]] attribute to <var>value</var>.
  <!-- There are three approaches here.  For instance, if you ask browsers to
  create a link to "http://example.org" on the "b" here:

    <a href=http://example.com><b>Abc</b></a>

  Chrome 10 dev produces:

    <b><a href=http://example.com>A</a><a href=http://example.org>b</a>
    <a href=http://example.com>c</a></b>

  Firefox 4b11 produces (roughly):

    <a href=http://example.com><b>A<a href=http://example.org>b</a>c</b></a>

  (This doesn't round-trip through text/html serialization.)  IE 9 RC and Opera
  11 produce simply:

    <a href=http://example.org><b>Abc</b></a>

  The last behavior probably best matches user expectations.  If you happen to
  miss out a character when selecting the link you want to change, do you
  really intend to only change the link of part of it?
  -->

  <li><span>Set the selection's value</span> to <var>value</var>.
</ol>

<!-- IE10PP2, Firefox 7.0a2, Chrome 14 dev, and Opera 11.50 all do not support
indeterminate, state, or value for createLink or unlink.  I define
indeterminate and value anyway because they make sense. -->
<p><span>Standard inline value command</span>

<!-- @} -->
<h3><dfn>The <code title>fontName</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Set the selection's value</span> to
<var>value</var>.
<!-- UAs differ a bit in the details here:

IE 9 RC: Empty string sets <font face="">
Firefox 4b11: Empty string does nothing
Chrome 11 dev: Empty string does nothing, '"monospace"' same as 'monospace'
  (i.e., cannot escape font-family keywords because quotes are stripped,
  clearly wrong)
Opera 11: Empty string sets <font face="">

Setting an empty font-family has the effect of inheriting the font from the
parent (although I don't see where the February 24, 2011 CSS 3 Fonts draft says
that).  Thus it makes sense that if we special-case this, it should be to unset
the font somehow.

Special-casing the empty string to do nothing doesn't make sense to me.  With
createLink we'd expect the user to enter the URL themselves, so it makes sense
to special-case clicking OK without entering anything.  But here it's very
likely that the font list will be fixed by the author (how many users will
understand CSS font-family syntax?), so I don't think such usability concerns
apply. -->

<p><span>Standard inline value command</span>
<!--
The value is complicated.

IE 9 RC: Always the empty string.  Not very useful.
Firefox 4b11: Confusing.  Sometimes it returns generic family names, like
  "sans-serif".  Sometimes it gives specific font names, like "tt" when the
  font is specified as "monospace".  Sometimes it gives the literal font-family
  string.  Not sure what it's doing here.
Chrome 11 dev: Gives the literal value of font-family, except if it's inherited
  from default values (no explicit style declarations anywhere), when it seems
  to return the exact font name.
Opera 11: Returns the literal value of font-family, except if it's inherited
  from default values, when it returns the empty string.

I'm just going to punt on this and say it should be the resolved value of
font-family.  I'll leave CSSOM to decide what that means if there are no
applicable style rules.
-->

<p><span>Relevant CSS property</span>: "font-family"

<!-- @} -->
<h3><dfn>The <code title>fontSize</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!--
IE 9: Parses the value as a number (allowing floating-point), rounds to the
  nearest integer, then clamps to the range 1 to 7.  If the value is not a
  valid number, including if it has trailing characters (like "2em"), does
  nothing.  Normalizes relative sizes, so "+0" is the same as "+3", etc.
  Treats empty string the same as "1".
Firefox 4.0: Passes the value through literally to <font size=>, so "2em" gets
  you <font size="2em">.  Always uses <font>, even with styleWithCss true.
  Ignores the command if the value is the empty string.
Chrome 12 dev: Parses the value as a legacy font size, so "2em" becomes "2",
  then outputs a <font> with the resulting number.  If there is no resulting
  number, like for a value of "xx-small", does nothing.  In styleWithCss mode,
  outputs a span with corresponding CSS keywords: 1 = x-small, 2 = small,
  . . ., 6 = xx-large, 7 = -webkit-xxx-large.  Normalizes relative sizes, so
  "+0" is the same as "3", etc.  Ignores the command if the value is the empty
  string.
Opera 11: Parses the value as an integer (ignoring floating-point as trailing
  characters), then outputs that.  This means that "+0" becomes <font size=0>
  instead of <font size=+0> or <font size=3>.  Non-numeric values get
  interpreted as 0.  Does not clamp, and is willing to output negative numbers.
  Treats empty string as "0".

What all of these have in common is that they force the author to deal with
legacy font values and don't let them use CSS.  This is undesirable, so I
ignore how implementations behave.  Practically any value that did the same
thing in IE and Firefox should still do the same thing here, so I'm only
respecifying non-interoperable behavior anyway.
-->
<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.

  <li><span data-anolis-spec=html>Strip leading and trailing whitespace</span>
  from <var>value</var>.

  <li>If <var>value</var> is a <span data-anolis-spec=html>valid floating point
  number</span>, or would be a <span data-anolis-spec=html>valid floating point
  number</span> if a single leading "+" character were stripped:

  <ol>
    <li>If the first character of <var>value</var> is "+", delete the character
    and let <var>mode</var> be "relative-plus".

    <li>Otherwise, if the first character of <var>value</var> is "-", delete
    the character and let <var>mode</var> be "relative-minus".

    <li>Otherwise, let <var>mode</var> be "absolute".

    <li>Apply the <span data-anolis-spec=html>rules for parsing non-negative
    integers</span> to <var>value</var>, and let <var>number</var> be the
    result.

    <li>If <var>mode</var> is "relative-plus", add three to <var>number</var>.

    <li>If <var>mode</var> is "relative-minus", negate <var>number</var>, then
    add three to it.

    <li>If <var>number</var> is less than one, let <var>number</var> equal 1.

    <li>If <var>number</var> is greater than seven, let <var>number</var> equal
    7.

    <li>Set <var>value</var> to the string here corresponding to
    <var>number</var>:

    <ul>
      <li>1: xx-small
      <li>2: small
      <li>3: medium
      <li>4: large
      <li>5: x-large
      <li>6: xx-large
      <li>7: xxx-large
    </ul>

    <!--
    The entry for 7 here is an issue: there's no CSS value that corresponds to
    it.  Even if we got one added to the drafts, it wouldn't be
    backward-compatible to use it.  WebKit is the only engine that supports CSS
    output for fontSize, and it uses -webkit-xxx-large in this case, which is
    unworkable.  Instead, we just always output a font tag for size 7.  If
    authors want conforming markup, they'll need to give CSS sizes above size
    7, not legacy sizes.
    -->
  </ol>

  <li>If <var>value</var> is not one of the strings "xx-small", "x-small",
  "small", "medium", "large", "x-large", "xx-large", "xxx-large", and is not a
  valid CSS absolute length, then abort these steps and do nothing.
  <!--
  Not sure this is the best way to do it.  We don't want to allow relative
  lengths, because those can have very weird user-visible behavior.  For
  instance, a size of 2em would sometimes double the text size, but if you
  applied it a second time it would do nothing, but if you deselected one
  character it would suddenly double the size again.  Current UAs just only
  allow numeric values.  There's no harm in allowing "x-small" and absolute
  sizes, I don't think.
  -->

  <li><span>Set the selection's value</span> to <var>value</var>.
</ol>

<p><span>Indeterminate</span>: True if among <span>editable</span> [[text]]
nodes that are <span>effectively contained</span> in the <span>active
range</span>, there are two that have distinct <span title="effective command
value">effective command values</span>.  Otherwise false.
<!-- This follows Firefox 6.0a2.  Chrome 14 dev always returns false.  Note
that indeterminacy here keys off the effective command value, while the value
is based only on an approximation (a number from one to seven).  Thus it's
possible for every subrange of the selection to have the same value, but for
the selection to still be indeterminate.  Setting the fontSize to the value
will make it determinate without changing anything's value. -->

<p><span>Value</span>:
<!--
IE9: Seems to return a number based on the computed font-size, but only if it's
exactly right, otherwise it returns null.  Something like that.

Firefox 6.0a2: Seemingly goes up to the nearest ancestor that's a <font size>
and returns the literal value of that attribute, or "" if there's no such
ancestor.

Chrome 14 dev: Gets the computed font-size in pixels, and rounds to the nearest
<font size> equivalent, rounding up in the event of a tie.  Except that if it's
small enough, it returns "0", which doesn't make sense because that behaves the
same as "1".

Opera 11.11: Like Firefox, except it returns "3" if there's no <font size>
ancestor, and it converts relative values to absolute ("+1" -> "4").

Chrome's behavior seems the most useful.  As usual, IE returns a variable type
and all other browsers return strings, and we follow other browsers.

If the selection isn't someplace editable, Chrome works like usual; some other
browsers behave differently.  I see no reason to behave differently.
-->
<ol>
  <li>Let <var>pixel size</var> be the <span>effective command value</span> of
  the first <span>editable</span> [[text]] node that is <span>effectively
  contained</span> in the <span>active range</span>, or if there is no such
  node, the <span>effective command value</span> of the <span>active
  range</span>'s [[startnode]], in either case interpreted as a number of
  pixels.
  <!-- See comment for standard inline value commands on how I decided on this
  choice of node. -->

  <li>Return the <span>legacy font size for</span> <var>pixel size</var>.
</ol>

<p><span>Relevant CSS property</span>: "font-size"

<p>The <dfn>legacy font size for</dfn> an integer <var>pixel size</var> is
returned by the following algorithm:

<ol>
  <li>Let <var>returned size</var> be 1.

  <li>While <var>returned size</var> is less than 7:

  <ol>
    <li>Let <var>lower bound</var> be the [[resval]] of "font-size" in pixels
    of a [[font]] element whose [[fontsize]] attribute is set to <var>returned
    size</var>.

    <li>Let <var>upper bound</var> be the [[resval]] of "font-size" in pixels
    of a [[font]] element whose [[fontsize]] attribute is set to one plus
    <var>returned size</var>.

    <li>Let <var>average</var> be the average of <var>upper bound</var> and
    <var>lower bound</var>.

    <li>If <var>pixel size</var> is less than <var>average</var>, return the
    one-[[strel]] string consisting of the digit <var>returned size</var>.

    <li>Add one to <var>returned size</var>.
  </ol>

  <li>Return "7".
</ol>
<!-- @} -->
<h3><dfn>The <code title>foreColor</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!-- Color interpretations (wide screen recommended):

                        IE10PP2       Firefox 7.0a2            Chrome 14 dev            Opera 11.50
blue                    blue          blue                     #0000ff                  #0000ff
f                       #f            -                        -                        #f00000
#f                      #f            -                        -                        #f00000
00f                     #00f          -                        #0000ff                  #00000f
#00f                    #00f          rgb(0, 0, 255)           #0000ff                  #00000f
0000ff                  #0000ff       -                        #0000ff                  #0000ff
#0000ff                 #0000ff       rgb(0, 0, 255)           #0000ff                  #0000ff
000000fff               #0000ff       -                        -                        -
#000000fff              #0000ff       -                        -                        -
rgb(0, 0, 255)          rgb(0,0,255)  rgb(0, 0, 255)           #0000ff                  #00b000
rgb(0%, 0%, 100%)       rgb(0,0,255)  rgb(0, 0, 255)           #0000ff                  #00b000
rgb( 0 ,0 ,255)         rgb(0,0,255)  rgb(0, 0, 255)           #0000ff                  #00b000
rgba(0, 0, 255, 0.0)    #ba0000       rgba(0, 0, 255, 0)       rgba(0, 0, 255, 0)       #00ba00
rgb(15, -10, 375)       rgb(15,0,255) rgb(15, 0, 255)          #0f00ff                  #00b015
rgba(0, 0, 0, 1)        #ba0010       rgb(0, 0, 0)             -                        #00ba00
rgba(255, 255, 255, 1)  #000055       rgb(255, 255, 255)       #ffffff                  #00ba02
rgba(0, 0, 255, 0.5)    #ba0000       rgba(0, 0, 255, 0.5)     rgba(0, 0, 255, 0.5)     #00ba00
hsl(240, 100%, 50%)     #000150       rgb(0, 0, 255)           #0000ff                  #000024
cornsilk                cornsilk      cornsilk                 #fff8dc                  #fff8dc
potato quiche           #0000c0       -                        -                        #000a00
transparent             transparent   -                        rgba(0, 0, 0, 0)         #00a000
currentColor            #c0e000       currentcolor             rgba(0, 0, 0, 0)         #c000e0

The interpretations given for Firefox are only in styleWithCSS mode.  In
non-styleWithCSS mode, it just outputs the string literally as the <font color>
attribute value, which can lead to different results.  The given output for
Chrome is for <font>; the output in styleWithCSS mode is the same, but rgb() is
used instead of hex notation, and "transparent" and "currentcolor" are passed
through under those names.  IE and Opera only support <font> to begin with.

Conclusions:

* Everyone accepts simple color keywords and #xxxxxx notation.
* Opera mangles #xxx, but everyone else handles it fine.
* The leading # is optional in all browsers but Gecko.
* rgb() is accepted by everyone but Opera.
* rgba() and hsl() are accepted by Gecko and WebKit, but rejected by IE and
  Opera.
* IE and Opera mangle unrecognized stuff, Gecko and WebKit ignore.
* Browsers will happily output stuff like "transparent" and "rgba()" into <font
  color> even though it won't be uniformly accepted there.
* Opera and WebKit normalize the output color very aggressively, Gecko leaves
  keywords intact but otherwise normalizes for CSS output (but doesn't
  normalize at all for <font>), and IE normalizes inconsistently.

What I'm going to say is that it either has to be a valid CSS color, or
prefixing it with # must result in a valid CSS color.  For <font>, I'll say
that the output color should be normalized to #xxxxxx form unless it's an SVG
color keyword, in which case it's passed through intact.  If the color is not a
simple color (fully opaque with all channels between 0 and 255), I'll force
style="" even if styleWithCSS mode is off.  Some of this disagrees with all
browsers, but it's unlikely to hurt and it makes sense.
-->
<ol>
  <li>If <var>value</var> is not a valid CSS color, prepend "#" to it.

  <li>If <var>value</var> is still not a valid CSS color, or if it is
  currentColor, abort these steps and do nothing.
  <!-- currentColor is bad for the same reason as relative font sizes.  It will
  confuse the algorithm, and doesn't seem very useful anyway. -->

  <li><span>Set the selection's value</span> to <var>value</var>.
</ol>

<!-- Opera 11 seems to return true for the state if there's some color style
applied, false otherwise, which seems fairly useless; authors want to use value
here, not state.  So I'll match other browsers and not define any state. -->

<p><span>Standard inline value command</span>
<!--
The spec essentially matches Firefox 6.0a2 and Chrome 14 dev, as far as how to
decide what color the node has.  IE9 seems to always return the number 0 for
some bizarre reason.  There are some cases where Firefox returns the empty
string for some reason, and it seems to select the active node a little
differently.  Opera uses #xxxxxx format for getComputedStyle() but rgb() here,
and also drops the transparent part of the color if there is any.
-->

<p><span>Relevant CSS property</span>: "color"

<!-- @} -->
<h3><dfn>The <code title>hiliteColor</code> command</dfn></h3>
<!-- @{ -->
<!-- IE 9 RC doesn't support this.  It uses backColor instead, but Gecko and
Opera treat that differently, while all non-IE browsers treat hiliteColor the
same, so I'm standardizing hiliteColor as the way to highlight text.

This is slightly tricky, because background-color does different things on
block and inline elements.  Given the name ("hiliteColor"), we really only want
to apply it to inline elements.  This is how everyone but Gecko behaves, but
Gecko sometimes applies it to blocks too.  WebKit doesn't set it on non-inline
elements, but does clear it and push it down from them.

The spec doesn't do any of these: background-color on non-inline elements is
not touched by hiliteColor, neither created nor removed.  If users want to
remove the style, they need to use removeFormat.  Adding it usually makes no
sense; see the comment for backColor.

For color parsing, see the comment for foreColor. -->
<p class=note>For historical reasons, backColor and hiliteColor behave
identically.

<p><span>Action</span>:

<ol>
  <li>If <var>value</var> is not a valid CSS color, prepend "#" to it.

  <li>If <var>value</var> is still not a valid CSS color, or if it is
  currentColor, abort these steps and do nothing.
  <!-- currentColor is bad for the same reason as relative font sizes.  It will
  confuse the algorithm, and doesn't seem very useful anyway.  For hiliteColor
  you could conceive of it being useful, but it will still confuse the
  algorithm, so ban it for now anyway. -->

  <li><span>Set the selection's value</span> to <var>value</var>.
</ol>

<p><span>Standard inline value command</span>
<!-- For indeterminacy, this follows no one.  Firefox 6.0a2 and Chrome 14 dev
both always return false.  However, it makes sense. -->

<p><span>Relevant CSS property</span>: "background-color"

<!-- @} -->
<h3><dfn>The <code title>italic</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: If <code
title=queryCommandState()>queryCommandState("italic")</code> returns true,
<span>set the selection's value</span> to "normal".  Otherwise <span>set the
selection's value</span> to "italic".

<p><span>Inline command activated values</span>: "italic" or "oblique"

<p><span>Relevant CSS property</span>: "font-style"

<!-- @} -->
<h3><dfn>The <code title>removeFormat</code> command</dfn></h3>
<!-- @{ -->
<!--
Tested in IE 9, Firefox 4.0, Chrome 12 dev, Opera 11.00.

Tags stripped by everyone: b big cite code dfn em font i ins kbd samp s small
  strike strong sub sup tt u var
Tags left alone by everyone: br hr img

Unrecognized elements: stripped by Firefox and Opera, left alone by IE and
  Chrome.

blink: stripped only by IE
abbr: stripped only by Firefox
a, wbr: stripped only by Opera

nobr: left alone only by Firefox
acronym, bdo, q: left alone only by Opera

bdi, del, mark, span, svg: treated the same as unknown elements

All elements whose default rendering is display: block are left untouched by
all browsers (although IE seems to throw an exception on <marquee> for some
reason).

It's not clear to me why we should leave <a> alone, but everyone but Opera
does.  In OpenOffice.org 3.2.1, doing "Default Formatting (Ctrl+M)" doesn't
remove links.  In Microsoft Word 2007, doing "Clear Formatting" also doesn't
remove links.  Verdict: don't remove links.  Apparently they don't logically
qualify as "formatting".

Conclusion: leave alone a, br, hr, img, wbr.  Strip everything else, including
unrecognized elements, although of course not block elements.  Also we should
probably treat all replaced elements the same as <img>, although I didn't test
that (somehow I doubt it will come up much).  <video> behaves the same as
<img>, although Firefox adds tabindex=0 (???), so I'm assuming the rest are
similar.  Also, I'll keep all foreign elements and form elements.

Browsers will split up all these inline elements if the selection is contained
within them.  Opera does strip unrecognized elements with display: block if
they're within the selection, but doesn't split them up if they contain the
selection.

Chrome 14 dev removes style attributes from every element in the range, but
IE10PP2, Firefox 7.0a2, and Opera 11.50 do not, so I go with them.
-->

<p><span>Action</span>:

<ol>
  <li>Let <var>elements to remove</var> be a list of all <span>editable</span>
  <span title="HTML element">HTML elements</span> <span>effectively
  contained</span> in the <span>active range</span>, excluding those with
  [[localname]] "a", "audio", "br", "img", "video", or "wbr", and excluding
  <span title="prohibited paragraph child">prohibited paragraph
  children</span>.

  <p class=XXX>Do we want to go with this whitelist approach, or a blacklist?
  If a whitelist, should we also whitelist display: block elements?  Either
  way, what exact list should we use?  I specced it this way because it's
  easiest given the definitions I'm using, since I have a mostly complete list
  of things to exclude (prohibited paragraph children) but no list of things to
  include (inline elements).

  <li>For each <var>element</var> in <var>elements to remove</var>:

  <ol>
    <li>While <var>element</var> has [[children]], insert the first [[child]]
    of <var>element</var> into the [[parent]] of <var>element</var> immediately
    before <var>element</var>, <span>preserving ranges</span>.

    <li>Remove <var>element</var> from its [[parent]].
  </ol>

  <li>If the <span>active range</span>'s [[startnode]] is an
  <span>editable</span> [[text]] node, and its [[startoffset]] is neither zero
  nor its [[startnode]]'s [[length]], call [[splittext|]] on the <span>active
  range</span>'s [[startnode]], with argument equal to the <span>active
  range</span>'s [[startoffset]].  Then set the <span>active range</span>'s
  [[startnode]] to the result, and its [[startoffset]] to zero.
  <!-- This last sentence just prettifies the resulting range a bit. -->

  <li>If the <span>active range</span>'s [[endnode]] is an
  <span>editable</span> [[text]] node, and its [[endoffset]] is neither zero
  nor its [[endnode]]'s [[length]], call [[splittext|]] on the <span>active
  range</span>'s [[endnode]], with argument equal to the <span>active
  range</span>'s [[endoffset]].

  <li>Let <var>node list</var> consist of all <span>editable</span> [[nodes]]
  <span>effectively contained</span> in the <span>active range</span>.

  <li>For each <var>node</var> in <var>node list</var>, while <var>node</var>'s
  [[parent]] is an <span>editable</span> <span>HTML element</span> <span>in the
  same editing host</span> as <var>node</var>, and <var>node</var>'s [[parent]]
  is not a <span>prohibited paragraph child</span> and does not have
  [[localname]] "a" or "audio" or "br" or "img" or "video" or "wbr",
  <span>split the parent</span> of the one-[[node]] list consisting of
  <var>node</var>.

  <!--
  TODO: Splitting the parent is really a block algorithm.  It's not clear
  whether it's desirable to use for inline nodes.  Perhaps it's okay, but it
  makes me a little uneasy.
  -->

  <li>For each of the entries in the following list, in the given order,
  <span>set the selection's value</span> to null, with <var>command</var> as
  given.
  <!-- For cases like <p style=font-weight:bold>foo[bar]baz</p>. -->

  <ol>
    <li>subscript
    <!-- superscript not needed, subscript does the same thing.  We run this
    first so <sub>/<sup> won't upset fontSize. -->
    <li>bold
    <li>fontName
    <li>fontSize
    <li>foreColor
    <li>hiliteColor
    <li>italic
    <li>strikethrough
    <li>underline
  </ol>
</ol>

<!-- @} -->
<h3><dfn>The <code title>strikethrough</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: If <code
title=queryCommandState()>queryCommandState("strikethrough")</code> returns
true, <span>set the selection's value</span> to null.  Otherwise <span>set the
selection's value</span> to "line-through".

<!-- TODO: See underline TODO. -->

<p><span>Inline command activated values</span>: "line-through"

<!-- @} -->
<h3><dfn>The <code title>subscript</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<ol>
  <li>Call <code
  title=queryCommandState()>queryCommandState("subscript")</code>, and let
  <var>state</var> be the result.

  <li><span>Set the selection's value</span> to "baseline".

  <li>If <var>state</var> is false, <span>set the selection's value</span> to
  "sub".
</ol>

<p><span>Indeterminate</span>: True if either among <span>editable</span>
[[text]] nodes that are <span>effectively contained</span> in the <span>active
range</span>, there is at least one with <span>effective command value</span>
"sub" and at least one with some other <span>effective command value</span>; or
if there is some <span>editable</span> [[text]] node <span>effectively
contained</span> in the <span>active range</span> with <span>effective command
value</span> "mixed".  Otherwise false.

<p><span>Inline command activated values</span>: "sub"
<!--
For <sup><sub>foo</sub></sup>, Firefox 6.0a2 and Opera 11.11 say the state is
true for both superscript and subscript, and indeterminate is false; Chrome 14
dev says it's true for subscript but not superscript, and indeterminate is
false.  We follow neither of these behaviors: we return false for both states,
and say indeterminate is true.  The reason is because we want to return true
for a state if we'll do nothing, false if we'll do something; and if we have
nesting like this, we'll always do something, namely get rid of all those
ancestors and replace them with a single tag.  This matches what happens in
other indeterminate situations, so it's fair to consider it indeterminate.
-->

<p><span>Relevant CSS property</span>: "vertical-align"

<!-- @} -->
<h3><dfn>The <code title>superscript</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<ol>
  <li>Call <code
  title=queryCommandState()>queryCommandState("superscript")</code>, and let
  <var>state</var> be the result.

  <li><span>Set the selection's value</span> to "baseline".

  <li>If <var>state</var> is false, <span>set the selection's value</span> to
  "super".
</ol>

<p><span>Indeterminate</span>: True if either among <span>editable</span>
[[text]] nodes that are <span>effectively contained</span> in the <span>active
range</span>, there is at least one with <span>effective command value</span>
"super" and at least one with some other <span>effective command value</span>;
or if there is some <span>editable</span> [[text]] node <span>effectively
contained</span> in the <span>active range</span> with <span>effective command
value</span> "mixed".  Otherwise false.

<p><span>Inline command activated values</span>: "super"

<p><span>Relevant CSS property</span>: "vertical-align"

<!-- @} -->
<h3><dfn>The <code title>underline</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: If <code
title=queryCommandState()>queryCommandState("underline")</code> returns true,
<span>set the selection's value</span> to null.  Otherwise <span>set the
selection's value</span> to "underline".

<!--
TODO: There are a lot of problems with underline color and thickness, because
text-decoration in CSS is horrible.  These aren't prohibitive for normal use
and existing browsers don't handle them either, so fixing these problems or
working around them can be put off for now.

* Pushing down underlines can change their color, since the color of an
  underline follows the color of the element where it's declared instead of the
  text it's drawn under.  This could be fixed by adding a special case for this
  condition and inserting extra color rules, such as by setting a color on the
  underlining element and then having another element inside it that resets the
  color.  Horrible, but that's text-decoration for you.  Alternatively, the new
  text-decoration-color property in the CSS 3 Text draft could come in handy
  here, in which case we'd degrade pretty gracefully in legacy UAs.

* Underline thickness depends on font-size in all rendering engines but WebKit,
  so pushing them down creates thickness problems as well as color problems.
  Working around this is a similar story to the previous, except we have no
  text-decoration-width property yet (see
  http://lists.w3.org/Archives/Public/www-style/2011Mar/0593.html).

* The preceding two points can't be avoided, because the only way to remove
  underlines in CSS is to push down styles (unlike most other things where you
  could override it).  Recent (February 2011) CSS 3 Text drafts have added
  support for a "text-decoration-line: cancel-underline" property, but we can
  only use that if there's no other possibility, since it won't work in legacy
  browsers.  (Although we should use it once there's no other possibility.)

* More generally, from a user's perspective, color and thickness of underlines
  is going to be more or less random if they're applying them to text with
  varying size or color.  If they underline a bunch of text all at once, it
  will all get the same color/thickness, probably.  But if they underline
  letter-by-letter, it probably will vary.  But sometimes when they underline a
  bunch of text at once it will also vary, if the algorithm decides to create
  multiple elements for whatever reason (like an intervening unwrappable node).
  This is unlikely to match user expectations.  There's not much we can do
  about this without entirely revamping text-decoration, so we'll have to live
  with it.

* Currently we don't treat non-underline text-decorations properly, because we
  have no way to set (or cancel) underlines independently of other
  text-decorations from within CSS.  I've sent feedback to www-style:
  http://lists.w3.org/Archives/Public/www-style/2011Mar/0591.html.
-->

<p><span>Inline command activated values</span>: "underline"

<!-- @} -->
<h3><dfn>The <code title>unlink</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!--
IE 9 RC unlinks the whole link you're pointing at, while others only
unlink the current text.  The latter behavior seems less expected, as with
createLink, although I can't articulate precisely why.  Word 2007 and
OpenOffice.org 3.2.1 (Ubuntu) seem to give an option to remove the whole link
or none of it, which backs the spec's requirement.  See also #whatwg logs
starting at 2011-05-13 at 16:53 EDT (UTC-0400).
-->
<ol>
  <li>Let <var>hyperlinks</var> be a list of every [[a]] element that has an
  [[href]] attribute and is [[contained]] in the <span>active range</span> or
  is an [[ancestor]] of one of its [[boundarypoints]].

  <li><span>Clear the value</span> of each member of <var>hyperlinks</var>.
</ol>

<!-- IE10PP2, Firefox 7.0a2, Chrome 14 dev, and Opera 11.50 all do not support
indeterminate, state, or value for createLink or unlink.  I define
indeterminate and value anyway because they make sense. -->
<p><span>Standard inline value command</span>

<!-- @} -->

<h2>Block formatting commands</h2>

<h3>Block formatting command definitions</h3>
<!-- @{ -->
<p>An <dfn>indentation element</dfn> is either a [[blockquote]], or a [[div]]
that has a [[style]] attribute that sets "margin" or some subproperty of it.

<p>A <dfn>simple indentation element</dfn> is an <span>indentation
element</span> that has no attributes other than one or more of

<ul>
  <li>a [[style]] attribute that sets no properties other than "margin",
  "border", "padding", or subproperties of those;

  <li>a <code data-anolis-spec=html title=classes>class</code> attribute;

  <li>a <code data-anolis-spec=html title="the dir attribute">dir</code>
  attribute.
</ul>

<p>A <dfn>non-list single-line container</dfn> is an <span>HTML element</span>
with [[localname]] "address", "div", "h1", "h2", "h3", "h4", "h5", "h6",
"listing", "p", "pre", or "xmp".
<!-- listing and xmp are included because otherwise insertParagraph inside them
won't work, since paragraphs aren't an allowed child. -->

<p>A <dfn>single-line container</dfn> is either a <span>non-list single-line
container</span>, or an <span>HTML element</span> with [[localname]] "li",
"dt", or "dd".

<p>The <dfn>default single-line container name</dfn> is "p".
<!-- TODO: Make this configurable. -->

<!-- @} -->
<h3>Assorted block formatting command algorithms</h3>
<!-- @{ -->
<p>To <dfn>fix disallowed ancestors</dfn> of <var>node</var>:
<!-- TODO: When breaking a non-inline element out of an inline element, like p
in b or whatever, it would make sense to re-wrap the contents in the inline
tag. -->

<ol>
  <li>If <var>node</var> is not <span>editable</span>, abort these steps.

  <li>If <var>node</var> is not an <span>allowed child</span> of any of its
  [[ancestors]] <span>in the same editing host</span>, and is not an <span>HTML
  element</span> with [[localname]] equal to the <span>default single-line
  container name</span>:
  <!-- The requirement about default containers is to prevent an infinite loop.
  This case is really intended to handle stuff like list items or table cells
  that wander outside their proper place. -->

  <ol>
    <li>If <var>node</var> is a [[dd]] or [[dt]], <span>wrap</span> the
    one-[[node]] list consisting of <var>node</var>, with <span>sibling
    criteria</span> matching any [[dl]] with no [[attributes]], and <span>new
    parent instructions</span> returning the result of calling
    [[createelement|"dl"]] on the [[contextobject]].  Then abort these steps.

    <li>If <var>node</var> is not a <span>prohibited paragraph child</span>,
    abort these steps.

    <li><span>Set the tag name</span> of <var>node</var> to the <span>default
    single-line container name</span>, and let <var>node</var> be the result.

    <li><span>Fix disallowed ancestors</span> of <var>node</var>.
    <!-- Because maybe it somehow wound up as the child of a p, like via
    insertHTML. -->

    <li>Let <var>descendants</var> be all [[descendants]] of <var>node</var>.

    <li><span>Fix disallowed ancestors</span> of each member of
    <var>descendants</var>.

    <li>Abort these steps.
  </ol>

  <li><span>Record the values</span> of the one-[[node]] list consisting of
  <var>node</var>, and let <var>values</var> be the result.

  <li>While <var>node</var> is not an <span>allowed child</span> of its
  [[parent]], <span>split the parent</span> of the one-[[node]] list consisting
  of <var>node</var>.

  <li><span>Restore the values</span> from <var>values</var>.
</ol>

<p>To <dfn>normalize sublists</dfn> in a [[node]] <var>item</var>:
<!--
This algorithm implies that we don't support a sublist in the middle of an
item, only at the end.  For instance,

  <li>foo<ol>...</ol>bar</li>

gets transformed to

  <li>foo</li><ol>...</ol><li>bar</li>

which in particular creates an extra list marker for "bar".  This is okay; we
don't need to expose all of HTML's markup abilities through execCommand().
Similarly, the superscript and subscript commands don't allow nesting.  I
didn't see any way to get a sublist in the middle of an item in Word 2007 or in
OpenOffice.org 3.2.1 Ubuntu package, nor in  any browser using just
execCommand(), so it should be no big problem if we require that such nesting
not occur.  (Existing browsers behave weirdly and inconsistently when
confronted with this kind of nesting.)

The reason we need this is that otherwise it gets very confusing to figure out
what happens in cases like trying to outdent
  <ol><li>[foo<ol><li>bar]</ol>baz</ol>
If we first normalize, then the natural answer is something like
  <p>[foo<ol><li>bar]<li>baz</ol>
but if we don't, we'd have to special-case in the toggle lists and outdent
algorithms.  This might be worthwhile, but it's not at all clear, and what I
have works okay, so I'll stick with it for now.

TODO: Investigate fixing this.
-->

<ol>
  <li>If <var>item</var> is not an [[li]] or it is not <span>editable</span> or
  its [[parent]] is not <span>editable</span>, abort these steps.

  <li>Let <var>new item</var> be null.

  <li>While <var>item</var> has an [[ol]] or [[ul]] [[child]]:

  <ol>
    <li>Let <var>child</var> be the last [[child]] of <var>item</var>.

    <li>If <var>child</var> is an [[ol]] or [[ul]], or <var>new item</var> is
    null and <var>child</var> is a [[text]] node whose <code
    data-anolis-spec=domcore title=dom-CharacterData-data>data</code>
    consists of zero of more <span data-anolis-spec=domcore title="space
    character">space characters</span>:

    <ol>
      <li>Set <var>new item</var> to null.

      <li>Insert <var>child</var> into the [[parent]] of <var>item</var>
      immediately following <var>item</var>, <span>preserving ranges</span>.
    </ol>

    <li>Otherwise:

    <ol>
      <li>If <var>new item</var> is null, let <var>new item</var> be the
      result of calling <code data-anolis-spec=domcore
      title=dom-Document-createElement>createElement("li")</code> on the
      [[ownerdocument]] of <var>item</var>, then insert <var>new item</var>
      into the [[parent]] of <var>item</var> immediately after
      <var>item</var>.

      <li>Insert <var>child</var> into <var>new item</var> as its first
      [[child]], <span>preserving ranges</span>.
    </ol>
  </ol>
</ol>

<p>The <dfn>selection's list state</dfn> is returned by the following
algorithm:

<ol>
  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each <var>node</var> [[contained]] in <var>new range</var>, append
  <var>node</var> to <var>node list</var> if the last member of <var>node
  list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is <span>editable</span>; <var>node</var> is not an
  <span>indentation element</span>; and <var>node</var> is either an [[ol]] or
  [[ul]], or the [[child]] of an [[ol]] or [[ul]], or an <span>allowed
  child</span> of "li".

  <li>If <var>node list</var> is empty, return "none".

  <li>If every member of <var>node list</var> is either an [[ol]] or the
  [[child]] of an [[ol]] or the [[child]] of a [[child]] of an [[li]] [[child]]
  of an [[ol]], and none is a [[ul]] or an [[ancestor]] of a [[ul]], return
  "ol".
  <!--
  The child-of-child case is necessary right now because of the following:
    <ol><li>[foo<ol><li>bar]</ol>baz</ol>
  With the current (July 2011) block-extend algorithm, this will become:
    {<ol><li>foo<ol><li>bar</ol>}baz</ol>
  because of the magical li handling in block-extend.  We want this to register
  as ol, because after normalizing sublists it will become
    {<ol><li>foo</li><ol><li>bar</ol>}<li>baz</ol>

  But the text node "foo" will wind up in node list, and is not the child of an
  ol.  This is all very messy and has to do with questionable decisions about
  how to handle nested lists.
  -->

  <li>If every member of <var>node list</var> is either a [[ul]] or the
  [[child]] of a [[ul]] or the [[child]] of an [[li]] [[child]] of a [[ul]],
  and none is an [[ol]] or an [[ancestor]] of an [[ol]], return "ul".
  <!-- The previous two conditions are mutually exclusive, so the order is
  actually irrelevant.  Clearly they could only both hold if no member of node
  list is an ol or ul, so if they both held, every member would have to be
  either the child of an ol and of a ul, or of an ol and an li, or a ul and an
  li, or of an li that's the child of both an ol and a ul.  This is impossible
  unless the list is empty, in which case we already aborted. -->

  <li>If some member of <var>node list</var> is either an [[ol]] or the
  [[child]] or [[ancestor]] of an [[ol]] or the [[child]] of an [[li]]
  [[child]] of an [[ol]], and some member of <var>node list</var> is either a
  [[ul]] or the [[child]] or [[ancestor]] of a [[ul]] or the [[child]] of an
  [[li]] [[child]] of a [[ul]], return "mixed".

  <li>If some member of <var>node list</var> is either an [[ol]] or the
  [[child]] or [[ancestor]] of an [[ol]] or the [[child]] of an [[li]]
  [[child]] of an [[ol]], return "mixed ol".

  <li>If some member of <var>node list</var> is either a [[ul]] or the
  [[child]] or [[ancestor]] of a [[ul]] or the [[child]] of an [[li]] [[child]]
  of a [[ul]], return "mixed ul".

  <li>Return "none".
</ol>

<p>The <dfn>alignment value</dfn> of a [[node]] <var>node</var> is returned by
the following algorithm:
<!--
When querying the value of justify*, IE9 seems to return boolean false across
the board when it doesn't throw exceptions, which it usually does in my tests.
Chrome 14 dev returns the string "true" or "false" depending on state, as in
other cases, which is useless.  Opera 11.11 returns "" across the board.
Firefox 6.0a2 behaves like with other command values: it returns
"center"/"justify"/"left"/"right" depending on the active range's start node.
Since this is the only behavior that's possibly useful, it's what I specced.
Firefox ties the value closely to the state, returning true for the state if
and only if the value matches the desired value, but this seems less useful
than what I've specced for the state.

This API is based on the four-state text-align of CSS 2.1.  We do some crude
mapping to make it not break too badly with CSS3 values, but it's not going to
work well given the design of the API.
-->
<ol>
  <li>While <var>node</var> is neither null nor an [[element]], or it is an
  [[element]] but its "display" property has [[resval]] "inline" or "none",
  set <var>node</var> to its [[parent]].

  <li>If <var>node</var> is not an [[element]], return "left".
  <!-- This means there's no applicable style rule, so probably it will wind up
  left-aligned.  Of course this ignores the fact that the alignment will really
  be "start", so this is wrong for RTL, but it's a pretty marginal corner case
  anyway.  (It will only happen if, e.g., everything up to and including the
  html and body elements have display: inline or none.) -->

  <li>If <var>node</var>'s "text-align" property has [[resval]] "start",
  return "left" if the [[directionality]] of <var>node</var> is "ltr", "right"
  if it is "rtl".

  <li>If <var>node</var>'s "text-align" property has [[resval]] "end", return
  "right" if the [[directionality]] of <var>node</var> is "ltr", "left" if it
  is "rtl".

  <li>If <var>node</var>'s "text-align" property has [[resval]] "center",
  "justify", "left", or "right", return that value.

  <li>Return "left".
</ol>

<!-- @} -->
<h3>Block-extending a range</h3>
<!-- @{ -->
<p>When a user agent is to <dfn>block-extend</dfn> a [[range]]
<var>range</var>, it must run the following steps:

<ol>
  <li>Let <var>start node</var>, <var>start offset</var>, <var>end node</var>,
  and <var>end offset</var> be the [[rangestart]] and [[rangeend]] [[bpnodes]]
  and [[bpoffsets]] of <var>range</var>.

  <li>If some [[ancestorcontainer]] of <var>start node</var> is an [[li]], set
  <var>start offset</var> to the [[index]] of the last such [[li]] in
  [[treeorder]], and set <var>start node</var> to that [[li]]'s [[parent]].

  <li>Repeat the following steps:

  <ol>
    <li>If <var>start node</var> is a [[text]] or [[comment]] node or
    <var>start offset</var> is 0, set <var>start offset</var> to the [[index]]
    of <var>start node</var> and then set <var>start node</var> to its
    [[parent]].

    <li>Otherwise, if <var>start node</var>'s [[child]] with [[index]]
    <var>start offset</var> minus one is <span>invisible</span>, subtract one
    from <var>start offset</var>.

    <li>Otherwise, if <var>start node</var> has no <span>visible</span>
    [[children]] with [[index]] greater than or equal to <var>start
    offset</var> and <var>start node</var>'s last <span>visible</span>
    [[child]] is an <span>inline node</span> that's not a [[br]], subtract one
    from <var>start offset</var>.
    <!-- So if you have a collapsed selection at the end of a block, for
    instance, it will extend backwards into a block. -->

    <li>Otherwise, if <var>start node</var> has a <span>visible</span>
    [[child]] with [[index]] greater than or equal to <var>start offset</var>,
    and the first such [[child]] is an <span>inline node</span>, and <var>start
    node</var>'s [[child]] with [[index]] <var>start offset</var> minus one is
    an <span>inline node</span> other than a [[br]], subtract one from
    <var>start offset</var>.
    <!-- IE also includes <br> (at least for the purposes of the indent
    command), but this is unlikely to match user expectations. -->

    <li>Otherwise, break from this loop.
  </ol>

  <li>If some [[ancestorcontainer]] of <var>end node</var> is an [[li]], set
  <var>end offset</var> to one plus the [[index]] of the last such [[li]] in
  [[treeorder]], and set <var>end node</var> to that [[li]]'s [[parent]].

  <li>Repeat the following steps:

  <ol>
    <li>If <var>end node</var> is a [[text]] or [[comment]] node or <var>end
    offset</var> is equal to the [[nodelength]] of <var>end node</var>, set
    <var>end offset</var> to one plus the [[index]] of <var>end node</var> and
    then set <var>end node</var> to its [[parent]].

    <li>Otherwise, if <var>end node</var>'s [[child]] with [[index]] <var>end
    offset</var> is <span>invisible</span>, add one to <var>end offset</var>.

    <li>Otherwise, if <var>end node</var> has no <span>visible</span>
    [[children]] with [[index]] less than <var>end offset</var> and <var>end
    node</var>'s first <span>visible</span> [[child]] is an <span>inline
    node</span> that's not a [[br]], add one to <var>end offset</var>.

    <li>Otherwise, if <var>end node</var> has a <span>visible</span> [[child]]
    with [[index]] less than <var>end offset</var>, and the last such [[child]]
    is an <span>inline node</span>, and <var>end node</var>'s [[child]] with
    [[index]] <var>end offset</var> is an <span>inline node</span> other than a
    [[br]], add one to <var>end offset</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <li>If the [[child]] of <var>end node</var> with [[index]] <var>end
  offset</var> is a [[br]], add one to <var>end offset</var>.

  <li>While <var>end offset</var> is equal to the [[nodelength]] of <var>end
  node</var>, set <var>end offset</var> to one plus the [[index]] of <var>end
  node</var> and then set <var>end node</var> to its [[parent]].

  <li>Let <var>new range</var> be a new [[range]] whose [[rangestart]] and
  [[rangeend]] [[bpnodes]] and [[bpoffsets]] are <var>start node</var>,
  <var>start offset</var>, <var>end node</var>, and <var>end offset</var>.

  <li>Return <var>new range</var>.
</ol>

<p>A [[node]] <var>node</var> <dfn>follows a line break</dfn> if the following
algorithm returns true:

<ol>
  <li>Let <var>offset</var> be zero.

  <li>While <var>offset</var> is zero, set <var>offset</var> to the [[index]]
  of <var>node</var> and then set <var>node</var> to its [[parent]].

  <li>Let <var>range</var> be a [[range]] with [[rangestart]] and [[rangeend]]
  (<var>node</var>, <var>offset</var>).

  <li><span>Block-extend</span> <var>range</var>, and let <var>new range</var>
  be the result.

  <li>Return false if <var>new range</var>'s [[rangestart]] is [[bpbefore]]
  (<var>node</var>, <var>offset</var>), true otherwise.
</ol>

<p>A [[node]] <var>node</var> <dfn>precedes a line break</dfn> if the following
algorithm returns true:

<ol>
  <li>Let <var>offset</var> be the [[length]] of <var>node</var>.

  <li>While <var>offset</var> is the [[length]] of <var>node</var>, set
  <var>offset</var> to one plus the [[index]] of <var>node</var> and then set
  <var>node</var> to its [[parent]].

  <li>Let <var>range</var> be a [[range]] with [[rangestart]] and [[rangeend]]
  (<var>node</var>, <var>offset</var>).

  <li><span>Block-extend</span> <var>range</var>, and let <var>new range</var>
  be the result.

  <li>Return false if <var>new range</var>'s [[rangeend]] is [[bpafter]]
  (<var>node</var>, <var>offset</var>), true otherwise.
</ol>

<!-- @} -->
<h3>Recording and restoring overrides</h3>
<!--@{-->

<p>To <dfn>record current overrides</dfn>:

<ol>
  <li>Let <var>overrides</var> be a list of (string, string or boolean) ordered
  pairs, initially empty.

  <!--
  When restoring, some commands can interfere with others.  Specifically, we
  want to restore createLink before foreColor and underline, and subscript and
  superscript before fontSize.  TODO: This approach only works for default
  styles (although I'm not sure offhand how we could handle non-default styles
  in principle).
  -->
  <li>If there is a <span>value override</span> for "createLink", add
  ("createLink", <span>value override</span> for "createLink") to
  <var>overrides</var>.
  <!--
  Firefox 7.0a2 and Opera 11.50 don't honor createLink with collapsed
  selections.  If you insert text, it's not linked.  The spec follows Chrome 14
  dev.  IE9 also ignores createLink with collapsed selections, but its behavior
  in other cases for collapsed selections is totally different from all other
  browsers, so it's not a fair comparison.
  -->

  <li>For each <var>command</var> in the list "bold", "italic",
  "strikethrough", "subscript", "superscript", "underline", in order: if there
  is a <span>state override</span> for <var>command</var>, add
  (<var>command</var>, <var>command</var>'s <span>state override</span>) to
  <var>overrides</var>.
  <!--
  Firefox 7.0a2 and Opera 11.50 will honor repeated subscript/superscript
  commands on a collapsed selection, allowing you to nest them.  The spec
  follows the general philosophy that we don't allow users to nest
  subscript/superscript, so the last one wins.  Chrome 14 dev is similar.
  -->

  <li>For each <var>command</var> in the list "fontName", "fontSize",
  "foreColor", "hiliteColor", in order: if there is a <span>value
  override</span> for <var>command</var>, add (<var>command</var>,
  <var>command</var>'s <span>value override</span>) to <var>overrides</var>.

  <li>Return <var>overrides</var>.
</ol>

<p>To <dfn>record current states and values</dfn>:

<ol>
  <li>Let <var>overrides</var> be a list of (string, string or boolean) ordered
  pairs, initially empty.

  <li>Let <var>node</var> be the first <span>editable</span> [[text]] node
  <span>effectively contained</span> in the <span>active range</span>, or null
  if there is none.

  <li>If <var>node</var> is null, return <var>overrides</var>.

  <li>Add ("createLink", <span>value</span> for "createLink") to
  <var>overrides</var>.

  <li>For each <var>command</var> in the list "bold", "italic",
  "strikethrough", "subscript", "superscript", "underline", in order: if
  <var>node</var>'s <span>effective command value</span> for <var>command</var>
  is one of its <span>inline command activated values</span>, add
  (<var>command</var>, true) to <var>overrides</var>, and otherwise add
  (<var>command</var>, false) to <var>overrides</var>.
  <!--
  Thus we will set state overrides based on the first editable text node, to
  match values.  This means that if you have <p>foo<b>[bar</b>baz]</p> and hit
  backspace and hit A, you'll get <p>foo<b>a[]</b></p>, although bold was
  previously indeterminate.  This is needed to match the behavior of hitting A
  straight away, since innerText doesn't strip wrappers when it invokes "delete
  the contents".
  -->

  <li>For each <var>command</var> in the list "fontName", "fontSize",
  "foreColor", "hiliteColor", in order: add (<var>command</var>,
  <var>command</var>'s <span>value</span>) to <var>overrides</var>.

  <li>Return <var>overrides</var>.
</ol>

<p>To <dfn>restore states and values</dfn> specified by a list
<var>overrides</var> returned by the <span>record current overrides</span> or
<span>record current states and values</span> algorithm:

<ol>
  <li>If there is some <span>editable</span> [[text]] node <span>effectively
  contained</span> in the <span>active range</span>, then for each
  (<var>command</var>, <var>override</var>) pair in <var>overrides</var>, in
  order:

  <ol>
    <li>If <var>override</var> is a boolean, and <code
    title=queryCommandState()>queryCommandState(<var>command</var>)</code>
    returns something different from <var>override</var>, call <code
    title=execCommand()>execCommand(<var>command</var>)</code>.

    <li>If <var>override</var> is a string, and <code
    title=queryCommandValue()>queryCommandValue(<var>command</var>)</code>
    returns something different from <var>override</var>, call <code
    title=execCommand()>execCommand(<var>command</var>, false,
    <var>override</var>)</code>.
  </ol>

  <li>Otherwise, for each (<var>command</var>, <var>override</var>) pair in
  <var>overrides</var>, in order:

  <ol>
    <li>If <var>override</var> is a boolean, set the <span>state
    override</span> for <var>command</var> to <var>override</var>.

    <li>If <var>override</var> is a string, set the <span>value override</span>
    for <var>command</var> to <var>override</var>.
  </ol>
</ol>

<!--@}-->
<h3>Deleting the contents of a range</h3>
<!-- @{ -->
<p>To <dfn>delete the contents</dfn> of a [[range]] <var>range</var>, given a
<var>block merging</var> flag that defaults to true and a <var>strip
wrappers</var> flag that defaults to true:
<!-- TODO: Consider what should happen for block merging in corner cases like
display: inline-table. -->

<ol>
  <li>If <var>range</var> is null, abort these steps and do nothing.

  <li>Let <var>start node</var>, <var>start offset</var>, <var>end node</var>,
  and <var>end offset</var> be <var>range</var>'s [[rangestart]] and
  [[rangeend]] [[bpnodes]] and [[bpoffsets]].

  <!-- Drill the range down to the lowest possible level, so we don't delete
  more elements than necessary. -->
  <li>While <var>start node</var> has at least one [[child]]:
  <!--
  We don't want to keep going when we hit an element with no children, because
  then we'd do something like

    foo{<br />bar]
    -> foo<br>{</br>bar]
    -> foo<br />{bar]
    -> foo<br />[bar]

  and we deselected the <br>.
  -->

  <ol>
    <li>If <var>start offset</var> is <var>start node</var>'s [[length]], and
    <var>start node</var>'s [[parent]] is <span>in the same editing
    host</span>, and <var>start node</var> is an <span>inline node</span>, set
    <var>start offset</var> to one plus the [[index]] of <var>start node</var>,
    then set <var>start node</var> to its [[parent]] and continue this loop
    from the beginning.
    <!--
    For instance:

      <b>foo[</b><i>bar]</i>
      -> <b>foo{</b><i>bar]</i>
      -> <b>foo</b>{<i>bar]</i>

    Then the next step will make it <b>foo</b><i>[bar]</i>.

    We don't want to do this for block nodes, because that would lead to
    something like

      <p>foo[</p><p>]bar<p>

    ultimately collapsing, which is wrong.  Once we do the deletion, it needs
    to wind up <p>foo[]bar</p>, whereas an actually collapsed selection should
    do nothing.
    -->

    <li>If <var>start offset</var> is <var>start node</var>'s [[nodelength]],
    break from this loop.
    <!-- This happens if the first step brought us all the way up to the root.
    The step immediately after this loop will bring us back down again.  -->

    <li>Let <var>reference node</var> be the [[child]] of <var>start node</var>
    with [[index]] equal to <var>start offset</var>.

    <li>If <var>reference node</var> is a <span>block node</span> or an
    [[element]] with no [[children]], or is neither an [[element]] nor a
    [[text]] node, break from this loop.
    <!--
    Don't descend into an element with no children, since then it won't get
    deleted even if it's selected.  Don't descend into a block node, because
    then we might wind up not mergings blocks when we should, e.g.

      foo{<p>}bar</p>
      -> foo<p>{}bar</p>

    and nothing gets changed.
    -->

    <li>Set <var>start node</var> to <var>reference node</var> and <var>start
    offset</var> to 0.
  </ol>

  <li>While <var>end node</var> has at least one [[child]]:

  <ol>
    <li>If <var>end offset</var> is 0, and <var>end node</var>'s
    [[parent]] is <span>in the same editing host</span>, and <var>end
    node</var> is an <span>inline node</span>, set <var>end offset</var> to the
    [[index]] of <var>end node</var>, then set <var>end node</var> to its
    [[parent]] and continue this loop from the beginning.

    <li>If <var>end offset</var> is 0, break from this loop.

    <li>Let <var>reference node</var> be the [[child]] of <var>end node</var>
    with [[index]] equal to <var>end offset</var> minus one.

    <li>If <var>reference node</var> is a <span>block node</span> or an
    [[element]] with no [[children]], or is neither an [[element]] nor a
    [[text]] node, break from this loop.

    <li>Set <var>end node</var> to <var>reference node</var> and <var>end
    offset</var> to the [[nodelength]] of <var>reference node</var>.
  </ol>

  <li>If (<var>end node</var>, <var>end offset</var>) is not [[bpafter]]
  (<var>start node</var>, <var>start offset</var>), set <var>range</var>'s
  [[rangeend]] to its [[rangestart]] and abort these steps.

  <li>If <var>start node</var> is a [[text]] node and <var>start offset</var>
  is 0, set <var>start offset</var> to the [[index]] of <var>start node</var>,
  then set <var>start node</var> to its [[parent]].

  <li>If <var>end node</var> is a [[text]] node and <var>end offset</var> is
  its [[nodelength]], set <var>end offset</var> to one plus the [[index]] of
  <var>end node</var>, then set <var>end node</var> to its [[parent]].

  <li>Set <var>range</var>'s [[rangestart]] to (<var>start node</var>,
  <var>start offset</var>) and its [[rangeend]] to (<var>end node</var>,
  <var>end offset</var>).

  <!--
  When we delete a selection that spans multiple blocks, we merge the end
  block's contents into the start block, like

    <p>fo[o</p><pre>b]ar</pre>
    -> <p>fo[]ar</p>.

  Figure out what the start and end blocks are before we start deleting
  anything.
  -->
  <li>Let <var>start block</var> be the [[rangestart]] [[bpnode]] of
  <var>range</var>.

  <li>While <var>start block</var>'s [[parent]] is <span>in the same editing
  host</span> and <var>start block</var> is an <span>inline node</span>, set
  <var>start block</var> to its [[parent]].

  <li>If <var>start block</var> is neither a <span>block node</span> nor an
  <span>editing host</span>, or "span" is not an <span>allowed child</span> of
  <var>start block</var>, or <var>start block</var> is a [[td]] or [[th]], set
  <var>start block</var> to null.
  <!--
  We only merge to or from block nodes or editing hosts.  (This is just in case
  someone makes a span into an editing host and sticks paragraphs inside it or
  something . . . we could probably drop that proviso.)  Firefox 7.0a2 ignores
  the display property when merging, so it doesn't merge <span
  style=display:block> but does merge <p style=display:inline>.  This is
  undesirable, because it's visually wrong.  IE10PP2 and Chrome 14 dev behave
  more like the spec, and Opera 11.50 seems to be unable to make up its mind.

  If span isn't an allowed child, it's probably something unpleasant like a
  table row or a list or such.  We don't want to merge to or from something
  like that, because we'd most likely wind up with the wrong type of child
  somewhere.  It should be pretty hard for this to happen given the
  normalization we do on the selection; I'm not actually sure how it could
  happen at all, actually, unless you start out with a DOM that has non-allowed
  children someplace.  So it's basically a sanity check.

  We don't let either start block or end block be a td or th.  This means we'll
  never merge to or from a td or th.  This matches Firefox 5.0a2, and
  reportedly Word as well.  Chrome 13 dev and Opera 11.11 allow merging from a
  non-table cell end block to a table cell start block, but not vice versa.  In
  IE9 the delete key just does nothing.
  -->

  <li>Let <var>end block</var> be the [[rangeend]] [[bpnode]] of
  <var>range</var>.

  <li>While <var>end block</var>'s [[parent]] is <span>in the same editing
  host</span> and <var>end block</var> is an <span>inline node</span>, set
  <var>end block</var> to its [[parent]].

  <li>If <var>end block</var> is neither a <span>block node</span> nor an
  <span>editing host</span>, or "span" is not an <span>allowed child</span> of
  <var>end block</var>, or <var>end block</var> is a [[td]] or [[th]], set
  <var>end block</var> to null.

  <li><span>Record current states and values</span>, and let
  <var>overrides</var> be the result.
  <!--
  As far as I can tell, IE9 and Opera 11.50 don't do this at all.  If you
  delete a selection and then start typing, the new text doesn't take on the
  styles of the old text.

  Firefox 7.0a2 seems to do it for some styles but not others.  Strikethrough,
  superscript, subscript, and links seem to be lost, at a minimum.

  The spec goes with something like Chrome 14 dev, which tries to preserve lots
  of stuff.
  -->

  <!-- This is based on deleteContents() in DOM Range. -->
  <li>If <var>start node</var> and <var>end node</var> are the same, and
  <var>start node</var> is an <span>editable</span> [[text]] node:

  <ol>
    <li>Call [[deletedata|<var>start offset</var>, <var>end offset</var>
    &minus; <var>start offset</var>]] on <var>start node</var>.

    <li><span>Canonicalize whitespace</span> at (<var>start node</var>,
    <var>start offset</var>).

    <li>Set <var>range</var>'s [[rangeend]] to its [[rangestart]].

    <li><span>Restore states and values</span> from <var>overrides</var>.
    <!-- This is needed to restore any overrides that would otherwise be lost.
    TODO: In this and similar cases, we could optimize by saving only
    overrides, not the full state/value. -->

    <li>Abort these steps.
  </ol>

  <li>If <var>start node</var> is an <span>editable</span> [[text]] node, call
  [[deletedata|]] on it, with <var>start offset</var> as the first argument and
  ([[nodelength]] of <var>start node</var> &minus; <var>start offset</var>) as
  the second argument.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each <var>node</var> [[contained]] in <var>range</var>, append
  <var>node</var> to <var>node list</var> if the last member of <var>node
  list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is <span>editable</span>; and <var>node</var> is not a
  [[thead]], [[tbody]], [[tfoot]], [[tr]], [[th]], or [[td]].
  <!--
  IE9 doesn't seem to let you do any intercell deletions: the delete key does
  nothing if you select across multiple cells.  Firefox 5.0a2 and Opera 11.11
  behave as the spec says, not removing any table things.  Chrome 13 dev will
  remove entire rows if selected.  Note that IE, Firefox, Word 2007, and
  OpenOffice.org 3.2.1 Ubuntu all switch to a magic cell-selection mode when
  you try to select between cells, at least in some cases, instead of selecting
  letter-by-letter.
  -->

  <li>For each <var>node</var> in <var>node list</var>:

  <ol>
    <li>Let <var>parent</var> be the [[parent]] of <var>node</var>.

    <li>Remove <var>node</var> from <var>parent</var>.

    <li>If <var>strip wrappers</var> is true or <var>parent</var> is not an
    [[ancestorcontainer]] of <var>start node</var>, while <var>parent</var> is
    an <span>editable</span> <span>inline node</span> with [[nodelength]] 0,
    let <var>grandparent</var> be the [[parent]] of <var>parent</var>, then
    remove <var>parent</var> from <var>grandparent</var>, then set
    <var>parent</var> to <var>grandparent</var>.
    <!--
    Taking insertText to test the case where strip wrappers is false, with
    value a: <p>[foo<b>bar</b>]baz becomes <p>a[]baz per spec, in IE9, and in
    Chrome 14 dev.  Firefox 7.0a2 and Opera 11.50 make it <p>a[]<b></b>baz,
    with a useless wrapper.  <p>foo<b>[bar</b>baz] becomes <p>foo<b>a[]</b> per
    spec and in IE9 and Firefox 7.0a2 and Opera 11.50; in Chrome 14 dev
    apparently it initially becomes <p>fooa[], but then the style is recreated.
    This is detectable if you do something weird like <span
    style=color:#aBcDeF> instead of <b>: it comes <font class=Apple-style-span
    color=#abcdef> or such.  I follow IE9 in all cases, because it makes the
    most sense.
    -->

    <li>If <var>parent</var> is <span>editable</span> or an <span>editing
    host</span>, is not an <span>inline node</span>, and has no [[children]],
    call [[createelement|"br"]] on the [[contextobject]] and append the result
    as the last [[child]] of <var>parent</var>.
  </ol>

  <li>If <var>end node</var> is an <span>editable</span> [[text]] node, call
  [[deletedata|0, <var>end offset</var>]] on it.

  <li><span>Canonicalize whitespace</span> at <var>range</var>'s
  [[rangestart]].

  <li><span>Canonicalize whitespace</span> at <var>range</var>'s [[rangeend]].

  <!--
  Now we need to merge blocks.  The simplest case is something like

    <p>fo[o</p><p>bar</p><p>b]az</p>
    -> <p>fo</p>{}<p>az</p>
    -> <p>fo{}az</p>

  where neither block descends from the other.  More complicated is something
  like

    foo[<p>]bar</p>
    -> foo[]bar

  or

    <p>foo[</p>]bar
    -> <p>foo[]bar</p>

  where one descends from the other.
  -->

  <li>If <var>block merging</var> is false, or <var>start block</var> or
  <var>end block</var> is null, or <var>start block</var> is not <span>in the
  same editing host</span> as <var>end block</var>, or <var>start block</var>
  and <var>end block</var> are the same:

  <ol>
    <li>Set <var>range</var>'s [[rangeend]] to its [[rangestart]].

    <li><span>Restore states and values</span> from <var>overrides</var>.

    <li>Abort these steps.
  </ol>

  <!--
  We might have added a br to the start/end block in an earlier step.  Now
  we're about to merge the blocks, and we don't want the br's to get in the
  way.  The end block is being destroyed no matter what.  If the start block
  winds up empty after merging, we'll add a new br child at the end so it
  doesn't collapse.
  -->
  <li>If <var>start block</var> has one [[child]], which is a <span>collapsed
  block prop</span>, remove its [[child]] from it.

  <li>If <var>end block</var> has one [[child]], which is a <span>collapsed
  block prop</span>, remove its [[child]] from it.

  <li>If <var>start block</var> is an [[ancestor]] of <var>end block</var>:
  <!-- Just repeatedly blow up the end block. -->

  <ol>
    <li>Let <var>reference node</var> be <var>end block</var>.

    <li>While <var>reference node</var> is not a [[child]] of <var>start
    block</var>, set <var>reference node</var> to its [[parent]].

    <li>Set the [[rangestart]] and [[rangeend]] of <var>range</var> to
    (<var>start block</var>, [[index]] of <var>reference node</var>).

    <li>If <var>end block</var> has no [[children]]:

    <ol>
      <li>While <var>end block</var> is <span>editable</span> and is the only
      [[child]] of its [[parent]] and is not a [[child]] of <var>start
      block</var>, let <var>parent</var> equal <var>end block</var>, then
      remove <var>end block</var> from <var>parent</var>, then set <var>end
      block</var> to <var>parent</var>.

      <li>If <var>end block</var> is <span>editable</span> and is not an
      <span>inline node</span>, and its [[previoussibling]] and [[nextsibling]]
      are both <span title="inline node">inline nodes</span>, call
      [[createelement|"br"]] on the [[contextobject]] and insert it into
      <var>end block</var>'s [[parent]] immediately after <var>end block</var>.

      <li>If <var>end block</var> is <span>editable</span>, remove it from its
      [[parent]].

      <li><span>Restore states and values</span> from <var>overrides</var>.

      <li>Abort these steps.
    </ol>

    <li>If <var>end block</var>'s [[firstchild]] is not an <span>inline
    node</span>, <span>restore states and values</span> from <var>record</var>,
    then abort these steps.

    <li>Let <var>children</var> be a list of [[nodes]], initially empty.

    <li>Append the first [[child]] of <var>end block</var> to
    <var>children</var>.

    <li>While <var>children</var>'s last member is not a [[br]], and
    <var>children</var>'s last member's [[nextsibling]] is an <span>inline
    node</span>, append <var>children</var>'s last member's [[nextsibling]] to
    <var>children</var>.

    <li><span>Record the values</span> of <var>children</var>, and let
    <var>values</var> be the result.

    <li>While <var>children</var>'s first member's [[parent]] is not <var>start
    block</var>, <span>split the parent</span> of <var>children</var>.

    <li>If <var>children</var>'s first member's [[previoussibling]] is an
    <span>editable</span> [[br]], remove that [[br]] from its [[parent]].
  </ol>

  <li>Otherwise, if <var>start block</var> is a [[descendant]] of <var>end
  block</var>:
  <!-- Pull in everything that comes after <var>start block</var>, until we hit
  a br or block node. -->

  <ol>
    <li>Set the [[rangestart]] and [[rangeend]] of <var>range</var> to
    (<var>start block</var>, [[nodelength]] of <var>start block</var>).

    <li>Let <var>reference node</var> be <var>start block</var>.

    <li>While <var>reference node</var> is not a [[child]] of <var>end
    block</var>, set <var>reference node</var> to its [[parent]].

    <li>If <var>reference node</var>'s [[nextsibling]] is an <span>inline
    node</span> and <var>start block</var>'s [[lastchild]] is a [[br]], remove
    <var>start block</var>'s [[lastchild]] from it.

    <li>Let <var>nodes to move</var> be a list of [[nodes]], initially empty.

    <li>If <var>reference node</var>'s [[nextsibling]] is neither null nor a
    [[br]] nor a <span>block node</span>, append it to <var>nodes to
    move</var>.

    <li>While <var>nodes to move</var> is nonempty and its last member's
    [[nextsibling]] is neither null nor a [[br]] nor a <span>block node</span>,
    append it to <var>nodes to move</var>.

    <li><span>Record the values</span> of <var>nodes to move</var>, and let
    <var>values</var> be the result.

    <li>For each <var>node</var> in <var>nodes to move</var>, append
    <var>node</var> as the last [[child]] of <var>start block</var>,
    <span>preserving ranges</span>.

    <li>If the [[nextsibling]] of <var>reference node</var> is a [[br]], remove
    it from its [[parent]].
  </ol>

  <li>Otherwise:
  <!-- In the last case, just move all the children of the end block to the
  start block, and then get rid of any elements we emptied that way. -->

  <ol>
    <li>Set the [[rangestart]] and [[rangeend]] of <var>range</var> to
    (<var>start block</var>, [[nodelength]] of <var>start block</var>).

    <li>If <var>end block</var>'s [[firstchild]] is an <span>inline node</span>
    and <var>start block</var>'s [[lastchild]] is a [[br]], remove <var>start
    block</var>'s [[lastchild]] from it.

    <li><span>Record the values</span> of <var>end block</var>'s [[children]],
    and let <var>values</var> be the result.

    <li>While <var>end block</var> has [[children]], append the first [[child]]
    of <var>end block</var> to <var>start block</var>, <span>preserving
    ranges</span>.

    <li>While <var>end block</var> has no [[children]], let <var>parent</var> be
    the [[parent]] of <var>end block</var>, then remove <var>end block</var> from
    <var>parent</var>, then set <var>end block</var> to <var>parent</var>.
  </ol>

  <li><span>Restore the values</span> from <var>values</var>.

  <li>If <var>start block</var> has no [[children]], call
  [[createelement|"br"]] on the [[contextobject]] and append the result as the
  last [[child]] of <var>start block</var>.

  <li><span>Restore states and values</span> from <var>overrides</var>.
</ol>

<!-- @} -->
<h3>Splitting a node list's parent</h3>
<!-- @{ -->
<p>To <dfn>split the parent</dfn> of a list <var>node list</var> of consecutive
[[sibling]] [[nodes]]:

<ol>
  <li>Let <var>original parent</var> be the [[parent]] of the first member of
  <var>node list</var>.

  <li>If <var>original parent</var> is not <span>editable</span> or its
  [[parent]] is null, do nothing and abort these steps.

  <li>If the first [[child]] of <var>original parent</var> is in <var>node
  list</var>, <span>remove extraneous line breaks before</span> <var>original
  parent</var>.

  <li>If the first [[child]] of <var>original parent</var> is in <var>node
  list</var>, and <var>original parent</var> <span>follows a line break</span>,
  set <var>follows line break</var> to true.  Otherwise, set <var>follows line
  break</var> to false.

  <li>If the last [[child]] of <var>original parent</var> is in <var>node
  list</var>, and <var>original parent</var> <span>precedes a line
  break</span>, set <var>precedes line break</var> to true.  Otherwise, set
  <var>precedes line break</var> to false.

  <li>If the first [[child]] of <var>original parent</var> is not in <var>node
  list</var>, but its last [[child]] is:
  <!--
  TODO: We insert things after the parent.  This is bad, because it will cause
  them to become part of any ranges that immediately follow.  For instance, if
  we're hitting "bar" in
    <div><p>foo<p>bar</div>{<p>baz}
  it becomes
    <div><p>foo</div>{<p>bar<p>baz}
  instead of
    <div><p>foo</div><p>bar{<p>baz}
  because of how range mutation rules work.  This doesn't happen if we insert
  before.  This may or may not be important enough to bother working around.
  -->

  <ol>
    <li>For each <var>node</var> in <var>node list</var>, <em>in reverse
    order</em>, insert <var>node</var> into the [[parent]] of <var>original
    parent</var> immediately after <var>original parent</var>, <span>preserving
    ranges</span>.

    <li>If <var>precedes line break</var> is true, and the last member of
    <var>node list</var> does not <span title="precedes a line break">precede a
    line break</span>, call [[createelement|"br"]] on the [[contextobject]] and
    insert the result immediately after the last member of <var>node
    list</var>.

    <li><span>Remove extraneous line breaks at the end of</span> <var>original
    parent</var>.

    <li>Abort these steps.
  </ol>

  <li>If the first [[child]] of <var>original parent</var> is not in <var>node
  list</var>:

  <ol>
    <li>Let <var>cloned parent</var> be the result of calling <code
    data-anolis-spec=domcore title=dom-Node-cloneNode>cloneNode(false)</code>
    on <var>original parent</var>.

    <li>If <var>original parent</var> has an [[id]] attribute, unset it.

    <li>Insert <var>cloned parent</var> into the [[parent]] of <var>original
    parent</var> immediately before <var>original parent</var>.

    <li>While the [[previoussibling]] of the first member of <var>node
    list</var> is not null, append the first [[child]] of <var>original
    parent</var> as the last [[child]] of <var>cloned parent</var>,
    <span>preserving ranges</span>.
  </ol>

  <li>For each <var>node</var> in <var>node list</var>, insert <var>node</var>
  into the [[parent]] of <var>original parent</var> immediately before
  <var>original parent</var>, <span>preserving ranges</span>.
  <!-- Notice that a boundary point that was immediately before the element
  will now be immediately before its children, just because of the regular
  range mutation rules, without needing to worry about preserving ranges.
  Likewise for boundary points immediately after the element, if we wind up
  removing the element in the final step.  Preserving ranges is only necessary
  for the sake of boundary points in the element or its descendants. -->

  <li>If <var>follows line break</var> is true, and the first member of
  <var>node list</var> does not <span title="follows a line break">follow a
  line break</span>, call [[createelement|"br"]] on the [[contextobject]] and
  insert the result immediately before the first member of <var>node
  list</var>.

  <li>If the last member of <var>node list</var> is an <span>inline node</span>
  other than a [[br]], and the first [[child]] of <var>original parent</var> is
  a [[br]], and <var>original parent</var> is not an <span>inline node</span>,
  remove the first [[child]] of <var>original parent</var> from <var>original
  parent</var>.

  <li>If <var>original parent</var> has no [[children]]:

  <ol>
    <li>Remove <var>original parent</var> from its [[parent]].

    <li>If <var>precedes line break</var> is true, and the last member of
    <var>node list</var> does not <span title="precedes a line break">precede a
    line break</span>, call [[createelement|"br"]] on the [[contextobject]] and
    insert the result immediately after the last member of <var>node
    list</var>.
  </ol>

  <li>Otherwise, <span>remove extraneous line breaks before</span>
  <var>original parent</var>.

  <li>If <var>node list</var>'s last member's [[nextsibling]] is null,
  but its [[parent]] is not null, <span>remove extraneous line breaks at the
  end of</span> <var>node list</var>'s last member's [[parent]].
  <!-- The parent might be null if it's a br that we removed in the last step,
  in which case this step isn't necessary. -->
</ol>

<p>To remove a [[node]] <var>node</var> while <dfn>preserving its
descendants</dfn>, <span>split the parent</span> of <var>node</var>'s
[[children]] if it has any.  If it has no [[children]], instead remove it from
its [[parent]].

<!-- @} -->
<h3>Canonical space sequences</h3>
<!-- @{ -->
<p>The <dfn>canonical space sequence</dfn> of length <var>n</var>, with boolean
flags <var>non-breaking start</var> and <var>non-breaking end</var>, is
returned by the following algorithm:
<!-- See long comment before insertText. -->

<ol>
  <li>If <var>n</var> is zero, return the empty string.

  <li>If <var>n</var> is one and both <var>non-breaking start</var> and
  <var>non-breaking end</var> are false, return a single space (U+0020).

  <li>If <var>n</var> is one, return a single non-breaking space (U+00A0).

  <li>Let <var>buffer</var> be the empty string.

  <li>If <var>non-breaking start</var> is true, let <var>repeated pair</var> be
  U+00A0 U+0020.  Otherwise, let it be U+0020 U+00A0.

  <li>While <var>n</var> is greater than three, append <var>repeated pair</var>
  to <var>buffer</var> and subtract two from <var>n</var>.

  <li>If <var>n</var> is three, append a three-[[strel]] string to
  <var>buffer</var> depending on <var>non-breaking start</var> and
  <var>non-breaking end</var>:

  <dl class=switch>
    <dt><var>non-breaking start</var> and <var>non-breaking end</var> false
    <dd>U+0020 U+00A0 U+0020

    <dt><var>non-breaking start</var> true, <var>non-breaking end</var> false
    <dd>U+00A0 U+00A0 U+0020

    <dt><var>non-breaking start</var> false, <var>non-breaking end</var> true
    <dd>U+0020 U+00A0 U+00A0

    <dt><var>non-breaking start</var> and <var>non-breaking end</var> both true
    <dd>U+00A0 U+0020 U+00A0
  </dl>

  <li>Otherwise, append a two-[[strel]] string to <var>buffer</var> depending
  on <var>non-breaking start</var> and <var>non-breaking end</var>:

  <dl class=switch>
    <dt><var>non-breaking start</var> and <var>non-breaking end</var> false
    <dt><var>non-breaking start</var> true, <var>non-breaking end</var> false
    <dd>U+00A0 U+0020

    <dt><var>non-breaking start</var> false, <var>non-breaking end</var> true
    <dd>U+0020 U+00A0

    <dt><var>non-breaking start</var> and <var>non-breaking end</var> both true
    <dd>U+00A0 U+00A0
  </dl>

  <li>Return <var>buffer</var>.
</ol>

<p>To <dfn>canonicalize whitespace</dfn> at (<var>node</var>,
<var>offset</var>):

<ol>
  <li>If <var>node</var> is neither <span>editable</span> nor an <span>editing
  host</span>, abort these steps.

  <li>Let <var>start node</var> equal <var>node</var> and let <var>start
  offset</var> equal <var>offset</var>.

  <!-- First go to the beginning of the current whitespace run. -->
  <li>Repeat the following steps:

  <ol>
    <li>If <var>start node</var> has a [[child]] <span>in the same editing
    host</span> with [[index]] <var>start offset</var> minus one, set
    <var>start node</var> to that [[child]], then set <var>start offset</var>
    to <var>start node</var>'s [[length]].

    <li>Otherwise, if <var>start offset</var> is zero and <var>start node</var>
    does not <span title="follows a line break">follow a line break</span> and
    <var>start node</var>'s [[parent]] is <span>in the same editing
    host</span>, set <var>start offset</var> to <var>start node</var>'s
    [[index]], then set <var>start node</var> to its [[parent]].
    <!-- TODO: Following a line break is unlikely to be the right criterion.
    -->

    <li>Otherwise, if <var>start node</var> is a [[text]] node and its
    [[parent]]'s [[resval]] for "white-space" is neither "pre" nor "pre-wrap"
    and <var>start offset</var> is not zero and the (<var>start offset</var>
    &minus; 1)st [[strel]] of <var>start node</var>'s [[cddata]] is a space
    (0x0020) or non-breaking space (0x00A0), subtract one from <var>start
    offset</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <!-- Now collapse any consecutive spaces. -->
  <li>Let <var>end node</var> equal <var>start node</var> and <var>end
  offset</var> equal <var>start offset</var>.

  <li>Let <var>length</var> equal zero.

  <li>Let <var>follows space</var> be false.

  <li>Repeat the following steps:

  <ol>
    <li>If <var>end node</var> has a [[child]] <span>in the same editing
    host</span> with [[index]] <var>end offset</var>, set <var>end node</var>
    to that [[child]], then set <var>end offset</var> to zero.

    <li>Otherwise, if <var>end offset</var> is <var>end node</var>'s [[length]]
    and <var>end node</var> does not <span title="precedes a line
    break">precede a line break</span> and <var>end node</var>'s [[parent]] is
    <span>in the same editing host</span>, set <var>end offset</var> to one
    plus <var>end node</var>'s [[index]], then set <var>end node</var> to its
    [[parent]].
    <!-- TODO: Preceding a line break is unlikely to be the right criterion.
    -->

    <li>Otherwise, if <var>end node</var> is a [[text]] node and its
    [[parent]]'s [[resval]] for "white-space" is neither "pre" nor "pre-wrap"
    and <var>end offset</var> is not <var>end node</var>'s [[length]] and the
    <var>end offset</var>th [[strel]] of <var>end node</var>'s [[cddata]] is a
    space (0x0020) or non-breaking space (0x00A0):

    <ol>
      <li>If <var>follows space</var> is true and the <var>end offset</var>th
      [[strel]] of <var>end node</var>'s [[cddata]] is a space (0x0020), call
      [[deletedata|<var>end offset</var>, 1]] on <var>end node</var>, then
      continue this loop from the beginning.

      <li>Set <var>follows space</var> to true if the <var>end offset</var>th
      [[strel]] of <var>end node</var>'s [[cddata]] is a space (0x0020), false
      otherwise.

      <li>Add one to <var>end offset</var>.

      <li>Add one to <var>length</var>.
    </ol>

    <li>Otherwise, break from this loop.
  </ol>

  <!-- Now replace with the canonical sequence. -->
  <li>Let <var>replacement whitespace</var> be the <span>canonical space
  sequence</span> of length <var>length</var>.  <var>non-breaking start</var>
  is true if <var>start offset</var> is zero and <var>start node</var>
  <span>follows a line break</span>, and false otherwise.  <var>non-breaking
  end</var> is true if <var>end offset</var> is <var>end node</var>'s
  [[cdlength]] and <var>end node</var> <span>precedes a line break</span>, and
  false otherwise.

  <li>While (<var>start node</var>, <var>start offset</var>) is [[bpbefore]]
  (<var>end node</var>, <var>end offset</var>):

  <ol>
    <li>If <var>start node</var> has a [[child]] with [[index]] <var>start
    offset</var>, set <var>start node</var> to that [[child]], then set
    <var>start offset</var> to zero.

    <li>Otherwise, if <var>start node</var> is not a [[text]] node or if
    <var>start offset</var> is <var>start node</var>'s [[length]], set
    <var>start offset</var> to one plus <var>start node</var>'s [[index]], then
    set <var>start node</var> to its [[parent]].

    <li>Otherwise:

    <ol>
      <li>Remove the first [[strel]] from <var>replacement whitespace</var>,
      and let <var>element</var> be that [[strel]].

      <li>If <var>element</var> is not the same as the <var>start
      offset</var>th [[strel]] of <var>start node</var>'s [[cddata]]:

      <ol>
        <!-- We need to insert then delete, so that we don't change range
        boundary points. -->
        <li>Call [[insertdata|<var>start offset</var>, <var>element</var>]] on
        <var>start node</var>.

        <li>Call [[deletedata|<var>start offset</var> + 1, 1]] on
        <var>start node</var>.
      </ol>

      <li>Add one to <var>start offset</var>.
    </ol>
  </ol>
</ol>

<!-- @} -->
<h3>Indenting and outdenting</h3>
<!-- @{ -->
<p>To <dfn>indent</dfn> a list <var>node list</var> of consecutive [[sibling]]
[[nodes]]:
<!--
We have to handle entire lists of siblings at once, or else we'd wind up doing
something like

  <ol>
    {<li>foo</li>
    <ol><li>bar</li></ol>}
  </ol>
  ->
  <ol><ol>
    <li>foo</li>
    <li>bar</li>
  </ol></ol>
  ->
  <ol><ol><ol>
    <li>foo</li>
    <li>bar</li>
  </ol></ol></ol>

since by the time we got to doing the <ol> that originally contained "bar", we
won't remember that we aren't supposed to indent "foo" a second time.
-->
<ol>
  <li>If <var>node list</var> is empty, do nothing and abort these steps.

  <li>Let <var>first node</var> be the first member of <var>node list</var>.

  <li>If <var>first node</var>'s [[parent]] is an [[ol]] or [[ul]]:

  <ol>
    <li>Let <var>tag</var> be the [[localname]] of the [[parent]] of
    <var>first node</var>.

    <li><span>Wrap</span> <var>node list</var>, with <span>sibling
    criteria</span> matching only <span title="HTML element">HTML
    elements</span> with [[localname]] <var>tag</var> and <span>new parent
    instructions</span> returning the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createElement>createElement(<var>tag</var>)</code> on
    the [[ownerdocument]] of <var>first node</var>.
    <!--
    This matches IE9, Firefox 4.0, and Chrome 12 dev.  If there's a preceding
    <li>, Opera 11.10 instead adds the new parent to the end of that <li>, so
    it's not the child of another list, which is invalid.  But the other
    browsers' way of doing things makes things simpler.  E.g., if we want to
    indent an <li> and it has <ol>/<ul> children, we have to distinguish
    between the case where we want to indent the whole <li> or only the first
    part.  It also allows things like

      <ol><li>
        foo
        <ol><li>bar</li></ol>
        baz
      </li></ol>

    in which case it's unclear what we should do if the user selects "foo" and
    indents.  I've filed a bug on HTML5:

    http://www.w3.org/Bugs/Public/show_bug.cgi?id=12609
    -->

    <li>Abort these steps.
  </ol>

  <!--
  Firefox 4.0 respects the CSS styling flag for indent, but Chrome 12 dev does
  not.  I always produce blockquotes, even if CSS styling is on, for two
  reasons.  One, IE9 handles inline margin attributes badly: when outdenting,
  it propagates the margin to the parent, which doesn't actually remove it.
  Two, in CSS mode I'd want to use <div style="margin: 1em 40px"> to match
  non-CSS mode, but authors are very likely to want to remove the top/bottom
  margin, which they can't do if it's not a special tag.  Authors who really
  want divs for indentation could always convert the blockquotes to divs
  themselves.  But if people really want it, I could respect CSS styling mode
  here too.

  The top/bottom margins might be undesirable here, but no more so than for
  <ol>/<ul>/<p>/etc.  Here as there, authors can remove them with CSS if they
  want.
  -->

  <li><span>Wrap</span> <var>node list</var>, with <span>sibling
  criteria</span> matching any <span>simple indentation element</span>, and
  <span>new parent instructions</span> to return the result of calling <code
  data-anolis-spec=domcore
  title=dom-Document-createElement>createElement("blockquote")</code> on the
  [[ownerdocument]] of <var>first node</var>.  Let <var>new parent</var> be the
  result.
  <!--
  This indents on both sides, so we don't have to worry about directionality.
  In theory it would be better if we indented only on the start side, but that
  requires care to get right in mixed-direction cases.  Even once browsers
  start to support margin-start and so on, we can't use them because a) we have
  to work okay in legacy browsers and b) it doesn't help if a descendant block
  has different direction (so should be indented the other way).  So let's not
  worry about it: most browsers don't, and the ones that do get it wrong.  Just
  indent on both sides.
  -->

  <li><span>Fix disallowed ancestors</span> of <var>new parent</var>.
</ol>

<p>To <dfn>outdent</dfn> a [[node]] <var>node</var>:

<!--
Things that are produced for indentation that we need to consider removing:

* Plain <blockquote> (produced by spec, Firefox 4.0 non-CSS, Opera 11.00)
* <blockquote style="margin-right: 0" dir="ltr"> and <blockquote
  style="margin-left: 0" dir="rtl"> (IE9)
* <blockquote class="webkit-indent-blockquote" style="margin: 0 0 0 40px;
  border: none; padding: 0px"> (Chrome 12 dev)
* <div style="margin-left: 40px"> and <div style="margin-right: 40px">
  (Firefox 4.0 CSS if no other element available)
* Other random things with display: block whose left or right margin was
  increased by 40px (Firefox 4.0 CSS)

For discussion on the list-related stuff, see the comment for
insertOrderedList.
-->
<ol>
  <li>If <var>node</var> is not <span>editable</span>, abort these steps.

  <!-- The easy case is when the whole element is indented.  In this case we
  remove the whole thing indiscriminately.  In the case of blockquotes
  created by IE, this might change the direction of some children, but then
  their direction was probably changed incorrectly in the first place, so no
  harm. -->
  <li>If <var>node</var> is a <span>simple indentation element</span>, remove
  <var>node</var>, <span>preserving its descendants</span>.  Then abort these
  steps.

  <!--
  Gecko in CSS mode just adds margin properties to random elements that are
  lying around.  We don't attempt to remove those, because 1) the amount and
  position of the margin can vary (it increases the margin if there's a
  preexisting one), so it's potentially complicated, and 2) no browser removes
  such margins on outdent, including Gecko, except for Gecko in CSS mode.

  TODO: Consider removing it anyway.
  -->

  <li>If <var>node</var> is an <span>indentation element</span>:
  <!-- This might be a simple indentation element that had style added to it by
  Firefox in CSS mode, for instance (color, font-family, etc.). -->

  <ol>
    <li>Unset the <code data-anolis-spec=html title=classes>class</code> and
    <code data-anolis-spec=html title="the dir attribute">dir</code>
    attributes of <var>node</var>, if any.

    <li>Unset the margin, padding, and border CSS properties of
    <var>node</var>.

    <li><span>Set the tag name</span> of <var>node</var> to "div".

    <li>Abort these steps.
  </ol>

  <!-- Approximate algorithms when an ancestor is causing the indentation
  appear to be:

  IE9: Go to the innermost element causing indentation.  If the stuff to be
    outdented includes all the contents of that element, get rid of it, but
    if it has any attributes, change it to a <p> with those same attributes.
    This is an excellent idea in general, but unfortunately it preserves
    explicitly-specified margins in style attributes, which isn't great.  In
    other cases, it moves the stuff to be outdented outside.  Not clear on
    all the details, seems to be pretty confusing.  Also does a bunch of
    seemingly arbitrary normalization like removing divs and some attributes
    from some things . . .
  Firefox 4.0: Go to the innermost element causing indentation.  If the stuff
    to be outdented includes all the contents of that element, get rid of it,
    even if it has arbitrary attributes.  Otherwise, move the stuff to be
    outdented outside the indenting element.  If there are any intervening
    elements that include stuff not to be outdented, wrap the outdented stuff
    in copies (which can duplicate id's, etc.).
  Chrome 12 dev: Go to the outermost element causing indentation (even if the
    current element is itself causing indentation).  Move the text to be
    outdented outside that outermost element, without regard to any
    intervening elements.  Then recreate the original styles on the moved
    text, in some fashion.  Something like that; it confuses me and doesn't
    seem to be reasonable.
  Opera 11.00: Like Firefox, except it goes to the outermost element, not the
    innermost.  Also seems to special-case to avoid duplicate id's, and has a
    few other quirks.

  Overall, all flawed, so I'll make up my own, patterned after pushing down
  styles.  First we search ancestors for an indentation element, which we stand
  a chance of completely removing.  Failing that, we look for an indentation
  element, which we cannot completely remove. -->
  <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

  <li>Let <var>ancestor list</var> be a list of [[nodes]], initially empty.

  <li>While <var>current ancestor</var> is an <span>editable</span> [[element]]
  that is neither a <span>simple indentation element</span> nor an [[ol]] nor a
  [[ul]], append <var>current ancestor</var> to <var>ancestor list</var> and
  then set <var>current ancestor</var> to its [[parent]].

  <li>If <var>current ancestor</var> is not an <span>editable</span>
  <span>simple indentation element</span>:

  <ol>
    <li>Let <var>current ancestor</var> be <var>node</var>'s [[parent]].

    <li>Let <var>ancestor list</var> be the empty list.

    <li>While <var>current ancestor</var> is an <span>editable</span>
    [[element]] that is neither an <span>indentation element</span> nor an
    [[ol]] nor a [[ul]], append <var>current ancestor</var> to <var>ancestor
    list</var> and then set <var>current ancestor</var> to its [[parent]].
  </ol>

  <li>If <var>node</var> is an [[ol]] or [[ul]] and <var>current ancestor</var>
  is not an <span>editable</span> <span>indentation element</span>:
  <!--
  When asked to outdent a list wrapped in a simple indentation element, Chrome
  12 dev removes the list instead of the simple indentation element.  Opera
  11.10 seems to remove both.  IE9 and Firefox 4.0 remove the simple
  indentation element, as does the spec.
  -->

  <ol>
    <li>Unset the <code data-anolis-spec=html
    title=attr-ol-reversed>reversed</code>, <code data-anolis-spec=html
    title=attr-ol-start>start</code>, and <code data-anolis-spec=html
    title=attr-ol-type>type</code> attributes of <var>node</var>, if any are
    set.

    <li>Let <var>children</var> be the [[children]] of <var>node</var>.

    <li>If <var>node</var> has attributes, and its [[parent]] is not an [[ol]]
    or [[ul]], <span>set the tag name</span> of <var>node</var> to "div".
    <!--
    We can't turn it into a div if it's the child of an ol or ul, because
    that's not currently allowed.  TODO: change this if
    http://www.w3.org/Bugs/Public/show_bug.cgi?id=13128 is fixed and we can
    make it a div.
    -->

    <li>Otherwise:

    <ol>
      <li><span>Record the values</span> of <var>node</var>'s [[children]], and
      let <var>values</var> be the result.

      <li>Remove <var>node</var>, <span>preserving its descendants</span>.

      <li><span>Restore the values</span> from <var>values</var>.
    </ol>

    <li><span>Fix disallowed ancestors</span> of each member of
    <var>children</var>.

    <li>Abort these steps.
  </ol>

  <li>If <var>current ancestor</var> is not an <span>editable</span>
  <span>indentation element</span>, abort these steps.

  <!-- At this point, we have an ancestor to split up. -->
  <li>Append <var>current ancestor</var> to <var>ancestor list</var>.

  <li>Let <var>original ancestor</var> be <var>current ancestor</var>.
  <!-- We can't outdent it yet, because we need its children to remain intact
  for the loop. -->

  <li>While <var>ancestor list</var> is not empty:

  <ol>
    <li>Let <var>current ancestor</var> be the last member of <var>ancestor
    list</var>.

    <li>Remove the last member from <var>ancestor list</var>.

    <li>Let <var>target</var> be the [[child]] of <var>current ancestor</var>
    that is equal to either <var>node</var> or the last member of <var>ancestor
    list</var>.

    <li>If <var>target</var> is an <span>inline node</span> that is not a
    [[br]], and its [[nextsibling]] is a [[br]], remove <var>target</var>'s
    [[nextsibling]] from its [[parent]].

    <li>Let <var>preceding siblings</var> be the [[precedingsiblings]] of
    <var>target</var>, and let <var>following siblings</var> be the
    [[followingsiblings]] of <var>target</var>.

    <li><span>Indent</span> <var>preceding siblings</var>.

    <li><span>Indent</span> <var>following siblings</var>.
  </ol>

  <li><span>Outdent</span> <var>original ancestor</var>.
</ol>

<!-- @} -->
<h3>Toggling lists</h3>
<!-- @{ -->
<!--
Research for insertOrderedList/insertUnorderedList: tested the following
command sequences in IE9, Firefox 4.0, Chrome 12 dev, Opera 11.10,
OpenOffice.org 3.2.1 Ubuntu package, Microsoft Office Word 2007.  The commands
"ol", "ul", "indent", "outdent" correspond in browsers to "insertOrderedList",
"insertUnorderedList", "indent", and "outdent"; in OO.org to "Numbering
On/Off", "Bullets On/Off", "Increase Indent", "Decrease Indent"; and in Word to
"Numbering", "Bullets", "Increase Indent", "Decrease Indent".

Note: OO has a bunch of extra options, like "Promote One Level", "Demote One
Level", "Promote One Level With Subpoints", "Demote One Level With Subpoints",
"Insert Unnumbered Entry", "Restart Numbering".  The regular "Increase/Decrease
Indent" commands work oddly, and I assume they're not really meant to be used
inside lists.  Thus I also tested with "Promote One Level" and "Demote One
Level".  These are denoted by OO' instead of OO.

Assume that there are style rules in effect like

ol ol { list-style-type: lower-alpha }
ol ol ol { list-style-type: lower-roman }

This is the default appearance in Word, and I set OO to something similar with
Bullets and Numbering -> Outline in the list editing toolbox.  I'm ignoring
bullet style throughout, for no particular reason.

* In an existing ordered list equivalent to <ol><li>foo<li>bar<li>baz</ol>quz:
  * Select "bar", do "ol":
    * Word/OO: Remove indent and number "2", change "3" to "2".
    * Browsers: Remove indent and number "2", change "3" to "1".
    * Spec: Same as browsers.
  * Select "bar", do "ul":
    * Word: Leave indent the same, change "2" to a bullet, change "3" to "2".
    * OO: Increase indent, change "2" to a bullet, change "3" to "2".
    * IE: Change all numbers to bullets.
    * Firefox/Chrome/Opera: Leave indent the same, change "2" to a bullet, change "3" to "1".
    * Spec: Same as Firefox/Chrome/Opera.
  * Select "bar", do "indent":
    * Word/OO'/Browsers: Increase indent, change "2" to "a", change "3" to "2".
    * OO: Increase indent, do not change any numbers.
    * Spec: Same as Word/OO'/Browsers.
  * Select "bar", do "outdent":
    * Word: Do nothing.
    * OO: Leave indent the same, de-indent "2" so it goes past the left margin (?!), do not change any numbers.
    * OO': Option grayed out.
    * Browsers: Remove indent and the number "2", change "3" to "1".
    * Spec: Same as browsers.
  * Select "quz", do "ol":
    * Word/OO/IE/Chrome: Add as fourth item to existing list, numbered "4".
    * Firefox/Opera: Create new list, number the item "1".
    * Spec: Same as OO/Word/IE/Chrome.
* In an existing ordered list equivalent to <ol><li>foo<br>bar<li>baz</ol>:
  * Select "foo", do "ol":
    * Word/OO/IE/Chrome/Opera: Remove indent from both "foo" and "bar", change "2" -> "1".
    * Firefox: Increase indent for "foo" only, add additional "a" marker after "1" and before "foo".
    * Spec: Same as Word/OO/IE/Chrome/Opera.
  * Select "foo", do "ul":
    * Word/Opera: Change "1" -> bullet, "2" -> "1".
    * OO: Increase indent for both "foo" and "bar", change "1" -> bullet, "2" -> "1".
    * IE: Change all numbers to bullets.
    * Firefox: Increase indent for "foo" only, add additional bullet marker after "1" and before "foo".
    * Chrome: Remove indent from "bar", change "1" -> bullet, "2" -> "1".
    * Spec: Same as Word/Opera.
  * Select "foo", do "indent":
    * Word: Increase indent for whole list.
    * OO: Increase indent for both "foo" and "bar".
    * OO': Increase indent for "foo", change "1" -> "a".
    * IE/Firefox non-CSS/Opera: Increase indent for both "foo" and "bar", change "1" -> "a", "2" -> "1".
    * Firefox CSS: Increase indent for "foo" only (<div style="margin-left: 40px">).
    * Chrome: Increase indent for "foo" only, add "a" before "foo", move "1" to be before "bar".
    * Spec: Same as IE/Firefox non-CSS/Opera.
  * Select "foo", do "outdent":
    * Word: Decrease indent for whole list, so it goes past the left margin.
    * OO: Decrease indent for "bar" and "1." (so "1." goes past the left margin), but not "foo".
    * OO': Option grayed out.
    * IE/Chrome/Opera: Remove indent from both "foo" and "bar", remove "1", change "2" -> "1".
    * Firefox: Do nothing.
    * Spec: Same as IE/Chrome/Opera.
  * Select "bar", do "ol":
    * Word/OO/IE/Chrome/Opera: Remove indent from both "foo" and "bar", change "2" -> "1".
    * Firefox: Increase indent for "bar" only, add "a" marker before it.
    * Spec: Same as Word/OO/IE/Chrome/Opera.
  * Select "bar", do "ul":
    * Word/Opera: Change "1" -> bullet, "2" -> "1".
    * OO: Increase indent for both "foo" and "bar", change "1" -> bullet, "2" -> "1".
    * IE: Change all numbers to bullets.
    * Firefox: Increase indent for "bar" only, add bullet marker before it.
    * Chrome: Remove indent from "foo", change "1" -> bullet and move it before "bar", change "2" -> "1".
    * Spec: Same as Word/Opera.
  * Select "bar", do "indent":
    * Word: Increase indent for whole list.
    * OO: Increase indent for both "foo" and "bar".
    * OO': Increase indent for "foo", change "1" -> "a".
    * IE/Firefox non-CSS/Opera: Increase indent for both "foo" and "bar", change "1" -> "a", "2" -> "1".
    * Firefox CSS: Increase indent for "bar" only (<div style="margin-left: 40px">).
    * Chrome: Increase indent for "bar" only, add "a" before "bar", move "bar" above "foo" (?!).
    * Spec: Same as IE/Firefox non-CSS/Opera.
  * Select "bar", do "outdent":
    * Word: Decrease indent for whole list, so it goes past the left margin.
    * OO: Decrease indent for "bar" and "1." (so "1." goes past the left margin), but not "foo".
    * OO': Option grayed out.
    * IE/Chrome/Opera: Remove indent from both "foo" and "bar", remove "1", change "2" -> "1".
    * Firefox: Do nothing.
    * Spec: Same as IE/Chrome/Opera.
* In an existing nested ordered list equivalent to <ol><li>foo<ol><li>bar<li>baz</ol><li>quz</ol>:
  * Select "bar", do "ol":
    * Word/IE/Firefox: Decrease indent, remove "a" ("bar" is aligned with "foo" with no marker of its own), change "b" -> "a".
    * OO: Remove all indent, change "b" -> "a".
    * Chrome: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "3".
    * Opera: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "4", insert extra "3" list marker before new "a".
    * Spec: Same as Chrome.
  * Select "bar", do "ul":
    * Word/Firefox/Chrome: Change "a" -> bullet, "b" -> "a".
    * OO: Increase indent, change "a" -> bullet, "b" -> "a".
    * IE: Change "a" and "b" to bullets.
    * Opera: Change "a" -> bullet, "b" -> "a", "2" -> "4", insert extra list markers "2" and "3" before new bullet and "a".
    * Spec: Same as Word/Firefox/Chrome.
  * Select "bar", do "indent":
    * Word/OO'/IE: Increase indent, change "a" -> "i", leave "b" alone.
    * OO: Increase indent, do not change numbers.
    * Firefox/Chrome/Opera: Increase indent, change "a" -> "i", "b" -> "a".
    * Spec: Same as Firefox/Chrome/Opera.
  * Select "bar", do "outdent":
    * Word/OO'/IE/Chrome: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "3".
    * OO: Leave indent the same, de-indent "a" so it goes past the left margin (?!).
    * Firefox: Decrease indent, remove "a" ("bar" is aligned with "foo" with no marker of its own), change "b" -> "a".
    * Opera: Decrease indent, change "a" -> "2", "b" -> "a", "2" -> "4", insert extra list marker "3" before new "a".
    * Spec: Same as Word/OO'/IE/Chrome.
* In existing nested lists equivalent to <ol><li>foo<ul><li>bar<li>baz</ul><li>quz</ol>:
  * Select "bar", do "ol":
    * Word: Change all bullets to numbers.  (Not letters, even though indented!)
    * OO: Decrease indent, change first bullet -> "2", "2" -> "3".
    * IE: Change all bullets to letters.
    * Firefox/Chrome: Change first bullet to "a".
    * Opera: Change first bullet -> "a", "2" -> "4", insert extra list markers "2" and "3" before new "a" and bullet.
    * Spec: Same as Firefox/Chrome.
  * Select "bar", do "ul":
    * Word/IE/Firefox: Decrease indent, remove first bullet ("bar" is aligned with "foo" with no marker of its own).
    * OO: Remove all indent, remove first bullet, leave all else the same.
    * Chrome: Decrease indent, change first bullet -> "2", "2" -> "3".
    * Opera: Decrease indent, change first bullet -> "2", "2" -> "4", insert extra list marker "3" before old bullet.
    * Spec: Same as Chrome.
  * Select "bar", do "indent":
    * Word: Increase indent, change first bullet to "i" (?!).
    * OO/OO'/Firefox/Chrome/Opera: Increase indent.
    * IE: Increase indent, change "2" -> "3" (?!?!).  (I don't see from the markup why the 2 actually changes to a 3.  The markup seems to be as other browsers.)
    * Spec: Same as OO/OO'/Firefox/Chrome/Opera.
  * Select "bar", do "outdent":
    * Word/IE/Chrome: Decrease indent, change first bullet -> "2", "2" -> "3".
    * OO: Usual crazy stuff, move bullet left but leave text alone.
    * OO': Option grayed out.  (Interesting.)
    * Firefox: Decrease indent, remove first bullet ("bar" is aligned with "foo" with no marker of its own).
    * Opera: Decrease indent, change first bullet -> "2", "2" -> "4", insert extra list marker "3" before old bullet.
    * Spec: Same as Word/IE/Chrome.
* In an existing nested ordered list equivalent to <ol><li>foo<li>bar<ol><li>baz</ol><li>quz</ol>:
  * Select "bar", do "ol":
    * Word/OO: Remove indent and "2", change "3" -> "2".
    * IE/Chrome/Opera: Remove indent and "2", decrease indent of "baz", change "2" and "3" -> "1".
    * Firefox: Increase indent, add extra "a" marker between "2" and "bar".
    * Spec: Different from all of them: remove indent and "2", change "3" -> "1".
  * Select "bar", do "ul":
    * Word: Change "2" -> bullet.
    * OO: Increase indent, change "2" -> bullet, "3" -> "2".
    * IE: Change "1", "2", "3" -> bullets (and "a" to "1").
    * Firefox: Increase indent, add extra bullet marker between "2" and "bar".
    * Chrome: Decrease indent of "baz", change "2" -> bullet, "a" and "3" -> "1".
    * Opera: Change "2" -> bullet, "a" and "3" -> "1".
    * Spec: Different from all of them: change "2" -> bullet, "3" -> "1".
  * Select "bar", do "indent":
    * Word/OO': Increase indent, change "2" -> "a", "a" -> "b", "3" -> "2".
    * OO: Increase indent (double amount, past "baz").
    * Firefox non-CSS/Opera: Increase indent of both "bar" and "baz", change "2" -> "a", "a" -> "i", "3" -> "2".
    * Firefox CSS: Increase indent.
    * Chrome: Increase indent, add "a" marker before "bar", move "2" marker to before the "a" marker of "baz".
    * Spec: Same as Word/OO'.
  * Select "bar", do "outdent":
    * Word/Firefox: Do nothing.
    * OO: Decrease indent on "2", leave "bar" alone.
    * OO': Option grayed out.
    * IE: Decrease indent of "baz", change "2" and "3" -> "1", "a" -> "2".
    * Chrome/Opera: Decrease indent of "bar" and "baz", remove "2", change "a" and "3" -> "1".
    * Spec: Different from all of them: remove indent and "2", change "3" -> "1".
* In an existing nested ordered list equivalent to <ol><li>foo<li>bar<ol><li>baz</ol>quz<li>qoz</ol>:
  * Does not appear to be possible in Word or OO.
  * Also might be impossible to actually make such a list using execCommand() in browsers.
  * Suffice it to say that there's a lot of variation.
* In an existing indented region equivalent to foo<blockquote>bar</blockquote>baz:
  * Select "bar", do "ol":
    * Word/OO/Firefox/Chrome: Increase indent, add "1".
    * IE: Increase indent, add "a".
    * Opera: Add "1" (but do not increase indent).
  * Select "foobar", do "ol":
    * Word/IE: Increase indent of both, add "1" before "foo" and "a" before
      "bar".
    * OO: Increase indent of "bar" one step, increase indent of "foo" two steps
      so it's aligned with "bar", add "1" before "foo" and "2" before "bar".
    * Firefox: Increase indent of both, add "1" before foo", add "2" before
      "bar" aligned with the "1" of "foo" (so large gap between "2" and "bar").
    * Chrome: Increase indent of "foo", add "1" before "foo" and "2" before
      "bar".
    * Opera: Mash everything together on one line.  But if you do
      <p>foo</p><blockquote>bar</blockquote><p>baz</p> instead, same as Chrome.
  * Select "foo" and do "ol", then select "bar" and do "ol":
    * Word/OO/Firefox/Opera: Different than doing both at once (often in
      exciting ways).
    * IE/Chrome: Same as doing both at once.
* <p>foo</p><blockquote><p>bar</p><p>baz</p></blockquote>
  * Select "foobar" and do "ol":
    * Word: One-item list with sublist.
    * OO/Firefox/Chrome/Opera: One two-item list, unindented.
    * IE9: Two one-item lists.
  * Select "foo", do "ol", then select "bar" and do "ol":
    * Word/OO/Chrome: One two-item list, unindented.
    * IE9/Firefox: Two one-item lists.
    * Opera: Two one-item lists, both unindented.
  * Desired behavior: One-item list with sublist in both cases.
* In an existing multi-line indented region equivalent to <blockquote>foo<br>bar<br>baz</blockquote>:
  * Select "bar", do "ol":
    * Word/OO/Firefox/Chrome: Increase indent, add "1".
    * IE: Increase indent of everything, add "a" before "foo".  If you do
      <blockquote><p>foo<p>bar<p>baz</blockquote>, same as
      Word/OO/Firefox/Chrome.
    * Opera: Don't increase indent of anything, add "1" before "bar".
* In an existing multi-line indented region equivalent to <blockquote>foo<br>bar</blockquote>baz:
  * Select "barbaz", do "ol":
    * Word: Indent both, add "a" before "bar" and "2" before "baz".
    * OO: Indent "baz", add "1" before "bar" and "2" before "baz".
    * IE: Indent everything, add "a" before "foo" and "1" before "baz".  If you
      do <blockquote><p>foo<p>bar</blockquote><p>baz, indent "bar" and "baz"
      and put "1" before each.
    * Firefox: Indent "bar" and put "1" before it, put "baz" after "bar" on the
      same line.  If you do <blockquote><p>foo<p>bar</blockquote><p>baz, same
      as Chrome.
    * Chrome: Indent "bar" once and "baz" twice, put "1" before "bar" and "2"
      before "baz".
    * Opera: Put a "1" before "bar" and move "baz" to the same line.  If you do
      <blockquote><p>foo<p>bar</blockquote><p>baz, indent "baz", put a "1"
      before "bar" and a "2" before "baz".
  * Select "bar", do "ol", then select "baz" and do "ol":
    * Word/OO/Opera: Different from if you do both together.
    * IE: Different with <br>, same with <p>.
    * Firefox: Three behaviors, depending on whether you do it in one step with
      <br>, one step with <p>, or two steps with either (same behavior
      regardless with two steps).
    * Chrome: Same behavior in all four cases.
* <blockquote>foo<ol><li>bar</ol></blockquote>baz:
  * Select "baz", do "ol":
    * Word/OO/Chrome: Add "baz" as a new item to existing list.
    * IE/Firefox/Opera: Make "baz" its own new list.
* <ul><li>foo</li><ol><li>bar</li></ol></ul>baz:
  * Select "baz", do "ol":
    * IE/Firefox/Chrome/Opera: Separate list.

Ignoring the conceptual model of HTML, which users won't understand, here's the
conceptual model I've developed for lists: text is divided up into blocks.
Each block has an indentation level and a list marker type.  The list marker
type can be either nothing, ordered, or unordered.  A list block cannot have
indentation level less than one.  Any given piece of text is part of only one
block.  A block may be visually non-contiguous, such as if a single list block
is interrupted by a further-indented block.

To find the right number (or letter) for an ordered-list block, look at the
immediately preceding block, but skip over any blocks of higher indentation
level.  If there is no immediately preceding block, or it's not an ordered-list
block, or it has a lower indentation level, the number is 1 (or a, i, etc.).
Otherwise, it's the number of the preceding block plus one.

ol/ul commands change the selected block to that list marker type, or remove
the list marker type if it's already the chosen type.  If the block has
indentation level zero, it increases to one.

indent/outdent commands change the selected block's indentation level.  If a
list block's indentation level is reduced to zero, it's converted to a regular
block.

What this means from an HTML perspective, roughly:

* A list block is the entire contents of an <li> element, ignoring any nested
  list elements or indentation elements.  A non-list block is a line box.
* Indentation level is equal to the number of ancestor elements that are either
  <li>s or indentation elements (blockquotes or indenting divs).
* To find the list marker type, go to the first ancestor that's either an <li>
  or indentation element.
* Correct numbering should automatically follow from the way <ol> works in HTML
  (which is one of the reasons I use this model).
* An ol command in an ordered-list block removes the surrounding <li>,
  migrating its contents into the parent of the <ol>.  This splits up the <ol> if
  it's not the first or last child, and wraps the contents in a new <li> if
  necessary.  If there's another list or indentation element nested in the <li>
  we're removing, it will get re-wrapped in a new <ol>, outside the
  newly-created <li>, so that it maintains its indentation.  This might cause
  the new <li> to wind up in multiple pieces, if the original block was not
  contiguous, which means the non-contiguous block is split into several blocks
  (with different numbers).
* An ol command in an unordered-list block breaks up the parent <ul> and puts a
  new <ol> in between the two pieces, moving the parent <li> into it.  If the
  <li> was the first or last child, we merge with an existing adjacent <ol> if
  possible.  All children stay as they are.
* An ol command in a non-list block with indentation zero wraps it in a new
  <ol><li>, or merges with an adjacent <ol> if possible.
* An ol command in a non-list block with nonzero indentation converts the
  parent to an <ol><li>, breaking it up if necessary.
* The ul command works similarly to ol.
* indent in a non-list block wraps in an indentation element.  In a list block,
  it wraps the <li> in an extra <ol> or <ul> as appropriate.  With merging.
  Whatever.  Let me just write the spec.
* outdent in a non-list block strips an indentation element, if one is present.
  In a list block, it breaks apart the parent <ol> or <ul> and makes the
  affected block a sibling in between the newly-split list elements.  Will
  create new <li>s, etc. etc.

Sheesh, lists are complicated.
-->
<p>To <dfn>toggle lists</dfn>, given a string <var>tag name</var> (either "ol"
or "ul"):

<ol>
  <li>Let <var>mode</var> be "disable" if the <span>selection's list
  state</span> is <var>tag name</var>, and "enable" otherwise.

  <li>Let <var>other tag name</var> be "ol" if <var>tag name</var> is "ul", and
  "ul" if <var>tag name</var> is "ol".

  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the <span>active range</span>'s [[rangestart]]
  and/or [[rangeend]] [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>If <var>mode</var> is "enable", then let <var>lists to convert</var>
  consist of every <span>editable</span> <span>HTML element</span> with
  [[localname]] <var>other tag name</var> that is [[contained]] in <var>new
  range</var>, and for every <var>list</var> in <var>lists to convert</var>:

  <ol>
    <li>If <var>list</var>'s [[previoussibling]] or [[nextsibling]] is an
    <span>editable</span> <span>HTML element</span> with [[localname]] <var>tag
    name</var>:
    <!-- Convert it to the right name.  If possible, we want to merge with a
    neighboring list of the correct type.  Failing that, we set the tag name.
    -->

    <ol>
      <li>Let <var>children</var> be <var>list</var>'s [[children]].

      <li><span>Record the values</span> of <var>children</var>, and let
      <var>values</var> be the result.

      <li><span>Split the parent</span> of <var>children</var>.

      <li><span>Wrap</span> <var>children</var>, with <span>sibling
      criteria</span> matching any <span>HTML element</span> with [[localname]]
      <var>tag name</var>.

      <li><span>Restore the values</span> from <var>values</var>.
    </ol>

    <li>Otherwise, <span>set the tag name</span> of <var>list</var> to <var>tag
    name</var>.
  </ol>

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  if <var>node</var> is <span>editable</span>; the last member of <var>node
  list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is not an <span>indentation element</span>; and either
  <var>node</var> is an [[ol]] or [[ul]], or its [[parent]] is an [[ol]] or
  [[ul]], or it is an <span>allowed child</span> of "li"; then append
  <var>node</var> to <var>node list</var>.
  <!--
  We exclude indentation elements so that selecting some random text and doing
  indent followed by insertOrderedList will have the same result as the
  reverse.  Specifically,

    <blockquote>[foo]</blockquote> ->
    <blockquote><ol><li>[foo]</li></ol></blockquote>

  per spec and Firefox 4.0 and (more or less) Chrome 12 dev.  Opera 11.10
  instead does <ol><li>foo</li></ol>, so the indentation vanishes.  IE9 does
  <ol><ol><li>foo</li></ol></ol>, but that doesn't make semantic sense and is
  different from how it would work if you reversed the commands.
  OpenOffice.org 3.2.1 (Ubuntu) and Word 2007 both agree with the spec in this
  case.
  -->

  <li>If <var>mode</var> is "enable", remove from <var>node list</var> any
  [[ol]] or [[ul]] whose [[parent]] is not also an [[ol]] or [[ul]].
  <!--
  We don't want to touch these.  E.g., assuming tag name is "ol",
    [foo<ol><li>bar</ol>baz]
    -> <ol><li>[foo<li>bar<li>baz]</ol>
    not <ol><li>[foo</li><ol><li>bar</ol><li>baz]</ol>.
  But
    <ul><li>foo<li>[bar</li><ol><li>baz</ol><li>quz]</ul>
    -> <ul><li>foo</ul><ol><li>[bar</li><ol><li>baz</ol><li>quz]</ol>
    not <ul><li>foo</ul><ol><li>[bar</ol><ul><ol><li>baz</ol></ul><ol><li>quz]</ol>
  -->

  <li>If <var>mode</var> is "disable", then while <var>node list</var> is not
  empty:

  <ol>
    <li>Let <var>sublist</var> be an empty list of [[nodes]].

    <li>Remove the first member from <var>node list</var> and append it to
    <var>sublist</var>.

    <li>If the first member of <var>sublist</var> is an <span>HTML
    element</span> with [[localname]] <var>tag name</var>, <span>outdent</span>
    it and continue this loop from the beginning.

    <li>While <var>node list</var> is not empty, and the first member of
    <var>node list</var> is the [[nextsibling]] of the last member of
    <var>sublist</var> and is not an <span>HTML element</span> with
    [[localname]] <var>tag name</var>, remove the first member from <var>node
    list</var> and append it to <var>sublist</var>.

    <li><span>Record the values</span> of <var>sublist</var>, and let
    <var>values</var> be the result.

    <li><span>Split the parent</span> of <var>sublist</var>.

    <li><span>Fix disallowed ancestors</span> of each member of
    <var>sublist</var>.

    <li><span>Restore the values</span> from <var>values</var>.
  </ol>

  <li>Otherwise, while <var>node list</var> is not empty:

  <ol>
    <li>Let <var>sublist</var> be an empty list of [[nodes]].

    <li>While either <var>sublist</var> is empty, or <var>node list</var> is
    not empty and its first member is the [[nextsibling]] of
    <var>sublist</var>'s last member:
    <!-- Accumulate consecutive sibling nodes in sublist, first converting them
    all to li's (except if they're already lists). -->

    <ol>
      <li>If <var>node list</var>'s first member is a [[p]] or [[div]],
      <span>set the tag name</span> of <var>node list</var>'s first member to
      "li", and append the result to <var>sublist</var>.  Remove the first
      member from <var>node list</var>.
      <!-- Thus <p>foo</p> becomes <ol><li>foo</ol> instead of
      <ol><li><p>foo</ol>, and likewise for div, but other things will be put
      inside the <li>. -->

      <li>Otherwise, if the first member of <var>node list</var> is an [[li]]
      or [[ol]] or [[ul]], remove it from <var>node list</var> and append it to
      <var>sublist</var>.

      <li>Otherwise:

      <ol>
        <li>Let <var>nodes to wrap</var> be a list of [[nodes]], initially
        empty.

        <li>While <var>nodes to wrap</var> is empty, or <var>node list</var> is
        not empty and its first member is the [[nextsibling]] of
        <var>nodes to wrap</var>'s last member and the first member of
        <var>node list</var> is an <span>inline node</span> and the last member
        of <var>nodes to wrap</var> is an <span>inline node</span> other than a
        [[br]], remove the first member from <var>node list</var> and append it
        to <var>nodes to wrap</var>.

        <li><span>Wrap</span> <var>nodes to wrap</var>, with <span>new parent
        instructions</span> returning the result of calling
        [[createelement|"li"]] on the [[contextobject]].  Append the result to
        <var>sublist</var>.
      </ol>
    </ol>

    <li>If <var>sublist</var>'s first member's [[parent]] is an <span>HTML
    element</span> with [[localname]] <var>tag name</var>, or if every member
    of <var>sublist</var> is an [[ol]] or [[ul]], continue this loop from the
    beginning.
    <!-- Already wrapped properly, nothing more to do. -->

    <li>If <var>sublist</var>'s first member's [[parent]] is an <span>HTML
    element</span> with [[localname]] <var>other tag name</var>:

    <ol>
      <li><span>Record the values</span> of <var>sublist</var>, and let
      <var>values</var> be the result.

      <li><span>Split the parent</span> of <var>sublist</var>.

      <li><span>Wrap</span> <var>sublist</var>, with <span>sibling
      criteria</span> matching any <span>HTML element</span> with [[localname]]
      <var>tag name</var>, and <span>new parent instructions</span> returning
      the result of calling [[createelement|<var>tag name</var>]] on the
      [[contextobject]].

      <li><span>Restore the values</span> from <var>values</var>.

      <li>Continue this loop from the beginning.
    </ol>

    <li><span>Wrap</span> <var>sublist</var>, with the <span>sibling
    criteria</span> matching any <span>HTML element</span> with [[localname]]
    <var>tag name</var>, and the <span>new parent instructions</span> being the
    following:

    <ol>
      <!--
      Special case: something like
        <ol><li>foo</ol><blockquote>[bar]</blockquote>
      becomes
        <ol><li>foo</li><ol><li>[bar]</ol></ol>
      instead of
        <ol><li>foo</ol><blockquote><ol><li>[bar]</ol></blockquote>.
      We handle the special case in the new parent instructions instead of
      outside because we'd prefer to wind up in a sibling if there is one.  We
      handle only previousSibling, not nextSibling, because we really mean for
      this to cover something like
        [foo<blockquote>bar]</blockquote>
      which we'll handle node-by-node.  TODO: Maybe we should do this
      differently, like just special-case simple indentation elements in an
      earlier part of the algorithm?  This way's a bit weird.
      -->
      <li>If <var>sublist</var>'s first member's [[parent]] is not an
      <span>editable</span> <span>simple indentation element</span>, or
      <var>sublist</var>'s first member's [[parent]]'s [[previoussibling]] is
      not an <span>editable</span> <span>HTML element</span> with [[localname]]
      <var>tag name</var>, call [[createelement|<var>tag name</var>]] on the
      [[contextobject]] and return the result.

      <li>Let <var>list</var> be <var>sublist</var>'s first member's
      [[parent]]'s [[previoussibling]].

      <li><span>Normalize sublists</span> of <var>list</var>'s [[lastchild]].

      <li>If <var>list</var>'s [[lastchild]] is not an <span>editable</span>
      <span>HTML element</span> with [[localname]] <var>tag name</var>, call
      [[createelement|<var>tag name</var>]] on the [[contextobject]], and
      append the result as the last [[child]] of <var>list</var>.

      <li>Return the last [[child]] of <var>list</var>.
    </ol>

    <li><span>Fix disallowed ancestors</span> of the previous step's result.
  </ol>
</ol>

<!-- @} -->
<h3>Justifying the selection</h3>
<!-- @{ -->
<!--
There are two basic ways it works: using the align attribute, and using CSS
text-align.  IE9 and Opera 11.11 use only the align attribute, Chrome 13 dev
uses only text-align, and Firefox 5.0a2 varies based on styleWithCSS.  The two
ways produce entirely different results, which is a real problem, so I don't
think Firefox's approach is tenable.  text-align is more valid, and for typical
contenteditable cases it works the same.  But for cases where you have
fixed-width blocks, like tables or just divs with a width set, it behaves
differently, and in those cases the align attribute is more useful.
-->

<p>To <dfn>justify the selection</dfn> to a string <var>alignment</var> (either
"center", "justify", "left", or "right"):

<!--
TODO: text-align doesn't behave as expected if there are descendant blocks with
non-100% width, like tables.  The align attribute behaves a lot more nicely in
such cases, but it's not valid.  Not clear what to do.  For now I've stuck with
text-align, just because the cases where it misbehaves can't be created by any
sequence of stock execCommand()s that I know of, but this needs more careful
consideration.  Gecko in CSS mode seems to special-case tables, adding auto
margins to the table element to get it to align correctly.

TODO: We could do something along the lines of pushing down values here,
although no browser does.  In fact, it's very likely this can be rewritten in
terms of the inline formatting command primitives, but it's not clear if it
would be worth the added complexity.
-->

<ol>
  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>element list</var> be a list of all <span>editable</span>
  [[element]]s [[contained]] in <var>new range</var> that either has an
  attribute in the [[htmlnamespace]] whose [[attrlocalname]] is "align", or has
  a [[style]] attribute that sets "text-align", or is a <code
  data-anolis-spec=html>center</code>.
  <!-- No browser actually removes center, but it makes sense to do so. -->

  <li>For each <var>element</var> in <var>element list</var>:

  <ol>
    <li>If <var>element</var> has an attribute in the [[htmlnamespace]] whose
    [[attrlocalname]] is "align", remove that attribute.

    <li>Unset the CSS property "text-align" on <var>element</var>, if it's set
    by a [[style]] attribute.

    <li>If <var>element</var> is a [[div]] or [[span]] or <code
    data-anolis-spec=html>center</code> with no attributes, remove it,
    <span>preserving its descendants</span>.

    <li>If <var>element</var> is a <code data-anolis-spec=html>center</code>
    with one or more attributes, <span>set the tag name</span> of
    <var>element</var> to "div".
  </ol>

  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.
  <!-- This could theoretically be necessary, like if it converted "<div
  align=right>foo</div>bar" to "foo<br>bar".  Now we need to select "foo<br>",
  nor just "foo". -->

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  append <var>node</var> to <var>node list</var> if the last member of
  <var>node list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is <span>editable</span>; <var>node</var> is an <span>allowed
  child</span> of "div"; and <var>node</var>'s <span>alignment value</span> is
  not <var>alignment</var>.
  <!-- Of tested browsers, only Chrome 13 dev seems to not apply the alignment
  to nodes that are already aligned.  Even then, it does apply it if the
  alignment is just inherited from the root. -->

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>Let <var>sublist</var> be a list of [[nodes]], initially empty.

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>While <var>node list</var> is not empty, and the first member of
    <var>node list</var> is the [[nextsibling]] of the last member of
    <var>sublist</var>, remove the first member of <var>node list</var> and
    append it to <var>sublist</var>.

    <li><span>Wrap</span> <var>sublist</var>.  <span>Sibling criteria</span>
    match any [[div]] that has one or both of the following two attributes, and
    no other attributes:

    <ul>
      <li>An <code data-anolis-spec=html title=attr-div-align>align</code>
      attribute whose [[attrvalue]] is an <span data-anolis-spec=domcore>ASCII
      case-insensitive</span> match for <var>alignment</var>.

      <li>A [[style]] attribute which sets exactly one CSS property (including
      unrecognized or invalid attributes), which is "text-align", which is set
      to <var>alignment</var>.
    </ul>

    <span>New parent instructions</span> are to call [[createelement|"div"]] on
    the [[contextobject]], then set its CSS property "text-align" to
    <var>alignment</var>, and return the result.
    <!-- As for inline formatting, I only ever create new elements, and don't
    ever modify existing ones.  This doesn't match how any browser behaves
   in this case, but for inline formatting it matches everyone but Gecko's CSS
    mode. -->
  </ol>
</ol>

<!-- @} -->
<h3><dfn>The <code title>delete</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:
<!--
For all the deletions here, Firefox 7.0a2 will remove wrapper elements like <b>
only if they're selected, like {<b>foo</b>}.  IE9, Chrome 14 dev, and Opera
11.50 will all remove them even if only their contents are selected, like
<b>[foo]</b>.  Gecko's behavior in the latter case leaves things like <b>{}</b>
in the DOM, which is unhelpful, so I don't.
-->

<ol>
  <li>If the <span>active range</span> is not <code data-anolis-spec=domrange
  title=dom-Range-collapsed>collapsed</code>, <span>delete the contents</span>
  of the <span>active range</span> and abort these steps.

  <li><span>Canonicalize whitespace</span> at (<span>active range</span>'s
  [[startnode]], <span>active range</span>'s [[startoffset]]).
  <!-- Needed so that if there are multiple consecutive spaces we backspace
  over all at once. -->

  <li>Let <var>node</var> and <var>offset</var> be the <span>active
  range</span>'s [[rangestart]] [[bpnode]] and [[bpoffset]].

  <!-- First go up as high as possible within the current block, then drill
  down to the lowest possible level, in the hopes that we'll wind up at the end
  of a text node, or maybe in a br or hr. -->
  <li>Repeat the following steps:

  <ol>
    <!--
    If there's an invisible node somewhere, Firefox 5.0a2 removes that node and
    then stops, so each backspace removes one invisible node.  All others
    remove the invisible node and then continue on looking for something
    visible to remove.  The spec follows the latter behavior, since it makes
    more sense to the user.  Of course, the definition of "invisible node" is
    not necessarily anything like the spec's.
    -->
    <li>If <var>offset</var> is zero and <var>node</var>'s [[previoussibling]]
    is an <span>editable</span> <span>invisible</span> [[node]], remove
    <var>node</var>'s [[previoussibling]] from its [[parent]].

    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> &minus; 1 and that [[child]] is an <span>editable</span>
    <span>invisible</span> [[node]], remove that [[child]] from
    <var>node</var>, then subtract one from <var>offset</var>.

    <li>Otherwise, if <var>offset</var> is zero and <var>node</var> is an
    <span>inline node</span>, or if <var>node</var> is an
    <span>invisible</span> [[node]], set <var>offset</var> to the [[index]] of
    <var>node</var>, then set <var>node</var> to its [[parent]].

    <!--
    When backspacing a link, Firefox 7.0a2, Chrome 14 dev, Opera 11.50, and
    OpenOffice.org 3.2.1 Ubuntu have no special behavior.  IE9 and Word 2007
    remove the link instead of deleting its last character.  The latter
    behavior seems more useful and intuitive.
    -->
    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> &minus; 1 and that [[child]] is an <span>editable</span>
    [[a]], remove that [[child]] from <var>node</var>, <span>preserving its
    descendants</span>.  Then abort these steps.

    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> &minus; 1 and that [[child]] is not a <span>block
    node</span> or a [[br]] or an [[img]], set <var>node</var> to that
    [[child]], then set <var>offset</var> to the [[nodelength]] of
    <var>node</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <!--
  At this point, node cannot be an invisible node.  There are three cases:

  1) offset is zero and node is a block node.  Then we'll usually merge with
  the previous block if one exists.

  2) offset is not zero, node is not a block node, and node does not have a
  child with index offset - 1.  The only way this is possible is if node has a
  length greater than zero but no children, which implies it's a text or
  comment or PI.  Comments and PIs are invisible nodes, so it must be a text
  node.  We delete the previous character.

  3) offset is not zero, and the child of node with index offset - 1 is a
  block node or a br or an img.  Then we'll usually merge the offsetth child of
  node with the last descendant of the offset - 1st.
  -->

  <li>If <var>node</var> is a [[text]] node and <var>offset</var> is not zero,
  call [[selcollapse|<var>node</var>, <var>offset</var>]] on the [[selection]].
  Then <span>delete the contents</span> of the [[range]] with [[rangestart]]
  (<var>node</var>, <var>offset</var> &minus; 1) and [[rangeend]]
  (<var>node</var>, <var>offset</var>) and abort these steps.

  <!-- At the time of this writing, this should be impossible. -->
  <li>If <var>node</var> is an <span>inline node</span>, abort these steps.

  <li>If <var>node</var> has a [[child]] with [[index]] <var>offset</var>
  &minus; 1 and that [[child]] is a [[br]] or [[hr]] or [[img]], call
  [[selcollapse|<var>node</var>, <var>offset</var>]] on the [[selection]].
  Then <span>delete the contents</span> of the [[range]] with [[rangestart]]
  (<var>node</var>, <var>offset</var> &minus; 1) and [[rangeend]]
  (<var>node</var>, <var>offset</var>) and abort these steps.

  <!--
  If we're at the beginning of a list, we want to outdent the first list item.
  This doesn't actually match anyone or anything.  Word 2007 and OpenOffice.org
  3.2.1 Ubuntu just remove the list marker, which is weird and doesn't map well
  to HTML.  Browsers tend to just merge with the preceding block, which isn't
  expected.
  -->
  <li>If <var>node</var> is an [[li]] or [[dt]] or [[dd]] and is the first
  [[child]] of its [[parent]], and <var>offset</var> is zero:

  <ol>
    <li>Let <var>items</var> be a list of all [[li]]s that are
    [[ancestors]] of <var>node</var>.

    <li><span>Normalize sublists</span> of each <var>item</var> in
    <var>items</var>.

    <li><span>Record the values</span> of the one-[[node]] list consisting of
    <var>node</var>, and let <var>values</var> be the result.

    <li><span>Split the parent</span> of the one-[[node]] list consisting of
    <var>node</var>.

    <li><span>Restore the values</span> from <var>values</var>.

    <li>If <var>node</var> is a [[dd]] or [[dt]], and it is not an
    <span>allowed child</span> of any of its [[ancestors]] <span>in the same
    editing host</span>, <span>set the tag name</span> of <var>node</var> to
    the <span>default single-line container name</span> and let <var>node</var>
    be the result.
    <!--
    Annoying hack to prevent the dl from being re-added when fixing disallowed
    ancestors.  In most cases we want a wrapper dl added, but in two cases
    (delete and insertParagraph) we're actually trying to outdent the list
    item.  There might be a better way to do this.
    -->

    <li><span>Fix disallowed ancestors</span> of <var>node</var>.

    <li>Abort these steps.
  </ol>

  <!-- By this point, we're almost certainly going to merge something, and the
  only question is what. -->
  <li>Let <var>start node</var> equal <var>node</var> and let <var>start
  offset</var> equal <var>offset</var>.

  <li>Repeat the following steps:

  <ol>
    <li>If <var>start offset</var> is zero, set <var>start offset</var> to the
    [[index]] of <var>start node</var> and then set <var>start node</var> to
    its [[parent]].

    <li>Otherwise, if <var>start node</var> has an <span>editable</span>
    <span>invisible</span> [[child]] with [[index]] <var>start offset</var>
    minus one, remove it from <var>start node</var> and subtract one from
    <var>start offset</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <!--
  At the beginning of an indented block, outdent it, similar to a list item.
  Browsers don't do this, word processors do.

  Note: this copy-pastes from the outdent command action.
  -->
  <li>If <var>offset</var> is zero, and <var>node</var> has an
  <span>editable</span> [[ancestorcontainer]] <span>in the same editing
  host</span> that's an <span>indentation element</span>:

  <ol>
    <li><span>Block-extend</span> the [[range]] whose [[rangestart]] and
    [[rangeend]] are both (<var>node</var>, 0), and let <var>new range</var> be
    the result.

    <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

    <li>For each [[node]] <var>current node</var> [[contained]] in <var>new
    range</var>, append <var>current node</var> to <var>node list</var> if the
    last member of <var>node list</var> (if any) is not an [[ancestor]] of
    <var>current node</var>, and <var>current node</var> is
    <span>editable</span> but has no <span>editable</span> [[descendants]].

    <li><span>Outdent</span> each [[node]] in <var>node list</var>.

    <li>Abort these steps.
  </ol>

  <!--
  This is to avoid stripping a line break from

    foo<br><br><table><tr><td>[]bar</table>

  and similarly for <hr>.  We should just do nothing here.
  -->
  <li>If the [[child]] of <var>start node</var> with [[index]] <var>start
  offset</var> is a [[table]], abort these steps.

  <!--
  If you try backspacing into a table, select it.  This doesn't match any
  browser; it matches the recommendation of the "behavior when typing in
  contentEditable elements" document.  The idea is that then you can delete it
  with a second backspace.
  -->
  <li>If <var>start node</var> has a [[child]] with [[index]] <var>start
  offset</var> &minus; 1, and that [[child]] is a [[table]]:

  <ol>
    <li>Call [[selcollapse|<var>start node</var>, <var>start offset</var>
    &minus; 1]] on the [[contextobject]]'s [[selection]].

    <li>Call [[extend|<var>start node</var>, <var>start offset</var>]] on the
    [[contextobject]]'s [[selection]].

    <li>Abort these steps.
  </ol>

  <!--
  Special case:

    <p>foo</p><br><p>[]bar</p>
    -> <p>foo</p><p>[]bar</p>

  and likewise for <hr>.  But with <img> we merge like in other cases:

    <p>foo</p><img><p>[]bar</p>
    -> <p>foo</p><img>[]bar.

  Browsers don't do this consistently.  Firefox 5.0a2 doesn't seem to do it at
  all.
  -->
  <li>If <var>offset</var> is zero; and either the [[child]] of <var>start
  node</var> with [[index]] <var>start offset</var> minus one is an [[hr]], or
  the [[child]] is a [[br]] whose [[previoussibling]] is either a [[br]] or not
  an <span>inline node</span>:

  <ol>
    <li>Call [[selcollapse|<var>node</var>, <var>offset</var>]] on the
    [[selection]].

    <li><span>Delete the contents</span> of the [[range]] with [[rangestart]]
    (<var>start node</var>, <var>start offset</var> &minus; 1) and [[rangeend]]
    (<var>start node</var>, <var>start offset</var>).

    <li>Abort these steps.
  </ol>

  <!--
  If you try backspacing out of a list item, merge it with the previous item,
  but add a line break.  Then you have to backspace again if you really want
  them to be on the same line.  This matches Word 2007 and OpenOffice.org 3.2.1
  Ubuntu, and also matches "behavior when typing in contentEditable elements",
  but does not match any browser.

  Note that this behavior is quite different from what happens if you actually
  select the linebreak in between the two lines.  In that case, the blocks are
  merged as normal.

  Also note that hitting backspace twice will merge with the previous item.
  This matches OO.org, but Word will outdent the item on subsequent backspaces.
  Word's behavior doesn't fit well with the way lists work in HTML, and we
  probably don't want it.
  -->
  <li>If the [[child]] of <var>start node</var> with [[index]] <var>start
  offset</var> is an [[li]] or [[dt]] or [[dd]], and that [[child]]'s
  [[firstchild]] is an <span>inline node</span>, and <var>start offset</var> is
  not zero:

  <ol>
    <li>Let <var>previous item</var> be the [[child]] of <var>start node</var>
    with [[index]] <var>start offset</var> minus one.

    <!-- If the last child is already a br, we only need to append one extra
    br.  Otherwise we need to append two, since the first will do nothing. -->
    <li>If <var>previous item</var>'s [[lastchild]] is an <span>inline
    node</span> other than a [[br]], call [[createelement|"br"]] on the
    [[contextobject]] and append the result as the last [[child]] of
    <var>previous item</var>.

    <li>If <var>previous item</var>'s [[lastchild]] is an <span>inline
    node</span>, call [[createelement|"br"]] on the [[contextobject]] and
    append the result as the last [[child]] of <var>previous item</var>.
  </ol>

  <!--
  When merging adjacent list items, make sure we only merge the items
  themselves, not any block children.  We want <li><p>foo<li><p>bar to become
  <li><p>foo<p>bar, not <li><p>foo<br>bar or <li><p>foobar.
  -->
  <li>If the [[child]] of <var>start node</var> with [[index]] <var>start
  offset</var> is an [[li]] or [[dt]] or [[dd]], and its [[previoussibling]] is
  also an [[li]] or [[dt]] or [[dd]], set <var>start node</var> to its
  [[child]] with [[index]] <var>start offset</var> &minus; 1, then set
  <var>start offset</var> to <var>start node</var>'s [[nodelength]], then set
  <var>node</var> to <var>start node</var>'s [[nextsibling]], then set
  <var>offset</var> to 0.

  <!-- General block-merging case. -->
  <li>Otherwise, while <var>start node</var> has a [[child]] with [[index]]
  <var>start offset</var> minus one:

  <ol>
    <li>If <var>start node</var>'s [[child]] with [[index]] <var>start
    offset</var> minus one is <span>editable</span> and <span>invisible</span>,
    remove it from <var>start node</var>, then subtract one from <var>start
    offset</var>.

    <li>Otherwise, set <var>start node</var> to its [[child]] with [[index]]
    <var>start offset</var> minus one, then set <var>start offset</var> to the
    [[nodelength]] of <var>start node</var>.
  </ol>

  <li><span>Delete the contents</span> of the [[range]] with [[rangestart]]
  (<var>start node</var>, <var>start offset</var>) and [[rangeend]]
  (<var>node</var>, <var>offset</var>).
</ol>

<!-- @} -->
<h3><dfn>The <code title>formatBlock</code> command</dfn></h3>
<!-- @{ -->
<!--
Tested browser versions: IE9, Firefox 4.0, Chrome 13 dev, Opera 11.10.

Firefox and Chrome will replace a <blockquote> by a <p> or other given tag.  IE
and Opera will nest the <p> inside instead.  The latter makes more sense, given
that a) we don't support formatBlock with <blockquote> and b) <blockquote>s are
logically different, since they can contain many lines.

Firefox will not convert other tags like <p> to <div>, it will only wrap
unwrapped lines in a <div>.  Firefox also won't replace <div> by things like
<p>, it will nest the <p> inside.  The spec follows other browsers.

If you try to convert a <dt> to a <div> or <p> or such, Firefox breaks out of
the <dl> entirely, leaving ...<dt><br></dt></dl>.  Chrome will convert a <dt>
or <dd> to the given element, leaving a <div> or <p> or such as the child of a
<dl>.  I follow IE/Opera, which only affect the contents of <dt>/<dd> (Firefox
behaves this way for <dd> as well, just not <dt>).  This means you can get
invalid DOMs like <dt><p>foo<p></dt>, but they can be serialized as text/html,
so I'm not too fussy.

When it comes to <li>, IE/Opera behave like with <dt>/<dd>, which is how I
behave too.  Firefox apparently refuses to do anything.  Chrome tries to wrap
the parent list element, breaking it up if only some of the children are
selected; this produces unserializable DOMs if you're wrapping with <p>.

When you're converting multiple blocks at once, Chrome replaces them all by one
block with <br> stuck in, like <p>foo</p><p>bar</p> -> <div>foo<br>bar</div>.
It wipes out intervening block containers too in some cases.  This might make
sense for <address>/<h*>/<pre>, but other browsers don't do it.
-->

<p>A <dfn>formattable block name</dfn> is "address", "dd", "div", "dt", "h1",
"h2", "h3", "h4", "h5", "h6", "p", or "pre".

<p><span>Action</span>:

<ol>
  <li>If <var>value</var> begins with a "&lt;" character and ends with a ">"
  character, remove the first and last characters from it.
  <!-- IE9 requires the brackets.  If they're not provided, it does nothing.
  -->

  <li>Let <var>value</var> be <span data-anolis-spec=domcore>converted to
  ASCII lowercase</span>.

  <li>If <var>value</var> is not a <span>formattable block name</span>, abort
  these steps and do nothing.
  <!--
  Opera 11.10 throws NOT_SUPPORTED_ERR for bad elements, all other tested
  browsers ignore the input.  Testing in IE9, Firefox 4.0, Chrome 13 dev, and
  Opera 11.10, supported elements seem to be:

  Everyone: address, div, h*, p, pre
  Everyone but IE: blockquote
  Everyone but Opera: dd, dt
  IE only: dir, menu, ol, ul
  Firefox and Chrome only: dl
  Chrome only: article, aside, footer, header, hgroup, nav, section

  HTML5 as of May 2011 supports: address, article, aside, blockquote, div,
  footer, h*, header, hgroup, nav, p, pre, section, which exactly matches
  Chrome except minus dd/dt/dl.

  See mailing list discussion on the subject:
  http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-May/031765.html
  -->

  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node list</var> be an empty list of [[nodes]].

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  append <var>node</var> to <var>node list</var> if it is
  <span>editable</span>, the last member of <var>original node list</var> (if
  any) is not an [[ancestor]] of <var>node</var>, <var>node</var> is either a
  <span>non-list single-line container</span> or an <span>allowed child</span>
  of "p" or a [[dd]] or [[dt]], and <var>node</var> is not the [[ancestor]] of
  a <span>prohibited paragraph child</span>.

  <li><span>Record the values</span> of <var>node list</var>, and let
  <var>values</var> be the result.

  <li>For each <var>node</var> in <var>node list</var>, while <var>node</var>
  is the [[descendant]] of an <span>editable</span> <span>HTML element</span>
  <span>in the same editing host</span>, whose [[localname]] is a
  <span>formattable block name</span>, and which is not the [[ancestor]] of a
  <span>prohibited paragraph child</span>, <span>split the parent</span> of the
  one-[[node]] list consisting of <var>node</var>.
  <!--
  This tries to avoid misnesting if only some lines of an element are selected,
  so <h1>[foo]<br>bar</h1> becomes <p>[foo]</p><h1>bar</h1> instead of
  <h1><p>[foo]</p><br>bar</h1> or such.  It tries to heuristically distinguish
  between divs used as line-breakers and divs used as actual wrappers by
  checking if they have prohibited paragraph children as descendants.  It works
  for address too, in case there are paragraphs nested inside.  Thus
  <address>[foo]<br>bar</address> becomes <p>[foo]</p><address>bar</address>,
  but <address>[foo]<p>bar</p></address> becomes
  <address><p>[foo]</p><p>bar</p></address>.  Likewise, we don't break things
  out of lists or tables or such if they happen to be nested in a <div>.
  -->

  <li><span>Restore the values</span> from <var>values</var>.

  <!--
  We have two different behaviors, one for div and p and one for everything
  else.  The basic difference is that for div and p, we assume that it should
  be one line per element, while for other elements, we put in multiple lines
  separated by <br>.  So if you do formatBlock to p on

    <div>foo</div><div>bar</div> or
    foo<br>bar

  you get

    <p>foo</p><p>bar</p>

  but formatBlock to h1 will get you

    <h1>foo<br>bar</h1>.

  IE9 will just change the elements as they are, so it gives
  <p>foo</p><p>bar</p> and <h1>foo</h1><h1>bar</h1> for
  <div>foo</div><div>bar</div>, but <p>foo<br>bar</p> and <h1>foo<br>bar</h1>
  for foo<br>bar.  This is unreasonable, because the two possible inputs here
  look identical to the user and might have been produced by identical user
  input.

  Firefox 5.0a2 will give results like <p>foo</p><p>bar</p> or
  <h1>foo</h1><h1>bar</h1> no matter what (modulo oddities in its handling of
  divs).  Opera 11.10 is similar, except it leaves a trailing <br> in the first
  element.

  Chrome 13 dev will give results like <p>foo<br>bar</p> or <h1>foo<br>bar</h1>
  no matter what.

  The specced behavior is a compromise between the existing behaviors,
  predicated on the fact that <h1>foo</h1><h1>bar</h1> almost never makes
  sense, and <p>foo<br>bar</p> isn't usually what's wanted either.
  -->
  <li>While <var>node list</var> is not empty:

  <ol>
    <li>If the first member of <var>node list</var> is a <span>single-line
    container</span>:

    <ol>
      <!--
      If you try to format a single-line container with no children, IE10PP2
      inserts an nbsp before formatting.  (It uses nbsp instead of <br> to make
      blocks not collapse, so the equivalent for us would be to insert a <br>.)
      Firefox 7.0a2 and Opera 11.50 make the element disappear.  Chrome 14 dev
      leaves it alone and doesn't format it.  I follow Firefox/Opera just
      because it's the simplest given how I happen to have written the spec,
      and it's a corner case, so exact behavior isn't important.

      For blocks that contain only a collapsed whitespace node, IE10PP2 and
      Firefox 7.0a2 convert them like normal.  Chrome 14 dev and Opera 11.50
      leave it alone and don't format it.  I go with the majority, which is
      again simpler to spec.
      -->
      <li>Let <var>sublist</var> be the [[children]] of the first member of
      <var>node list</var>.

      <li><span>Record the values</span> of <var>sublist</var>, and let
      <var>values</var> be the result.

      <li>Remove the first member of <var>node list</var> from its [[parent]],
      <span>preserving its descendants</span>.

      <li><span>Restore the values</span> from <var>values</var>.

      <li>Remove the first member from <var>node list</var>.
    </ol>

    <li>Otherwise:

    <ol>
      <li>Let <var>sublist</var> be an empty list of [[nodes]].

      <li>Remove the first member of <var>node list</var> and append it to
      <var>sublist</var>.

      <li>While <var>node list</var> is not empty, and the first member of
      <var>node list</var> is the [[nextsibling]] of the last member of
      <var>sublist</var>, and the first member of <var>node list</var> is not a
      <span>single-line container</span>, and the last member of
      <var>sublist</var> is not a [[br]], remove the first member of <var>node
      list</var> and append it to <var>sublist</var>.
    </ol>

    <li><span>Wrap</span> <var>sublist</var>.  If <var>value</var> is "div" or
    "p", <span>sibling criteria</span> match nothing; otherwise they match any
    <span>HTML element</span> with [[localname]] <var>value</var> and no
    attributes.  <span>New parent instructions</span> return the result of
    running [[createelement|<var>value</var>]] on the [[contextobject]].  Then
    <span>fix disallowed ancestors</span> of the result.
  </ol>
</ol>

<p><span>Indeterminate</span>:
<!--
Firefox 6.0a2 throws, Chrome 14 dev always returns false, Opera 11.11 doesn't
support indeterm to start with, IE9 was uncooperative in testing so I'm not
sure what it does.  I'm speccing it just because it makes sense.
-->
<ol>
  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node list</var> be all <span>visible</span>
  <span>editable</span> [[nodes]] that are [[contained]] in <var>new
  range</var> and have no [[children]].

  <li>If <var>node list</var> is empty, return false.

  <li>Let <var>type</var> be null.

  <li>For each <var>node</var> in <var>node list</var>:

  <ol>
    <li>While <var>node</var>'s [[parent]] is <span>editable</span> and
    <span>in the same editing host</span> as <var>node</var>, and
    <var>node</var> is not an <span>HTML element</span> whose [[localname]]
    is a <span>formattable block name</span>, set <var>node</var> to its
    [[parent]].

    <li>Let <var>current type</var> be the empty string.

    <li>If <var>node</var> is an <span>editable</span> <span>HTML
    element</span> whose [[localname]] is a <span>formattable block
    name</span>, and <var>node</var> is not the [[ancestor]] of a
    <span>prohibited paragraph child</span>, set <var>current type</var> to
    <var>node</var>'s [[localname]].

    <li>If <var>type</var> is null, set <var>type</var> to <var>current
    type</var>.

    <li>Otherwise, if <var>type</var> does not equal <var>current type</var>,
    return true.
  </ol>

  <li>Return false.
</ol>

<p><span>Value</span>:
<!--
IE9 returns human-readable strings like "Normal" (p/div/etc.), "Formatted"
(pre), "Heading 1" (h1), etc.  Firefox 6.0a2 and Chrome 14 dev both return the
appropriate tag name in lowercase, or the empty string if there is no
appropriate tag.  Opera 11.11 behaves the same, but with uppercase.

IE9 looks like it recognizes address, h*, pre, dd, dt, ol, ul, and dir, with
everything else registering as "Normal".  Firefox 6.0a2 recognizes only the
arguments it accepts for formatBlock, namely address, h*, p, and pre.  Chrome
14 dev recognizes address, div, h*, dd, dl, dt, p, pre plus lots of random
other stuff like blockquote and section.  I'll go with everything that
execCommand("formatblock") accepts as an argument, which at the time of this
writing means what Firefox supports plus div.
-->
<ol>
  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node</var> be the first <span>visible</span>
  <span>editable</span> [[node]] that is [[contained]] in <var>new range</var>
  and has no [[children]].  If there is no such [[node]], return the empty
  string.

  <li>While <var>node</var>'s [[parent]] is <span>editable</span> and <span>in
  the same editing host</span> as <var>node</var>, and <var>node</var> is not
  an <span>HTML element</span> whose [[localname]] is a <span>formattable block
  name</span>, set <var>node</var> to its [[parent]].
  <!-- Opera 11.11 doesn't require it be editable, so it will return "DIV"
  instead of "" for <div contenteditable>foo</div>.  -->

  <li>If <var>node</var> is an <span>editable</span> <span>HTML element</span>
  whose [[localname]] is a <span>formattable block name</span>, and
  <var>node</var> is not the [[ancestor]] of a <span>prohibited paragraph
  child</span>, return <var>node</var>'s [[localname]], <span
  data-anolis-spec=domcore>converted to ASCII lowercase</span>.
  <!--
  Chrome 14 dev will report "div" for <div><ol><li>foo</ol></div> or such.
  Opera 11.11 reports "".  IE and Firefox didn't cooperate with testing.  Opera
  makes more sense, and matches the fact that formatBlock now doesn't recognize
  such a div as a formatBlock candidate, so Opera it is.

  We don't really need to specify "editable", since it has to be editable.
  -->

  <li>Return the empty string.
</ol>

<!-- @} -->
<h3><dfn>The <code title>forwardDelete</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:
<!-- Copy-pasted from delete, see there for comments. -->

<ol>
  <li>If the <span>active range</span> is not <code data-anolis-spec=domrange
  title=dom-Range-collapsed>collapsed</code>, <span>delete the contents</span>
  of the <span>active range</span> and abort these steps.

  <li><span>Canonicalize whitespace</span> at (<span>active range</span>'s
  [[startnode]], <span>active range</span>'s [[startoffset]]).

  <li>Let <var>node</var> and <var>offset</var> be the <span>active
  range</span>'s [[rangestart]] [[bpnode]] and [[bpoffset]].

  <li>Repeat the following steps:

  <ol>
    <li>If <var>offset</var> is the [[nodelength]] of <var>node</var> and
    <var>node</var>'s [[nextsibling]] is an <span>editable</span>
    <span>invisible</span> [[node]], remove <var>node</var>'s [[nextsibling]]
    from its [[parent]].

    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> and that [[child]] is an <span>editable</span>
    <span>invisible</span> [[node]], remove that [[child]] from
    <var>node</var>.

    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> and that [[child]] is a <span>collapsed block
    prop</span>, add one to <var>offset</var>.

    <li>Otherwise, if <var>offset</var> is the [[nodelength]] of
    <var>node</var> and <var>node</var> is an <span>inline node</span>, or if
    <var>node</var> is <span>invisible</span>, set <var>offset</var> to one
    plus the [[index]] of <var>node</var>, then set <var>node</var> to its
    [[parent]].

    <li>Otherwise, if <var>node</var> has a [[child]] with [[index]]
    <var>offset</var> and that [[child]] is not a <span>block node</span> or a
    [[br]] or an [[img]], set <var>node</var> to that [[child]], then set
    <var>offset</var> to zero.

    <li>Otherwise, break from this loop.
  </ol>

  <li>If <var>node</var> is a [[text]] node and <var>offset</var> is not
  <var>node</var>'s [[nodelength]]:

  <ol>
    <li>Call [[selcollapse|<var>node</var>, <var>offset</var>]] on the
    [[selection]].

    <li>Let <var>end offset</var> be <var>offset</var> plus one.

    <li>While <var>end offset</var> is not <var>node</var>'s [[length]] and the
    <var>end offset</var>th [[strel]] of <var>node</var>'s [[cddata]] has
    general category M when interpreted as a Unicode code point, add one to
    <var>end offset</var>.
    <!-- TODO: This is probably not right.  We probably want to normalize to
    grapheme cluster boundaries, using UAX#29 or something.  We also need to
    handle non-BMP stuff.  The idea is that if the cursor is before a character
    that precedes a combining mark, you need to delete the combining mark too.
    -->

    <li><span>Delete the contents</span> of the [[range]] with [[rangestart]]
    (<var>node</var>, <var>offset</var>) and [[rangeend]] (<var>node</var>,
    <var>end offset</var>).

    <li>Abort these steps.
  </ol>

  <li>If <var>node</var> is an <span>inline node</span>, abort these steps.

  <li>If <var>node</var> has a [[child]] with [[index]] <var>offset</var> and
  that [[child]] is a [[br]] or [[hr]] or [[img]], call
  [[selcollapse|<var>node</var>, <var>offset</var>]] on the [[selection]].
  Then <span>delete the contents</span> of the [[range]] with [[rangestart]]
  (<var>node</var>, <var>offset</var>) and [[rangeend]] (<var>node</var>,
  <var>offset</var> + 1) and abort these steps.

  <!-- No special list-item behavior for forwardDelete. -->

  <li>Let <var>end node</var> equal <var>node</var> and let <var>end
  offset</var> equal <var>offset</var>.

  <li>Repeat the following steps:

  <ol>
    <li>If <var>end offset</var> is the [[length]] of <var>end node</var>, set
    <var>end offset</var> to one plus the [[index]] of <var>end node</var> and
    then set <var>end node</var> to its [[parent]].

    <li>Otherwise, if <var>end node</var> has a an <span>editable</span>
    <span>invisible</span> [[child]] with [[index]] <var>end offset</var>,
    remove it from <var>end node</var>.

    <li>Otherwise, break from this loop.
  </ol>

  <!-- No special indentation element behavior for forwardDelete. -->

  <li>If the [[child]] of <var>end node</var> with [[index]] <var>end
  offset</var> minus one is a [[table]], abort these steps.

  <li>If the [[child]] of <var>end node</var> with [[index]] <var>end
  offset</var> is a [[table]]:

  <ol>
    <li>Call [[selcollapse|<var>end node</var>, <var>end offset</var>]] on the
    [[contextobject]]'s [[selection]].

    <li>Call [[extend|<var>end node</var>, <var>end offset</var> + 1]] on the
    [[contextobject]]'s [[selection]].

    <li>Abort these steps.
  </ol>

  <li>If <var>offset</var> is the [[length]] of <var>node</var>, and the
  [[child]] of <var>end node</var> with [[index]] <var>end offset</var> is an
  [[hr]] or [[br]]:
  <!-- Note, any br will do here: a br immediately after a block is always
  significant. -->

  <ol>
    <li>Call [[selcollapse|<var>node</var>, <var>offset</var>]] on the
    [[selection]].

    <li><span>Delete the contents</span> of the [[range]] with [[rangeend]]
    (<var>end node</var>, <var>end offset</var>) and [[rangeend]] (<var>end
    node</var>, <var>end offset</var> + 1).

    <li>Abort these steps.
  </ol>

  <!-- No special list-item behavior for forwardDelete. -->

  <li>While <var>end node</var> has a [[child]] with [[index]] <var>end
  offset</var>:

  <ol>
    <li>If <var>end node</var>'s [[child]] with [[index]] <var>end offset</var>
    is <span>editable</span> and <span>invisible</span>, remove it from
    <var>end node</var>.

    <li>Otherwise, set <var>end node</var> to its [[child]] with [[index]]
    <var>end offset</var> and set <var>end offset</var> to zero.
  </ol>

  <li><span>Delete the contents</span> of the [[range]] with [[rangestart]]
  (<var>node</var>, <var>offset</var>) and [[rangeend]] (<var>end node</var>,
  <var>end offset</var>).
</ol>

<!-- @} -->
<h3><dfn>The <code title>indent</code> command</dfn></h3>
<!-- @{ -->
<!--
IE9: Outputs <blockquote style="margin-right: 0px" dir="ltr">, or when
  surrounding RTL blocks, <blockquote style="margin-left: 0px" dir="rtl">.  The
  direction seems to go by the end of the selection.  The presence of the dir
  attribute means that any contents that were inheriting a different dir from
  an ancestor get their direction changed as a side effect, but if they
  actually have the opposite dir specified, they won't appear to be indented.
  It doesn't reset top or bottom margins on the blockquote, so it adds them.
  If it's not wrapping a block element, like if it's only wrapping up until a
  <br>, it adds a <p>.
Firefox 4.0: In styleWithCSS mode, adds style="margin-left: 40px" to the
  appropriate block container (or margin-right if it's RTL).  If there's no
  appropriate block container, adds a div.  If multiple blocks are affected, it
  goes by the direction of the block whose style it's changing, which winds up
  being wrong for descendants with different direction.  In non-styleWithCSS
  mode, uses <blockquote>, so it indents on both sides and also adds top/bottom
  margins.
Chrome 12 dev: Outputs <blockquote class="webkit-indent-blockquote"
  style="margin: 0 0 0 40px; border: none; padding: 0px"> in both modes for
  both LTR and RTL (which is broken for RTL, since it indents only on the
  left).
Opera 11.00: Outputs <blockquote>, so it indents on both sides and on the
  top/bottom.

For repeated indentation, everyone except Opera that outputs <blockquote>s just
puts them at the outermost possible location, which works well.  Opera puts
them in the innermost position, which is broken, because it will even put them
inside <p> (which will not round-trip through text/html serialization).

Gecko in CSS mode messes up by adding margins even to things like <blockquote>
that already have margins from CSS rules, instead of nesting a div, so it
doesn't actually increase the indentation.  However, if an element has an
explicit left margin (assuming LTR), it will increase the margin to 80px, so it
works with WebKit's blockquotes.


We have two strategies for handling directionality: always indent on both sides
(Firefox non-CSS, Opera) or try to figure out heuristically which side we want
(IE, Firefox CSS).  The latter approach is only possible by adding extra markup
and complexity, so for now we'll take the easy way out and go with just
indenting on both sides.


This reasoning doesn't discuss lists.  For research on lists, see the comment
for insertOrderedList.  List handling is more complicated and I wound up
differing from all browsers in lots of ways.
-->

<p><span>Action</span>:

<ol>
  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the <span>active range</span>'s [[rangestart]]
  and/or [[rangeend]] [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  if <var>node</var> is <span>editable</span> and is an <span>allowed
  child</span> of "div" or "ol" and if the last member of <var>node list</var>
  (if any) is not an [[ancestor]] of <var>node</var>, append <var>node</var> to
  <var>node list</var>.

  <li>If the first member of <var>node list</var> is an [[li]] whose [[parent]]
  is an [[ol]] or [[ul]], and its [[previoussibling]] is an [[li]] as well,
  <span>normalize sublists</span> of its [[previoussibling]].
  <!-- Otherwise the last child of the previous sibling might be a list, which
  the li wouldn't get appended to. -->

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>Let <var>sublist</var> be a list of [[nodes]], initially empty.

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>While the first member of <var>node list</var> is the [[nextsibling]]
    of the last member of <var>sublist</var>, remove the first member of
    <var>node list</var> and append it to <var>sublist</var>.

    <li><span>Indent</span> <var>sublist</var>.
  </ol>
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertHorizontalRule</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!-- You'd think interop here would be simple, right?  Nope: we have three
different behaviors across four browsers.  Opera 11.00 is the only one that
acts more or less like the spec.  IE9 and Chrome 12 dev treat the value as an
id, which is weird and probably useless, so I don't do it.  Firefox 4.0
produces <hr size=2 width=100%> instead of <hr>, which is also weird and almost
definitely useless, so I don't do it.  Then you have the varying behavior in
splitting up parents to ensure validity . . . -->
<ol>
  <li>Let <var>range</var> be the <span>active range</span>.

  <li>While <var>range</var>'s [[startoffset]] is 0 and its [[startnode]]'s
  [[parent]] is not null, set <var>range</var>'s [[rangestart]] to ([[parent]]
  of [[startnode]], [[index]] of [[startnode]]).

  <li>While <var>range</var>'s [[endoffset]] is the [[nodelength]] of its
  [[endnode]], and its [[endnode]]'s [[parent]] is not null, set
  <var>range</var>'s [[rangeend]] to ([[parent]] of [[endnode]], 1 + [[index]]
  of [[startnode]]).

  <li><span>Delete the contents</span> of <var>range</var>, with <var>block
  merging</var> false.

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <!-- We don't want to call insertNode at the start or end of a text node,
  because that will leave an empty text node. -->
  <li>If the <span>active range</span>'s [[startnode]] is a [[text]] node and
  its [[startoffset]] is zero, set the <span>active range</span>'s
  [[rangestart]] and [[rangeend]] to ([[parent]] of [[startnode]], [[index]] of
  [[startnode]]).

  <li>If the <span>active range</span>'s [[startnode]] is a [[text]] node and
  its [[startoffset]] is the [[length]] of its [[startnode]], set the
  <span>active range</span>'s [[rangestart]] and [[rangeend]] to ([[parent]] of
  [[startnode]], 1 + [[index]] of [[startnode]]).

  <li>Let <var>hr</var> be the result of calling [[createelement|"hr"]] on the
  [[contextobject]].

  <li>Run [[insertnode|<var>hr</var>]] on <var>range</var>.

  <li><span>Fix disallowed ancestors</span> of <var>hr</var>.
  <!--
  IE9 and Chrome 13 dev seem to never break up any ancestors, which can lead to
  unserializable DOMs like <hr> inside <p>.  Opera 11.11 seems to always break
  up parents going all the way up to the contenteditable root, even ones like
  <div> that can contain <hr>.  Firefox 5.0a2 acts the most sensibly: it only
  breaks up things like <p> or <b> that shouldn't contain <hr>.  The spec goes
  with Firefox here (although the list of what to break up isn't precisely
  identical).
  -->

  <li>Let <var>selection</var> be the result of running [[getselection]] on the
  [[contextobject]].

  <li>Run [[selcollapse|]] on <var>selection</var>, with first argument equal
  to the [[parent]] of <var>hr</var> and the second argument equal to one plus
  the [[index]] of <var>hr</var>.
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertHTML</code> command</dfn></h3>
<!-- @{ -->
<!--
Not supported by IE9.  Handling of disallowed children is interesting:

Firefox 5.0a2: Will allow <dt> inside <dt> (doesn't serialize).  If you try
inserting dir/ol/ul inside an existing dir/ol/ul, it will strip the list
element and leave only the li's, so inserting <ul><li>abc</ul> into
<ol><li>f[o]o</ol> creates <ol><li>f<li>abc<li>o</ol>.  <dt>/<dd>/<li> that
don't descend from a list will be left alone, not converted to <p>.  Empty
elements seem not to be inserted.  <li> will get put inside <p>, which breaks
serialization.  Nothing is allowed inside <xmp>, not even text.

Chrome 13 dev: Inserting a <p> into a <p> or <li> or such will remove the child
<p>, adding its contents to the parent instead.  Adding an <li> or <hr> as the
child of a <p> works, as does an <a> inside an <a>, <h2> inside <h1>, <li>
inside <li>, <nobr> inside <nobr>, <b> inside <xmp>, etc. (all unserializable).
But <dt> and <dd> seem to get converted to their contents like <p>.
<ol><li>abc</ol> inside <ol><li>f[o]o</ol> becomes
<ol><li>f<li>abc<li><li>o</ol>, interestingly (note the empty <li>).  I don't
understand how it works, but it doesn't seem to make much sense.

Opera 11.11: Seems to do almost no validity or serialization checks, except
that it prevents <a> inside <a>, <nobr> inside <nobr>, and block elements
inside inline elements.  Interestingly, most of the places where it's
non-serializable per HTML parsing are actually serializable in Opera's own
parser.
-->

<p><span>Action</span>:

<ol>
  <li><span>Delete the contents</span> of the <span>active range</span>.
  <!--
  Chrome 14 dev and Opera 11.11 do this even if the value is empty.  Firefox
  5.0a2 throws an exception.

  Firefox 7.0a2 and Chrome 14 dev do strip wrappers here, so inserting HTML in
  the place of <b>[foo]</b> will remove the <b>.  Opera 11.50 keeps the
  wrappers.  I follow the majority.
  -->

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <li>Let <var>frag</var> be the result of calling <code data-anolis-spec=domps
  title=dom-Range-createContextualFragment>createContextualFragment(<var>value</var>)</code>
  on the <span>active range</span>.
  <!--
  TODO: This has some interesting consequences.  For instance, table cells and
  similar will just vanish if they're not in an appropriate place; and inside a
  script or style or xmp or such, the argument will effectively be HTML-escaped
  before use.  Some of these consequences might be undesirable.
  -->

  <li>Let <var>last child</var> be the [[lastchild]] of <var>frag</var>.

  <li>If <var>last child</var> is null, abort these steps.
  <!-- Firefox 5.0a2 also seems to not add empty elements like <b></b>, but
  Chrome 13 dev and Opera 11.11 do. -->

  <li>Let <var>descendants</var> be all [[descendants]] of <var>frag</var>.

  <li>If the <span>active range</span>'s [[startnode]] is a <span>block
  node</span> whose sole [[child]] is a [[br]], and its [[startoffset]] is 0,
  remove its [[startnode]]'s [[child]] from it.
  <!--
  This is so we don't get something like
    <div>[foo]</div>
    -> <div>{}<br></div>
    -> <div><p>Some HTML{}</p><br></div>
  with an extra bogus line break at the end.
  -->

  <li>Call [[insertnode|<var>frag</var>]] on the <span>active range</span>.

  <!--
  We could canonicalize whitespace at this point, but let's not.  If the author
  wants HTML, give them HTML behavior.  When asked to replace a paragraph's
  contents with a single space, Firefox 7.0a2 does so but inserts a <br> before
  it (not after); Chrome 14 dev does so and doesn't insert a <br>, so the
  paragraph collapses; Opera 11.50 doesn't insert the space at all, and just
  inserts a <br>.  Correct behavior is to insert a space, then insert a <br>
  after it in the next step because it's an invisible node.
  -->

  <li>If the <span>active range</span>'s [[startnode]] is a <span>block
  node</span> with no <span>visible</span> [[children]], call
  [[createelement|"br"]] on the [[contextobject]] and append the result as the
  last child of the <span>active range</span>'s [[startnode]].
  <!-- In case we remove all the contents, then remove the extra <br>, then
  only add a comment or something.  In that case we want to re-add the extra
  <br>.  We don't try fixing the actual inserted content: that's the author's
  lookout. -->

  <li>Call [[selcollapse|]] on the [[contextobject]]'s [[selection]], with
  <var>last child</var>'s [[parent]] as the first argument and one plus its
  [[index]] as the second.
  <!-- Need to do this before fixing disallowed ancestors, since otherwise the
  last child might have been removed (e.g., it's an li). -->

  <li><span>Fix disallowed ancestors</span> of each member of
  <var>descendants</var>.
  <!-- We want to fix all descendants, not just children.  Consider
  <div><li>foo</li></div>, for example. -->
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertImage</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<ol>
  <li>If <var>value</var> is the empty string, abort these steps and do
  nothing.
  <!-- Similar logic to createLink, except even more compelling, since an HTML
  document linking to itself as an image is just silly.  In fact, the current
  HTML spec instructs UAs to not even try displaying the image, and just fail
  immediately if the URL is empty.  Firefox 4b11 silently does nothing on an
  empty string, but the other three browsers I tested stick in the <img>
  anyway. -->

  <li>Let <var>range</var> be the <span>active range</span>.

  <li><span>Delete the contents</span> of <var>range</var>, with <var>strip
  wrappers</var> false.
  <!--
  Firefox 7.0a2 seems to strip the wrapper or not depending on the exact
  positioning of the selection: <b>{foo}</b> yes, <b>[foo]</b> no.  Chrome 14
  dev seems to strip the wrapper regardless.  Opera 11.50 seems to keep the
  wrapper, but place the image outside it.  I didn't get IE to cooperate with
  my tests.  I chose to leave wrappers across the board because they might be
  meaningful: e.g., a background-color when the image is small or not fully
  opaque.
  -->

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <li>If <var>range</var>'s [[startnode]] is a <span>block node</span> whose
  sole [[child]] is a [[br]], and its [[startoffset]] is 0, remove its
  [[startnode]]'s [[child]] from it.
  <!-- Same logic as with insertHTML. -->

  <li>Let <var>img</var> be the result of calling [[createelement|"img"]] on
  the [[contextobject]].

  <li>Run [[setattribute|"src", <var>value</var>]] on <var>img</var>.
  <!-- No alt text, so it's probably invalid.  This matches all browsers. -->

  <li>Run [[insertnode|<var>img</var>]] on <var>range</var>.
  <!--
  This winds up putting it at the original start point of the active range, as
  currently specced.  This matches IE9 and Firefox 5.0a2.  Chrome 13 dev puts
  it at the end point, and Opera 11.11 puts it in between (where the range
  would collapse if you called deleteContents()).
  -->

  <li>Let <var>selection</var> be the result of calling [[getselection]] on the
  [[contextobject]].

  <li>Run [[selcollapse|]] on <var>selection</var>, with first argument equal
  to the [[parent]] of <var>img</var> and the second argument equal to one plus
  the [[index]] of <var>img</var>.
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertLineBreak</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<!--
Only implemented in WebKit (Chrome 14 dev).  Other tests are entirely manual.
There's a surprisingly large amount of interop.

IE9 is tripped up by <xmp>, and also often doesn't add an extra <br> when the
one it just inserted is extraneous.

Firefox 6.0a2 doesn't notice if you're trying to put the <br> in a bad place,
which can result in unserializable DOMs.

Chrome 14 dev inserts a literal linebreak for pre and xmp and maybe other
similar elements.  This doesn't seem very useful, so I don't bother.

Opera 11.11 isn't heedful of <xmp>, and treats <pre> somewhat oddly.
-->

<ol>
  <li><span>Delete the contents</span> of the <span>active range</span>, with
  <var>strip wrappers</var> false.
  <!--
  IE9 doesn't strip wrappers (IE10PP2 didn't work in tests).  Firefox 7.0a2
  strips wrappers inconsistently depending on the exact selection endpoints.
  Chrome 14 dev strips wrappers but recreates any styles using new wrappers.
  Opera 11.50 strips all wrappers.
  -->

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <li>If the <span>active range</span>'s [[startnode]] is an [[element]], and
  "br" is not an <span>allowed child</span> of it, abort these steps.
  <!-- script, xmp, table, . . . -->

  <li>If the <span>active range</span>'s [[startnode]] is not an [[element]],
  and "br" is not an <span>allowed child</span> of the <span>active
  range</span>'s [[startnode]]'s [[parent]], abort these steps.

  <!-- We don't want to call insertNode at the start or end of a text node,
  because that will leave an empty text node. -->
  <li>If the <span>active range</span>'s [[startnode]] is a [[text]] node and
  its [[startoffset]] is zero, set the <span>active range</span>'s
  [[rangestart]] and [[rangeend]] to ([[parent]] of [[startnode]], [[index]] of
  [[startnode]]).

  <li>If the <span>active range</span>'s [[startnode]] is a [[text]] node and
  its [[startoffset]] is the [[length]] of its [[startnode]], set the
  <span>active range</span>'s [[rangestart]] and [[rangeend]] to ([[parent]] of
  [[startnode]], 1 + [[index]] of [[startnode]]).

  <li>Let <var>br</var> be the result of calling [[createelement|"br"]] on the
  [[contextobject]].

  <li>Call [[insertnode|<var>br</var>]] on the <span>active range</span>.

  <li>Call [[selcollapse|]] on the [[contextobject]]'s [[selection]], with
  <var>br</var>'s [[parent]] as the first argument and one plus <var>br</var>'s
  [[index]] as the second argument.

  <li>If <var>br</var> is a <span>collapsed line break</span>, call
  [[createelement|"br"]] on the [[contextobject]] and let <var>extra br</var>
  be the result, then call [[insertnode|<var>extra br</var>]] on the
  <span>active range</span>.
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertOrderedList</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Toggle lists</span> with <var>tag name</var>
"ol".

<p><span>Indeterminate</span>: True if the <span>selection's list state</span>
is "mixed" or "mixed ol", false otherwise.
<!--
Firefox 6.0a2 sort of supports this, but it throws exceptions most of the
time.  It has the quirk that even if there are no ol's around, it will say it's
indeterminate if there are some things that are ul's and some that are not
lists at all, but this doesn't make sense and I don't duplicate it.  No one
else supports indeterminate for insert*List, but it makes sense if you support
state.
-->

<p><span>State</span>: True if the <span>selection's list state</span> is "ol",
false otherwise.
<!--
IE9 throws exceptions in most cases, Firefox 6.0a2 in some cases as well, for
no apparent reason.  Ignoring those, the spec basically matches all browsers,
except with a few weird random mismatches that looked like browser bugs to me.
-->

<!-- @} -->
<h3><dfn>The <code title>insertParagraph</code> command</dfn></h3>
<!-- @{ -->
<!--
There are three major behaviors here.  Firefox 5.0a2 behaves identically to
execCommand("formatBlock", false, "p"), which is not really useful.  IE9
actually just overwrites the selection with an empty paragraph element, which
seems not very useful either.  Chrome 13 dev and Opera 11.10 behave basically
the same as if the user hit the Return key.  This latter behavior seems much
more useful, even though it's horribly misnamed, so it's what I'll spec.

(Actually, Opera doesn't behave quite the same for insertParagraph and line
breaks.  But it's pretty close, and I expect the differences are bugs.)

Then, of course, we have several flavors of line-breaking behavior to choose
from.  Firefox prefers <br>s, unless it's in the middle of a <p> or something.
Opera and IE like <p>.  Chrome prefers <div>.  And there are lots of subtleties
besides.  I go with IE/Opera-style behavior, as discussed in this thread:

http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2011-May/031577.html
-->

<p><span>Action</span>:

<ol>
  <li><span>Delete the contents</span> of the <span>active range</span>.

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <li>Let <var>range</var> be the <span>active range</span>.

  <li>Let <var>node</var> and <var>offset</var> be <var>range</var>'s
  [[rangestart]] [[bpnode]] and [[bpoffset]].

  <li>If <var>node</var> is a [[text]] node, and <var>offset</var> is neither 0
  nor the [[nodelength]] of <var>node</var>, call
  [[splittext|<var>offset</var>]] on <var>node</var>.

  <li>If <var>node</var> is a [[text]] node and <var>offset</var> is its
  [[nodelength]], set <var>offset</var> to one plus the [[index]] of
  <var>node</var>, then set <var>node</var> to its [[parent]].

  <li>If <var>node</var> is a [[text]] or [[comment]] node, set
  <var>offset</var> to the [[index]] of <var>node</var>, then set
  <var>node</var> to its [[parent]].

  <li>Set <var>range</var>'s [[rangestart]] and [[rangeend]] to
  (<var>node</var>, <var>offset</var>).

  <li>Let <var>container</var> equal <var>node</var>.

  <li>While <var>container</var> is not a <span>single-line container</span>,
  and <var>container</var>'s [[parent]] is <span>editable</span> and <span>in
  the same editing host</span> as <var>node</var>, set <var>container</var> to
  its [[parent]].

  <li>If <var>container</var> is not <span>editable</span> or not <span>in the
  same editing host</span> as <var>node</var> or is not a <span>single-line
  container</span>:
  <!-- Add the default wrapper. -->

  <ol>
    <li>Let <var>tag</var> be the <span>default single-line container
    name</span>.

    <li><span>Block-extend</span> <var>range</var>, and let <var>new
    range</var> be the result.

    <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

    <li>Append to <var>node list</var> the first [[node]] in [[treeorder]] that
    is [[contained]] in <var>new range</var> and is an <span>allowed
    child</span> of "p", if any.

    <li>If <var>node list</var> is empty:

    <ol>
      <!-- Ideally, we should normalize things so that the cursor is never in a
      weird place after deletion, but let's be safe and bail out if we do hit
      this scenario.  It's not clear if we need this line in the long term, but
      at the time of this writing there's at least one corner case where
      deleting can leave the cursor inside a <tr>. -->
      <li>If <var>tag</var> is not an <span>allowed child</span> of
      <var>range</var>'s [[startnode]], abort these steps.

      <li>Set <var>container</var> to the result of calling
      [[createelement|<var>tag</var>]] on the [[contextobject]].

      <li>Call [[insertnode|<var>container</var>]] on <var>range</var>.

      <li>Call [[createelement|"br"]] on the [[contextobject]], and append the
      result as the last [[child]] of <var>container</var>.

      <li>Set <var>range</var>'s [[rangestart]] and [[rangeend]] to
      (<var>container</var>, 0).

      <li>Abort these steps.
    </ol>

    <li>While the [[nextsibling]] of the last member of <var>node list</var> is
    not null and is an <span>allowed child</span> of "p", append it to
    <var>node list</var>.
    <!--
    TODO: It is not at all obvious that this is the correct list of nodes in
    all cases.  It should probably work because of how the block-extend
    algorithm works, but further thought would be good.
    -->

    <li><span>Wrap</span> <var>node list</var>, with <span>sibling
    criteria</span> matching nothing and <span>new parent instructions</span>
    returning the result of calling [[createelement|<var>tag</var>]] on the
    [[contextobject]].  Set <var>container</var> to the result.
  </ol>

  <li>If <var>container</var>'s [[localname]] is "address", "listing", or
  "pre":
  <!--
  IE9 and Chrome 13 dev just break <pre> up into multiple <pre>s.  Firefox
  5.0a2 and Opera 11.10 insert a <br> instead, treating it differently from
  <p>.  The latter makes more sense.  What might make the most sense is to just
  insert an actual newline character, though, since this is a pre after all
  . . .

  IE9 and Chrome 13 dev also break <address> up into multiple <address>es.
  Firefox 5.0a2 inserts <br> instead.  Opera 11.10 nests <p>s inside.  I don't
  like Opera's behavior, because it means we nest formatBlock candidates inside
  one another, so I'll go with Firefox.

  listing and xmp work the same as pre in all browsers.  For Firefox and Opera,
  this results in trying to put a br inside an xmp, so I go with IE/Chrome for
  xmp.

  TODO: In cases where hitting enter in a header doesn't break out of the
  header, we should probably follow this code path too, instead of creating an
  adjoining header.  No browser does this, though, so we don't.
  -->

  <ol>
    <li>Let <var>br</var> be the result of calling [[createelement|"br"]] on
    the [[contextobject]].

    <li>Call [[insertnode|<var>br</var>]] on <var>range</var>.

    <li>Increment <var>range</var>'s [[rangestart]] and [[rangeend]]
    [[bpoffsets]].

    <li>If <var>br</var> is the last [[descendant]] of <var>container</var>,
    let <var>br</var> be the result of calling [[createelement|"br"]] on the
    [[contextobject]], then call [[insertnode|<var>br</var>]] on
    <var>range</var>.
    <!-- Necessary because adding a br to the end of a block element does
    nothing if there wasn't one there already.  A single newline immediately
    preceding a block boundary does nothing. -->

    <li>Abort these steps.
  </ol>

  <li>If <var>container</var>'s [[localname]] is "li", "dt", or "dd"; and
  either it has no [[children]] or it has a single [[child]] and that [[child]]
  is a [[br]]:
  <!-- Including dt/dd here follows Firefox 5.0a2, as with the special dt/dd
  handling below. -->

  <ol>
    <li><span>Split the parent</span> of the one-[[node]] list consisting of
    <var>container</var>.

    <li>If <var>container</var> has no [[children]], call
    [[createelement|"br"]] on the [[contextobject]] and append the result as
    the last [[child]] of <var>container</var>.

    <li>If <var>container</var> is a [[dd]] or [[dt]], and it is not an
    <span>allowed child</span> of any of its [[ancestors]] <span>in the same
    editing host</span>, <span>set the tag name</span> of <var>container</var>
    to the <span>default single-line container name</span> and let
    <var>container</var> be the result.
    <!--
    Annoying hack to prevent the dl from being re-added when fixing disallowed
    ancestors.  In most cases we want a wrapper dl added, but in two cases
    (delete and insertParagraph) we're actually trying to outdent the list
    item.  There might be a better way to do this.
    -->

    <li><span>Fix disallowed ancestors</span> of <var>container</var>.

    <li>Abort these steps.
  </ol>

  <li>Let <var>new line range</var> be a new [[range]] whose [[rangestart]] is
  the same as <var>range</var>'s, and whose [[rangeend]] is
  (<var>container</var>, [[nodelength]] of <var>container</var>).

  <!-- We don't want the start to be just inside a node, because if it is,
  we'll leave behind an empty element either in the new or old container.
  Clearly we don't want the start point to get any higher than the container
  itself, though. -->
  <li>While <var>new line range</var>'s [[startoffset]] is zero and its
  [[startnode]] is not <var>container</var>, set its [[rangestart]] to
  ([[parent]] of [[startnode]], [[index]] of [[startnode]]).

  <li>While <var>new line range</var>'s [[startoffset]] is the [[nodelength]]
  of its [[startnode]] and its [[startnode]] is not <var>container</var>, set
  its [[rangestart]] to ([[parent]] of [[startnode]], 1 + [[index]] of
  [[startnode]]).

  <li>Let <var>end of line</var> be true if <var>new line range</var> <span
  data-anolis-spec=domrange title=contained>contains</span> either nothing or a
  single [[br]], and false otherwise.

  <li>If the [[localname]] of <var>container</var> is "h1", "h2", "h3", "h4",
  "h5", or "h6", and <var>end of line</var> is true, let <var>new container
  name</var> be the <span>default single-line container name</span>.
  <!-- IE9 makes a new header if there's a trailing <br>.  Firefox 5.0a2,
  Chrome 13 dev, and Opera 11.10 do not, and I follow them, since it makes more
  sense (such a <br> is invisible). -->

  <li>Otherwise, if the [[localname]] of <var>container</var> is "dt" and
  <var>end of line</var> is true, let <var>new container name</var> be "dd".

  <li>Otherwise, if the [[localname]] of <var>container</var> is "dd" and
  <var>end of line</var> is true, let <var>new container name</var> be "dt".
  <!-- These two follow Firefox 5.0a2.  IE9 and Chrome 13 dev act as though
  these two lines were not present (they clone the existing element).  Opera
  11.10 nests a <p> inside.  Firefox is the most useful, assuming a definition
  list somehow winds up inside the content. -->

  <li>Otherwise, let <var>new container name</var> be the [[localname]] of
  <var>container</var>.

  <li>Let <var>new container</var> be the result of calling
  [[createelement|<var>new container name</var>]] on the [[contextobject]].

  <li>Copy all attributes of <var>container</var> to <var>new container</var>.

  <li>If <var>new container</var> has an [[id]] attribute, unset it.

  <li>Insert <var>new container</var> into the [[parent]] of
  <var>container</var> immediately after <var>container</var>.

  <li>Let <var>contained nodes</var> be all [[nodes]] [[contained]] in <var>new
  line range</var>.

  <li>Let <var>frag</var> be the result of calling [[extractcontents]] on
  <var>new line range</var>.
  <!--
  TODO: This blows up any ranges (other than the selection, which we reset),
  and can alter non-editable nodes, and maybe other bad stuff.  May or may not
  be the best solution.  The intermediate fragment is also probably black-box
  detectable by DOM mutation events, but I like to pretend those don't exist.
  -->

  <li>Unset the [[id]] attribute (if any) of each [[element]] [[descendant]] of
  <var>frag</var> that is not in <var>contained nodes</var>.

  <li>Call [[appendchild|<var>frag</var>]] on <var>new container</var>.

  <li>If <var>container</var> has no <span>visible</span> [[children]], call
  [[createelement|"br"]] on the [[contextobject]], and append the result as the
  last [[child]] of <var>container</var>.

  <li>If <var>new container</var> has no <span>visible</span> [[children]],
  call [[createelement|"br"]] on the [[contextobject]], and append the result
  as the last [[child]] of <var>new container</var>.
  <!-- These two steps follow Firefox 5.0a2, Chrome 13 dev, and Opera 11.10.
  IE9 instead inserts an &nbsp; which magically does not appear in innerHTML.
  In all cases, the reason is that an empty block box in CSS will have zero
  height, so the user won't be able to put the selection cursor inside it. -->

  <li>Set the [[rangestart]] of <var>range</var> to (<var>new container</var>,
  0).
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertText</code> command</dfn></h3>
<!-- @{ -->
<!--
Supported only by WebKit.  Tests in other browsers were manual.  In the manual
tests, where the value was always "a", IE9 and Firefox 5.0a2 match the spec
exactly as far as I can tell; Chrome 14 dev and Opera 11.11 might match it in
theory, but normalize the selection first, so they don't match it in practice.
-->
<p><span>Action</span>:

<!--
Non-breaking space fun!  The issue: if the user hits space twice, they expect
it to create two spaces, not collapse.  Also, if they're at the beginning or
end of a line and hit space, again, they expect it not to collapse.  Since we
don't want to require that all contenteditable element contents always be used
only with white-space: pre-wrap, we need to convert to and from non-breaking
spaces.

But there's a catch: you can't just make spaces non-breaking willy-nilly,
because that doesn't just stop the space from collapsing, it also prevents
breaking.  (Chrome 14 dev actually cheats here: in contenteditable, it doesn't
collapse nbsp, but breaks after it like a regular space.)  The upshot of this
is that any nbsp needs to be followed by a space, or else it might end up at
the beginning of a line and be visible there; and it needs to be preceded by a
space, or else it might break a line prematurely.  How to achieve both of these
goals when there are an even number of spaces to display is left as an exercise
for the reader.

Browsers vary greatly in how they handle all this, of course!

The basic philosophy of IE9 is that if you're inserting a space, and one or
both of the neighboring characters is a space, change the neighboring
characters to non-breaking spaces.  This breaks if one of the neighboring
characters is part of a run of collapsed whitespace: "foo  []bar" becomes "foo
&nbsp; []bar", which converts one visible space to three.

Firefox 6.0a2 will sometimes convert the space you're inserting to an nbsp,
sometimes convert neighboring spaces to nbsps, and sometimes convert
neighboring nbsps to spaces.  I cannot discern any clear reason to when it
chooses what, except that it seems to prefer runs of nbsp's followed by a
single space (although not always).  I didn't find any outright bugs, except
the inevitable ones like nbsp's sometimes being right after letters.

Chrome 14 dev tries to normalize everything to look like " &nbsp; &nbsp; ...",
alternating with space then nbsp.  Unfortunately, it does so buggily, because
it converts collapsed spaces to nbsp's, so inserting a space before " " makes
it into " &nbsp; &nbsp;", which changes one visible space to four (or
arbitrarily many).

Opera 11.11 has varying behavior, like Firefox and Chrome.  Like Firefox, I
didn't discern an obvious pattern.

This was discussed: http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-June/032187.html

Unfortunately, we're stuck with this nbsp stuff, because of 1) legacy reasons,
2) mail clients might not support CSS equivalents, 3) authors might not know to
apply any CSS to wherever the content is eventually used.  The behavior I
decided on to minimize the evil is as follows:

* If the first and last spaces are in non-collapsing positions, two spaces is
  nbsp+space, three is space+nbsp+space, four or more is space+nbsp followed by
  the pattern for two less.
* If the first space has to be an nbsp so it doesn't collapse, three is instead
  nbsp+nbsp+space, four or more is nbsp+space followed by the pattern for two
  less.
* If the last space has to be nbsp, two is space+nbsp, three is
  space+nbsp+nbsp, four or more is space+nbsp followed by the pattern for two
  less.
* If the first and last space must both be nbsp, two is nbsp+nbsp, three is
  nbsp+space+nbsp, four or more nbsp+space followed by the pattern for two
  less.

This avoids nbsp at the end of a run except where it's needed, so words won't
appear indented if they wrap to the next line.  It avoids more than two nbsp's
in a row, so there won't be huge chunks of space that get wrapped all at once.
And it avoids nbsp at the beginning of a run except where it's needed or
if there are only two spaces in the run, so words won't have to wrap
unnecessarily.

This is still a huge headache, though.
-->

<!--
TODO: This doesn't work well if the input contains things that aren't supposed
to appear in HTML, like carriage returns or nulls.  Nor is it going to work
well if the current cursor position is in between two halves of a non-BMP
character.  This will result in unserializability.  The current spec disregards
this, as Chrome 14 dev does.
-->

<ol>
  <li><span>Delete the contents</span> of the <span>active range</span>, with
  <var>strip wrappers</var> false.
  <!--
  Chrome 14 dev does the deletion even if the value is empty.  Of course, other
  browsers don't expose this as an execCommand(), so no one else has any
  defined behavior in this case at all, so I follow Chrome.

  IE9, Firefox 7.0a2, Chrome 14 dev, and Opera 11.50 all don't strip wrappers,
  except that as usual, Gecko does if you select the whole wrapper, like
  {<b>foo</b>}.  Also, Chrome 14 dev seems to strip the wrapper and try
  recreating the style in cases like <b>[foo</b>bar], where it starts in a
  wrapper but ends after it; this doesn't always work so well, so I don't do
  it.  Firefox 7.0a2 also has the deletion set overrides for indeterminate
  state commands, so if you run insertText on [foo<b>bar</b>baz] it will make
  the result bold.

  These things don't make any sense to me, so I don't do them.  I set overrides
  based on the first editable text node in the range when deleting; preserve
  any wrappers at the start of the range; and restore the overrides in case
  preserving the wrappers isn't enough (like if they weren't set by deletion at
  all).  This behavior seems to closely match IE9.
  -->

  <li>If the <span>active range</span>'s [[startnode]] is neither
  <span>editable</span> nor an <span>editing host</span>, abort these steps.

  <li>If <var>value</var>'s [[strlen]] is greater than one:

  <ol>
    <li>For each [[strel]] <var>el</var> in <var>value</var>, take the
    <span>action</span> for <span>the <code title>insertText</code>
    command</span>, with <var>value</var> equal to <var>el</var>.

    <li>Abort these steps.
  </ol>

  <li>If <var>value</var> is the empty string, abort these steps.

  <li>If <var>value</var> is a newline (U+00A0), take the <span>action</span>
  for <span>the <code title>insertParagraph</code> command</span> and abort
  these steps.
  <!-- TODO: WebKit also does magic for tabs, wrapping them in a
  whitespace-preserving span.  Should we? -->

  <li>Let <var>node</var> and <var>offset</var> be the <span>active
  range</span>'s [[startnode]] and [[bpoffset]].

  <!--
  Just to be tidy, add to an existing text node if there is one.  Firefox 5.0a2
  only adds to an existing one if the range is in a text node.  IE9, Chrome 14
  dev, and Opera 11.11 also add to an existing text node if the range is in an
  element adjacent to a text node.  If there are two text nodes and it's in
  between, like foo{}bar, IE and Opera add to the first, Chrome adds to the
  second, although it probably doesn't matter in practice exactly which we
  choose.
  -->
  <li>If <var>node</var> has a [[child]] whose [[index]] is <var>offset</var>
  &minus; 1, and that [[child]] is a [[text]] node, set <var>node</var> to that
  [[child]], then set <var>offset</var> to <var>node</var>'s [[length]].

  <li>If <var>node</var> has a [[child]] whose [[index]] is <var>offset</var>,
  and that [[child]] is a [[text]] node, set <var>node</var> to that [[child]],
  then set <var>offset</var> to zero.

  <li>If <var>value</var> is a space (U+0020), and either <var>node</var> is an
  [[element]] whose [[resval]] for "white-space" is neither "pre" nor
  "pre-wrap" or <var>node</var> is not an [[element]] but its [[parent]] is an
  [[element]] whose [[resval]] for "white-space" is neither "pre" nor
  "pre-wrap", set <var>value</var> to a non-breaking space (U+00A0).
  <!-- This may change to a space when we canonicalize. -->

  <li><span>Record current overrides</span>, and let <var>overrides</var> be
  the result.

  <li>If <var>node</var> is a [[text]] node:

  <ol>
    <li>Call [[insertdata|<var>offset</var>, <var>value</var>]] on
    <var>node</var>.

    <li>Call [[selcollapse|<var>node</var>, <var>offset</var>]] on the
    [[contextobject]]'s [[selection]].

    <li>Call [[extend|<var>node</var>, <var>offset</var> + 1]] on the
    [[contextobject]]'s [[selection]].
  </ol>

  <li>Otherwise:

  <ol>
    <!-- If some text is inserted into <p><br></p> or similar, we no longer need
    the <br>. -->
    <li>If <var>node</var> has only one [[child]], which is a <span>collapsed
    line break</span>, remove its [[child]] from it.

    <li>Let <var>text</var> be the result of calling <code
    data-anolis-spec=domcore
    title=dom-Document-createTextNode>createTextNode(<var>value</var>)</code> on
    the [[contextobject]].

    <li>Call [[insertnode|<var>text</var>]] on the <span>active range</span>.

    <li>Call [[selcollapse|<var>text</var>, 0]] on the [[contextobject]]'s
    [[selection]].

    <li>Call [[extend|<var>text</var>, 1]] on the [[contextobject]]'s
    [[selection]].
  </ol>

  <li><span>Restore states and values</span> from <var>overrides</var>.

  <li><span>Canonicalize whitespace</span> at the <span>active range</span>'s
  [[rangestart]].

  <li><span>Canonicalize whitespace</span> at the <span>active range</span>'s
  [[rangeend]].

  <li>Call [[collapsetoend]] on the [[contextobject]]'s [[selection]].
</ol>

<!-- @} -->
<h3><dfn>The <code title>insertUnorderedList</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Toggle lists</span> with <var>tag name</var>
"ul".

<p><span>Indeterminate</span>: True if the <span>selection's list state</span>
is "mixed" or "mixed ul", false otherwise.

<p><span>State</span>: True if the <span>selection's list state</span> is "ul",
false otherwise.

<!-- @} -->
<h3><dfn>The <code title>justifyCenter</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Justify the selection</span> with
<var>alignment</var> "center".

<p><span>Indeterminate</span>: <span>Block-extend</span> the <span>active
range</span>.  Return true if among <span>visible</span> <span>editable</span>
[[nodes]] that are [[contained]] in the result and have no [[children]], at
least one has <span>alignment value</span> "center" and at least one does not.
Otherwise return false.
<!--
This roughly matches Chrome 14 dev, although not exactly.  Firefox 6.0a2 always
returns false.

As a general rule, ignoring nodes with children saves us from treating <div
align=left><div align=center>foo</div></div> as though it's indeterminate.
Chrome 14 dev seems to only pay attention to text nodes, instead, or something
like that.  At any rate, it fails on images.  Firefox 6.0a2 (for state and
value) gets tripped up by examples like the one given.

If we ever support centering of tables and similar, we'd want to pay attention
even to some nodes that do have children.
-->

<p><span>State</span>: <span>Block-extend</span> the <span>active range</span>.
Return true if there is at least one <span>visible</span> <span>editable</span>
[[node]] that is [[contained]] in the result and has no [[children]], and all
such [[nodes]] have <span>alignment value</span> "center".  Otherwise return
false.
<!--
IE9 throws exceptions in almost every case when querying the state of justify*,
and Opera 11.11 returns false in every case except some seemingly random crazy
ones.

Firefox 6.0a2 returns true for the state of justify* if anything in the range
has the right alignment, not if everything does.  This isn't consistent with
how state works for the inline commands, nor with WebKit.

Chrome 14 dev counts text-align on inline elements, which is wrong, because the
property has no effect.  It also counts it on non-editable elements, which is
wrong, because then the state for justify* wouldn't necessarily be true after
executing it.  (Chrome actually does align the non-editable elements, but
that's just a bug.)  Chrome further returns false for justify* if the
justification is just the default inherited justification, e.g., left for LTR.
This doesn't seem to make sense either.

State is kind of redundant here, because it's true if and only if indeterminate
is false and the value is equal to the desired value.  However, I'll support it
anyway, since Gecko/WebKit do.
-->

<p><span>Value</span>: <span>Block-extend</span> the <span>active range</span>,
and return the <span>alignment value</span> of the first <span>visible</span>
<span>editable</span> [[node]] that is [[contained]] in the result and has no
[[children]].  If there is no such [[node]], return "left".
<!--
Not bidi-safe, but it's a pretty marginal corner case.  Firefox 6.0a2 behaves
weirdly here: it keys off the start node of the active range, even if that's
not contained.  Thus {<div align=center>foo</div>} has value "left" and
indeterminate false, which would suggest that the whole selection is aligned
left, but that's not the case.  Chrome 14 dev returns the state cast to a
string, as usual.  Opera 11.11 always returns the empty string.
-->

<!-- @} -->
<h3><dfn>The <code title>justifyFull</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Justify the selection</span> with
<var>alignment</var> "justify".

<p><span>Indeterminate</span>: <span>Block-extend</span> the <span>active
range</span>.  Return true if among <span>visible</span> <span>editable</span>
[[nodes]] that are [[contained]] in the result and have no [[children]], at
least one has <span>alignment value</span> "justify" and at least one does not.
Otherwise return false.

<p><span>State</span>: <span>Block-extend</span> the <span>active range</span>.
Return true if there is at least one <span>visible</span> <span>editable</span>
[[node]] that is [[contained]] in the result and has no [[children]], and all
such [[nodes]] have <span>alignment value</span> "justify".  Otherwise return
false.

<p><span>Value</span>: <span>Block-extend</span> the <span>active range</span>,
and return the <span>alignment value</span> of the first <span>visible</span>
<span>editable</span> [[node]] that is [[contained]] in the result and has no
[[children]].  If there is no such [[node]], return "left".

<!-- @} -->
<h3><dfn>The <code title>justifyLeft</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Justify the selection</span> with
<var>alignment</var> "left".

<p><span>Indeterminate</span>: <span>Block-extend</span> the <span>active
range</span>.  Return true if among <span>visible</span> <span>editable</span>
[[nodes]] that are [[contained]] in the result and have no [[children]], at
least one has <span>alignment value</span> "left" and at least one does not.
Otherwise return false.

<p><span>State</span>: <span>Block-extend</span> the <span>active range</span>.
Return true if there is at least one <span>visible</span> <span>editable</span>
[[node]] that is [[contained]] in the result and has no [[children]], and all
such [[nodes]] have <span>alignment value</span> "left".  Otherwise return
false.

<p><span>Value</span>: <span>Block-extend</span> the <span>active range</span>,
and return the <span>alignment value</span> of the first <span>visible</span>
<span>editable</span> [[node]] that is [[contained]] in the result and has no
[[children]].  If there is no such [[node]], return "left".

<!-- @} -->
<h3><dfn>The <code title>justifyRight</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>: <span>Justify the selection</span> with
<var>alignment</var> "right".

<p><span>Indeterminate</span>: <span>Block-extend</span> the <span>active
range</span>.  Return true if among <span>visible</span> <span>editable</span>
[[nodes]] that are [[contained]] in the result and have no [[children]], at
least one has <span>alignment value</span> "right" and at least one does not.
Otherwise return false.

<p><span>State</span>: <span>Block-extend</span> the <span>active range</span>.
Return true if there is at least one <span>visible</span> <span>editable</span>
[[node]] that is [[contained]] in the result and has no [[children]], and all
such [[nodes]] have <span>alignment value</span> "right".  Otherwise return
false.

<p><span>Value</span>: <span>Block-extend</span> the <span>active range</span>,
and return the <span>alignment value</span> of the first <span>visible</span>
<span>editable</span> [[node]] that is [[contained]] in the result and has no
[[children]].  If there is no such [[node]], return "left".

<!-- @} -->
<h3><dfn>The <code title>outdent</code> command</dfn></h3>
<!-- @{ -->
<p><span>Action</span>:

<ol>
  <li>Let <var>items</var> be a list of all [[li]]s that are
  [[ancestorcontainers]] of the <span>active range</span>'s [[rangestart]]
  and/or [[rangeend]] [[bpnode]].

  <li>For each <var>item</var> in <var>items</var>, <span>normalize
  sublists</span> of <var>item</var>.
  <!-- This overnormalizes, but it seems like the simplest solution for now.
  -->

  <li><span>Block-extend</span> the <span>active range</span>, and let <var>new
  range</var> be the result.

  <li>Let <var>node list</var> be a list of [[nodes]], initially empty.

  <li>For each [[node]] <var>node</var> [[contained]] in <var>new range</var>,
  append <var>node</var> to <var>node list</var> if the last member of
  <var>node list</var> (if any) is not an [[ancestor]] of <var>node</var>;
  <var>node</var> is <span>editable</span>; and either <var>node</var> has no
  <span>editable</span> [[descendants]], or is an [[ol]] or [[ul]], or is an
  [[li]] whose [[parent]] is an [[ol]] or [[ul]].
  <!--
  This step is kind of weird.  For regular outdenting, we start at the inside
  and outdent going out, so that we remove the innermost indentation, on the
  theory that that will produce the cleanest markup (remove the most nodes).
  For lists, we remove the outermost indentation, because it makes a difference
  whether we remove inner or outer indentation, and logically we want to remove
  outer.  E.g.,

    <ol><li>foo</li><ul><li>bar</li></ul></ol>

  should become

    foo<ul><li>bar</li></ul>

  not

    foo<ol><li>bar</li></ol>.

  But this is a bit weird and I'm wondering if it's really correct.  TODO:
  Reexamine this.
  -->

  <li>While <var>node list</var> is not empty:

  <ol>
    <li>While the first member of <var>node list</var> is an [[ol]] or [[ul]]
    or is not the [[child]] of an [[ol]] or [[ul]], <span>outdent</span> it and
    remove it from <var>node list</var>.

    <li>If <var>node list</var> is empty, break from these substeps.

    <li>Let <var>sublist</var> be a list of [[nodes]], initially empty.

    <li>Remove the first member of <var>node list</var> and append it to
    <var>sublist</var>.

    <li>While the first member of <var>node list</var> is the [[nextsibling]]
    of the last member of <var>sublist</var>, and the first member of <var>node
    list</var> is not an [[ol]] or [[ul]], remove the first member of <var>node
    list</var> and append it to <var>sublist</var>.

    <li><span>Record the values</span> of <var>sublist</var>, and let
    <var>values</var> be the result.

    <li><span>Split the parent</span> of <var>sublist</var>.

    <li><span>Fix disallowed ancestors</span> of each member of
    <var>sublist</var>.

    <li><span>Restore the values</span> from <var>values</var>.
  </ol>
</ol>
<!-- @} -->

<h2 id=miscellaneous-commands>Miscellaneous commands</h2>

<h3><dfn>The <code title>copy</code> command</dfn></h3>
<!-- @{ -->
<!--
IE9 supports copy/cut/paste with a security warning.  Firefox reportedly only
supports it if you set a pref.  I didn't find info on other browsers, but in my
tests it didn't do anything.  I'm not going to try speccing it unless
implementers are interested in working out the security problems and trying to
get interop.  It seems like as of June 2011, everyone just uses Flash for this:

http://code.google.com/p/zeroclipboard/

So it would be nice if we could work out a more secure standardized substitute.
-->

<p><span>Action</span>: The user agent must either copy the current selection
to the clipboard as though the user had requested it, or raise a
[[SECURITY_ERR]] exception.  This specification does not define exactly how the
selection is to be copied to the clipboard, but the <a
href=http://dev.w3.org/2006/webapi/clipops/clipops.html>Clipboard API and
events</a> specification might be useful.

<p>User agents should exercise caution in respecting this <span>command</span>,
because sites could abuse it to confuse and annoy the user by overwriting the
clipboard with extremely long, obscene, or otherwise objectionable content.

<p>User agents may choose not to <span title=supported>support</span> this
<span>command</span> at all.  If a user agent will only honor the
<span>command</span> for some whitelisted sites depending on configuration, it
may either raise a [[SECURITY_ERR]] for non-whitelisted sites, or it may act as
though the <span>command</span> is <span title=supported>unsupported</span> on
those sites.
<!--
The idea is sites might catch the SECURITY_ERR and treat it differently from
NOT_SUPPORTED_ERR, like encouraging users to reconfigure their browser.
However, browsers might not want to encourage authors to tell users to
reconfigure their browser insecurely.
-->

<!-- @} -->
<h3><dfn>The <code title>cut</code> command</dfn></h3>
<!-- @{ -->
<!-- See comment for copy -->

<p><span>Action</span>: The user agent must either copy the current selection
to the clipboard and then delete it, as though the user had requested it, or
raise a [[SECURITY_ERR]] exception.  This specification does not define exactly
how the selection is to be deleted or copied to the clipboard, but the <a
href=http://dev.w3.org/2006/webapi/clipops/clipops.html>Clipboard API and
events</a> specification might be useful.

<p>User agents should exercise caution in respecting this command, because
sites could abuse it to confuse and annoy the user by overwriting the clipboard
with extremely long, obscene, or otherwise objectionable content.

<p>User agents may choose not to <span title=supported>support</span> this
<span>command</span> at all.  If a user agent will only honor the
<span>command</span> for some whitelisted sites depending on configuration, it
may either raise a [[SECURITY_ERR]] for non-whitelisted sites, or it may act as
though the <span>command</span> is <span title=supported>unsupported</span> on
those sites.

<!-- @} -->
<h3><dfn>The <code title>paste</code> command</dfn></h3>
<!-- @{ -->
<!-- See comment for copy -->

<p><span>Action</span>: The user agent must either <span>delete the
contents</span> of the <span>active range</span> and then paste the clipboard's
contents to the current cursor position, as though the user had requested it,
or raise a [[SECURITY_ERR]] exception.  This specification does not define
exactly how the clipboard is to be converted to HTML for pasting, but the <a
href=http://dev.w3.org/2006/webapi/clipops/clipops.html>Clipboard API and
events</a> specification might be useful.

<p>User agents should exercise caution in respecting this command,
because sites could abuse it to read private information from the clipboard.

<p>User agents may choose not to <span title=supported>support</span> this
<span>command</span> at all.  If a user agent will only honor the
<span>command</span> for some whitelisted sites depending on configuration, it
may either raise a [[SECURITY_ERR]] for non-whitelisted sites, or it may act as
though the <span>command</span> is <span title=supported>unsupported</span> on
those sites.

<!-- @} -->
<h3><dfn>The <code title>selectAll</code> command</dfn></h3>
<!-- @{ -->
<!--
Tested using roughly this:

http://software.hixie.ch/utilities/js/live-dom-viewer/saved/1018

IE9: A bit confusing.  The gist seems to be that it does selectAllChildren() on
the body, except sometimes it doesn't.

Firefox 5.0a2: Throws an exception if nothing in the document is editable,
which apparently it always does for execCommand().  If there's a body, it does
selectAllChildren() on that, and otherwise it does selectAllChildren() on the
root element.  If there's no root element, throws an exception.

Chrome 13 dev: If there's no root element, removes the selection.  If there's
a root element but no body, collapses the selection at (document, 0).  If
there's a body, it selects all the contents of the body, although that doesn't
mean the resulting anchor or focus actually are the body node (they're usually
text nodes).  But it seems to *avoid* selecting contenteditable stuff: if all
the visible things in the body are contenteditable, it removes all ranges from
the selection, and if some are, it freaks out and behaves oddly.  But
designMode doesn't trouble it.

Opera 11.11: Was characteristically uncooperative in my tests, and I didn't try
to investigate further.

The behavior here is relatively simple and largely matches implementations.
-->

<p><span>Action</span>:

<ol>
  <li>Let <var>target</var> be <span data-anolis-spec=html
  title=the-body-element-0>the body element</span> of the [[contextobject]].
  <!-- TODO: Is this right even for framesets? -->

  <li>If <var>target</var> is null, let <var>target</var> be the
  [[contextobject]]'s <code data-anolis-spec=domcore
  title=dom-Document-documentElement>documentElement</code>.
  <!-- TODO: Is this right even for documents whose root element is not an HTML
  element? -->

  <li>If <var>target</var> is null, call [[getselection]] on the
  [[contextobject]], and call [[removeallranges]] on the result.

  <li>Otherwise, call [[getselection]] on the [[contextobject]], and call
  [[selectallchildren|<var>target</var>]] on the result.
</ol>

<!-- @} -->
<h3><dfn>The <code title>styleWithCSS</code> command</dfn></h3>
<!-- @{ -->
<!-- IE9 and Opera 11.00 don't support this command.  By and large, they act
the way Gecko and WebKit do when styleWithCSS is off.  Gecko invented it, and
WebKit also supports it:

https://bugs.webkit.org/show_bug.cgi?id=13490

The default in Firefox 4.0 is off, while all other browsers behave like the
default is on (and IE/Opera give no way to turn it off), so I default it to on.
-->

<p><span>Action</span>: If <var>value</var> is an <span
data-anolis-spec=domcore>ASCII case-insensitive</span> match for the string
"false", set the <span>CSS styling flag</span> to false.  Otherwise, set the
<span>CSS styling flag</span> to true.
<!-- This matches Firefox 5.0a2.  Chrome 13 dev treats the case-sensitive
string "true" as true, the case-sensitive string "false" as false, and does
nothing for any other string.  I went with Gecko because this way there are
only two possible effects, not three, which makes it easier to reason about and
debug.  Also, Gecko made up the command and has larger market share, so this is
probably more web-compatible.  Cursory searches of Google Code and GitHub
suggest that authors almost always pass a boolean as the third argument when
using styleWithCSS, in which case the two behaviors work the same. -->

<p><span>State</span>: True if the <span>CSS styling flag</span> is true,
otherwise false.
<!-- This follows Chrome 13 dev.  Firefox 5.0a2 doesn't support
queryCommandState() for styleWithCSS. -->

<!-- @} -->
<h3><dfn>The <code title>useCSS</code> command</dfn></h3>
<!-- @{ -->
<!-- Supported by Firefox 4.0, but not IE9 or Opera 11.00 (which don't support
styleWithCSS either), nor by Chrome 12 dev (which does support styleWithCSS.
useCSS was the original feature in Mozilla 1.3, but the meaning is backward, so
Gecko added styleWithCSS as a replacement. -->

<p><span>Action</span>: If <var>value</var> is an <span
data-anolis-spec=domcore>ASCII case-insensitive</span> match for the string
"false", set the <span>CSS styling flag</span> to true.  Otherwise, set the
<span>CSS styling flag</span> to false.

<p>Since the effect of this command is the opposite of what one would expect,
user agents are encouraged to point authors to <code title="the stylewithcss
command">styleWithCSS</code> when <code title="the usecss
command">useCSS</code> is used, such as by logging a warning to an error
console.

<p class=XXX>The meaning of this command is backwards, and only Gecko supports
it.  It would be great if Gecko would agree to drop support, so that we could
get rid of it.

<!-- No state defined, since only Gecko supports useCss at all, and as of
Firefox 6.0a2, it doesn't support queryCommandState() for it. -->
<!-- @} -->

<h2>Additional requirements</h2>
<!-- @{ -->
<p class=XXX>It has been <a
href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024628.html>suggested</a>
that some things here need to be platform-dependent, not fully standardized.
For now I'm standardizing them anyway, because the large majority of behavior
should be platform-agnostic.  If anyone has suggestions as to particular things
that should be left up to platform behavior, please say so.

<p>When the user instructs the user agent to insert a line break inside an
<span>editing host</span>, such as by pressing the Enter key while the cursor
is in an <span>editable</span> [[node]], the user agent must take the
<span>action</span> for <span>the <code title>insertParagraph</code>
command</span>.

<p>When the user instructs the user agent to insert a line break inside an
<span>editing host</span> without breaking out of the current block, such as by
pressing Shift-Enter or Option-Enter while the cursor is in an
<span>editable</span> [[node]], the user agent must take the
<span>action</span> for <span>the <code title>insertLineBreak</code>
command</span>.

<p>When the user instructs the user agent to delete the previous character
inside an <span>editing host</span>, such as by pressing the Backspace key
while the cursor is in an <span>editable</span> [[node]], the user agent must
take the <span>action</span> for <span>the <code title>delete</code>
command</span>.

<p>When the user instructs the user agent to delete the next character inside
an <span>editing host</span>, such as by pressing the Delete key while the
cursor is in an <span>editable</span> [[node]], the user agent must take the
<span>action</span> for <span>the <code title>forwardDelete</code>
command</span>.

<p>When the user instructs the user agent to insert text inside an
<span>editing host</span>, such as by typing on the keyboard while the cursor
is in an <span>editable</span> [[node]], the user agent must take the
<span>action</span> for <span>the <code title>insertText</code> command</span>,
with <var>value</var> equal to the text the user provided.  If the user inserts
multiple characters at once or in quick succession, this specification does not
define whether it is treated as one insertion or several consecutive
insertions.
<!-- @} -->

<h2 class=no-num>Acknowledgements</h2>
<!-- @{ -->
<p>Thanks to:

<ul>
  <li>Google, for funding this work
  <li>Ian Hickson, for overseeing it
  <li>Julie Parent, Ojan Vafai, Alex Russel, and Eric Seidel for their <a
  href=http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2009-December/024627.html>research</a>
  on how browsers and other rich text editors behave in many common scenarios
  <li>
  Ehsan Akhgari,
  Tim Down,
  Markus Ernst,
  Daniel Glazman,
  Cameron Heavon-Jones,
  Ryosuke Niwa,
  Robert O'Callahan,
  Julie Parent,
  Simon Pieters,
  Michael A. Puls II,
  Rich Schwerdtfeger,
  Henri Sivonen,
  Smylers,
  Hallvord R. M. Steen,
  Roland Steiner,
  Ojan Vafai,
  Brett Zamir,
  and
  Boris Zbarsky
  for their feedback on drafts of this document and participation in related
  mailing list and Bugzilla discussions
  <li>Tab Atkins, Ian Hickson, Glenn Maynard, Ms2ger, Simon Pieters, and most
  of the rest of the <a href=irc://irc.freenode.net/whatwg>#whatwg</a> crowd
  for giving quick online feedback when I have questions or need to solicit
  opinions.
</ul>
<!-- @} -->
<script src=http://www.whatwg.org/specs/web-apps/current-work/dfn.js></script>
<!-- vim: set expandtab shiftwidth=2 tabstop=2 foldmarker=@{,@} foldmethod=marker indentexpr=: -->
