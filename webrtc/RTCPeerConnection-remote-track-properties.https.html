<!doctype html>
<meta charset=utf-8>
<meta name="variant" content="?interop-2026">
<meta name="variant" content="?rest">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="RTCPeerConnection-helper.js"></script>
<script>
'use strict';
const rest = !new URLSearchParams(location.search).has("interop-2026");
const interop2026 = !new URLSearchParams(location.search).has("rest");

async function setupPeerConnectionAndWaitForTrack(t, localTrack, localStream) {
  const pc1 = createPeerConnectionWithCleanup(t);
  pc1.addTrack(localTrack, localStream);
  const pc2 = createPeerConnectionWithCleanup(t);

  const haveTrackEvent = waitUntilEvent(pc2, "track");
  await exchangeOfferAnswer(pc1, pc2);
  const trackEvent = await haveTrackEvent;
  return [ trackEvent.track, trackEvent.streams[0] ];
}

function testStreamId(localStream, remoteStream, kind)
{
  test(() => {
    assert_equals(localStream.id, remoteStream.id);
  }, "Stream id for " + kind);
}

if (interop2026) {

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "video");
  const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
  assert_equals(remoteTrack.label, "remote video");
}, 'Track label for video');

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "audio");
  const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
  assert_equals(remoteTrack.label, "remote audio");
}, 'Track label for audio');

}

if (rest) {

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "video");
  const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
  testStreamId(localStream, remoteStream, "video");
}, 'Remote video track and stream');

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "audio");
  const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
  testStreamId(localStream, remoteStream, "audio");
}, 'Remote audio track and stream');

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "audio");
  const remoteTrackIds = new Set();
  for (let i = 0; i < 10; ++i) {
    const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
    remoteTrackIds.add(remoteTrack.id);
  }

  assert_greater_than(remoteTrackIds.size, 1, "Remote tracks should have their own id");
}, 'Remote audio track ID is different on different PCs');

promise_test(async t => {
  const [localTrack, localStream] = await createTrackAndStreamWithCleanup(t, "video");
  const remoteTrackIds = new Set();
  for (let i = 0; i < 10; ++i) {
    const [remoteTrack, remoteStream] = await setupPeerConnectionAndWaitForTrack(t, localTrack, localStream);
    remoteTrackIds.add(remoteTrack.id);
  }

  assert_greater_than(remoteTrackIds.size, 1, "Remote tracks should have their own id");
}, 'Remote video track ID is different on different PCs');

} // rest

</script>
