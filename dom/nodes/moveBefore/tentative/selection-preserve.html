<!DOCTYPE html>
<html>
<head>
<script src='/resources/testharness.js'></script>
<script src='/resources/testharnessreport.js'></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-actions.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
</head>

<body>
</body>

<script>
  'use strict';

async function select_range(t, anchorNode, extentNode) {
  await new test_driver.Actions()
      .pointerMove(0, 0, {origin: anchorNode})
      .pointerDown()
      .pointerMove(extentNode.clientWidth, extentNode.clientHeight, {origin: extentNode})
      .pointerUp()
      .send();
}

promise_test(async t => {
  document.body.innerHTML = `
    <div id=old_parent>
      <span>This text does not move</span>
      <span id=text>Text</span>
    </div>
    <div id=new_parent></div>`;
  getSelection().removeAllRanges();

  await select_range(t, text, text);

  // Don't first verify that `getSelection().anchorNode` is the expected
  // `<span id=text>` node that was selected above. If we did that, then at
  // least in Chromium browsers, this would generate a new Range capturing the
  // visual selection, which would be cached to the internal `DOMSelection`
  // object. Then the move would have two effects:
  //
  // 1. The internal visual selection would change as a result of
  //    `moveBefore()`
  // 2. But the Range representing the visual selection would remain
  //    unchanged, since it was cached to the `DOMSelection` object and not
  //    updated during `moveBefore()`. This means if (a) the visual selection,
  //    and (b) the "API-returned" selection Range are out of sync after
  //    `moveBefore()`, it would be impossible to detect the discrepancy
  //    without a reftest.
  //
  // So instead, we will just dive right into `moveBefore()`, and then compute
  // the selection range *after*, which will accurately represent the internal
  // visual selection that the user sees, and we can run our assertions on it.
  new_parent.moveBefore(text, null);
  assert_equals(getSelection().anchorNode, text.firstChild);
}, "moveBefore should not reset selection with preceding text");

promise_test(async t => {
  document.body.innerHTML = `
    <div id=old_parent>
      <span>This text does not move</span>
      <span id=text>Text</span>
      <span>This text ALSO does not move</span>
    </div>
    <div id=new_parent></div>`;
  getSelection().removeAllRanges();

  await select_range(t, text, text);

  new_parent.moveBefore(text, null);
  assert_equals(getSelection().anchorNode, text.firstChild);
}, "moveBefore should not reset selection with preceding and following text");
</script>
</html>
